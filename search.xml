<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分查找详解</title>
      <link href="/2020/02/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="模板一-left-lt-right-："><a href="#模板一-left-lt-right-：" class="headerlink" title="模板一(left &lt;= right)："></a>模板一(left &lt;= right)：</h2><ul><li><p>二分查找的最基础和最基本的形式。</p></li><li><p>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</p></li><li><p>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</p></li><li><p>初始条件：<code>left = 0, right = length-1</code></p></li><li><p>终止：<code>left &gt; right</code></p></li><li><p>向左查找：<code>right = mid-1</code></p></li><li><p>向右查找：<code>left = mid+1</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** x 的平方根</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现 `int sqrt(int x)` 函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">计算并返回 *x* 的平方根，其中 *x* 是非负整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = x / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> mid = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = (right - left)/<span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &gt; x)&#123;</span><br><span class="line">            right = (<span class="keyword">int</span>)(mid - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &lt; x)&#123;</span><br><span class="line">            left = (<span class="keyword">int</span>)(mid +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h2><ul><li>一种实现二分查找的高级方法。</li><li>查找条件需要访问元素的直接右邻居。</li><li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li><li>保证查找空间在每一步中至少有 2 个元素。</li><li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li></ul><ul><li>初始条件：<code>left = 0, right = length</code></li><li>终止：<code>left == right</code></li><li>向左查找：<code>right = mid</code></li><li>向右查找：<code>left = mid+1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">寻找峰值</span></span><br><span class="line"><span class="comment">峰值元素是指其值大于左右相邻值的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">你可以假设 nums[-1] = nums[n] = -∞。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">        mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板三"><a href="#模板三" class="headerlink" title="模板三"></a>模板三</h2><ul><li>实现二分查找的另一种方法。</li><li>搜索条件需要访问元素的直接左右邻居。</li><li>使用元素的邻居来确定它是向右还是向左。</li><li>保证查找空间在每个步骤中至少有 3 个元素。</li><li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li></ul><ul><li>初始条件：<code>left = 0, right = length-1</code></li><li>终止：<code>left + 1 == right</code></li><li>向左查找：<code>right = mid</code></li><li>向右查找：<code>left = mid</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="comment">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">你的算法时间复杂度必须是 O(log n) 级别。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果数组中不存在目标值，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            right = mid;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) left--;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) right++;</span><br><span class="line">            res[<span class="number">0</span>] = left;</span><br><span class="line">            res[<span class="number">1</span>] = right;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka详解</title>
      <link href="/2020/02/13/Kafka%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/13/Kafka%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>broker：Kafka 服务器，负责消息存储和转发 </li><li>topic：消息类别，Kafka 按照 topic 来分类消息 </li><li>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个 partition 上 </li><li>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的 唯一序号 </li><li>Producer：消息生产者 </li><li>Consumer：消息消费者 </li><li>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group </li><li>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故 障发现，partition leader 选举，负载均衡等功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发</title>
      <link href="/2020/02/12/Java%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/02/12/Java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p><ul><li><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</li><li><strong>同步方法</strong>：ynchronized修饰的方法是隐式同步，<strong>是通过方法调用指令读取运行时常量池中的ACC_SYNCHRONIZED标志来区分这个方法是否是同步方法。当方法调用的时候将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置了，如果被设置了，表明是一个同步方法，这个时候，执行线程将会先持有monitor对象(尝试持有，可能没有持有成功)，</strong>然后再访问执行方法，最后再方法完成的时候，无论是正常完成还是出现异常都会释放monitor。在方法执行期间其他任何一个线程都不能获得同一个monitor对象。如果在方法执行的时候出现了异常并且方法内部无法处理这个异常的时候，这个同步方法持有的monitor将会在异常抛到方法为的时候自动释放**</li></ul><h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p><p><img src="https://img-blog.csdn.net/20180806100435681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JveWVsZXZlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>Monitor可以类比为一个特殊的房间，这个房间中有一些被保护的数据，Monitor保证每次只能有一个线程能进入这个房间进行访问被保护的数据，进入房间即为持有Monitor，退出房间即为释放Monitor。</p><p>当一个线程需要访问受保护的数据（即需要获取对象的Monitor）时，它会首先在entry-set入口队列中排队（这里并不是真正的按照排队顺序），如果没有其他线程正在持有对象的Monitor，那么它会和entry-set队列和wait-set队列中的被唤醒的其他线程进行竞争（即通过CPU调度），选出一个线程来获取对象的Monitor，执行受保护的代码段，执行完毕后释放Monitor，如果已经有线程持有对象的Monitor，那么需要等待其释放Monitor后再进行竞争。</p><p>再说一下wait-set队列。当一个线程拥有Monitor后，经过某些条件的判断（比如用户取钱发现账户没钱），这个时候需要调用Object的wait方法，线程就释放了Monitor，进入wait-set队列，等待Object的notify方法（比如用户向账户里面存钱）。当该对象调用了notify方法或者notifyAll方法后，wait-set中的线程就会被唤醒，然后在wait-set队列中被唤醒的线程和entry-set队列中的线程一起通过CPU调度来竞争对象的Monitor，最终只有一个线程能获取对象的Monitor。</p><p>需要注意的是：</p><p>​    当一个线程在wait-set中被唤醒后，并不一定会立刻获取Monitor，它需要和其他线程去竞争<br>​    如果一个线程是从wait-set队列中唤醒后，获取到的Monitor，它会去读取它自己保存的PC计数器中的地址，从它调用wait方法的地方开始执行。</p><p><strong>Object的notify方法和wait方法详解</strong></p><p><strong>wait方法</strong><br>wait有三个重载方法，分别如下：</p><p>wait()<br>wait(long millis)<br>wait(long millis, int nanos) </p><p>后面两个传入了时间参数（nanos表示纳秒），表示如果指定时间过去还没有其他线程调用notify或者notifyAll方法来将其唤醒，那么该线程会自动被唤醒。</p><p><strong>调用obj.wait方法需要注意的是，当前线程必须获取到了obj的Monitor，才能去调用其wait方法，即wait必须放在同步方法或同步代码块中。（调用的是obj.wait()，而不是Thread.currentThread.wait()）</strong></p><p><strong>notify方法</strong><br>notify有两个方法notify和notifyAll，前者只能唤醒一个正在等待这个对象的monitor的线程，具体由JVM决定，后者则会唤醒所有正在等待这个对象的monitor的线程</p><p><strong>需要关注的点：</strong></p><p>调用notify方法，并不意味着释放了Monitor，必须要等同步代码块结束后才会释放Monitor<br>在调用notify方法时，必须保证其他线程处于wait状态，否则调用notify没有任何效果，导致之后其他线程永远处于堵塞状态</p><h3 id="synchronized-的锁膨胀过程"><a href="#synchronized-的锁膨胀过程" class="headerlink" title="synchronized 的锁膨胀过程"></a>synchronized 的锁膨胀过程</h3><p><img src="https://oscimg.oschina.net/oscnet/2bcc8161c52eb100d2c7c4c96c70d3c5823.jpg" alt="img"></p><ol><li>一个锁对象刚刚开始创建的时候，没有任何线程来访问它，它是可偏向的，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问他的时候，它会偏向这个线程。此时锁状态为无锁状态，锁标志位为 01。</li><li>当一个线程（线程 A）来获取锁的时，会首先检查所标志位，此时锁标志位为 01，然后检查是否为偏向锁，此时不为偏向锁，所以当前线程会修改对象头状态为偏向锁，同时将对象头中的 ThreadID 改成自己的 Thread ID。</li><li>如果再有一个线程（线程 B）过来，此时锁状态为偏向锁，该线程会检查 Mark Word 中记录的线程 ID 是否为自己的线程 ID，如果是，则获取偏向锁，执行同步代码块。如果不是，则利用 CAS 尝试替换 Mark Word 中的 Thread ID，成功，表示该线程（线程 B）获取偏向锁，执行同步代码块。</li><li>如果失败，则表明当前环境存在锁竞争情况，则执行偏向锁的撤销工作（<strong>这里有一点需要注意的是：偏向锁的释放并不是主动，而是被动的，什么意思呢？就是说持有偏向锁的线程执行完同步代码后不会主动释放偏向锁，而是等待其他线程来竞争才会释放锁</strong>）。撤销偏向锁的操作需要等到全局安全点才会执行，然后暂停持有偏向锁的线程，同时检查该线程的状态，如果该线程不处于活动状态或者已经退出同步代码块，则设置为无锁状态（线程 ID 为空，是否为偏向锁为 0 ，锁标志位为01）重新偏向，同时恢复该线程。若该线程活着，则会遍历该线程栈帧中的锁记录，检查锁记录的使用情况，如果仍然需要持有偏向锁，则撤销偏向锁，升级为轻量级锁。</li><li>在升级为轻量级锁之前，持有偏向锁的线程（线程 A）是暂停的，JVM 首先会在原持有偏向锁的线程（线程 A）的栈中创建一个名为锁记录的空间（Lock Record），用于存放锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 到原持有偏向锁的线程（线程 A）的锁记录中（官方称之为 Displaced Mark Word ），这时线程 A 获取轻量级锁，此时 Mark Word 的锁标志位为 00，指向锁记录的指针指向线程 A 的锁记录地址。</li><li>当原持有偏向锁的线程（线程 A）获取轻量级锁后，JVM 唤醒线程 A，线程 A 执行同步代码块，执行完成后，开始轻量级锁的释放过程。</li><li>对于其他线程而言，也会在栈帧中建立锁记录，存储锁对象目前的 Mark Word 的拷贝。JVM 利用 CAS 操作尝试将锁对象的 Mark Word 更正指向当前线程的 Lock Record，如果成功，表明竞争到锁，则执行同步代码块，如果失败，那么线程尝试使用自旋的方式来等待持有轻量级锁的线程释放锁。当然，它不会一直自旋下去，因为自旋的过程也会消耗 CPU，而是自旋一定的次数，如果自旋了一定次数后还是失败，则升级为重量级锁，阻塞所有未获取锁的线程，等待释放锁后唤醒。</li><li>轻量级锁的释放，会使用 CAS 操作将 Displaced Mark Word 替换会对象头中，成功，则表示没有发生竞争，直接释放。如果失败，表明锁对象存在竞争关系，这时会轻量级锁会升级为重量级锁，然后释放锁，唤醒被挂起的线程，开始新一轮锁竞争，注意这个时候的锁是重量级锁。</li></ol><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。</p><p>上面那段话，有两层语义</p><ol><li>保证可见性、不保证原子性</li><li>禁止指令重排序</li></ol></blockquote><p>使用它必须满足如下两个条件：</p><ol><li>对变量的写操作不依赖当前值；</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p><strong>happens-before</strong></p><p>happens-before是<a href="http://www.ujiuye.com/zt/javaqz/?1600gqy1220=" target="_blank" rel="noopener">Java</a>内存模型中定义的两个操作之间的偏序关系，即如果操作A在操作B之前先发生，那么操作A产生的操作结果，操作B可以观察到，或者说操作A的结果影响到操作B。可以认为Java内存模型中的这种与生俱来的原则实现了可见性和顺序性。</p><p>​        <strong>一、程序次序规则</strong></p><p>　　在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作</p><p>　　<strong>二、管程锁定规则</strong></p><p>　　一个unlock操作先行发生于后面对同一个锁的lock操作。</p><p>　　<strong>三、volatile变量规则</strong></p><p>　　对一个volatile变量的写入操作先行发生于后面对这个变量的读操作。</p><p>　　<strong>四、线程启动规则</strong></p><p>　　Thread对象的start()方法先行发生于此线程的每一个动作。</p><p>　　<strong>五、线程终止规则</strong></p><p>　　线程中的所有操作都先行发生于对此线程的终止检测。</p><p>　　<strong>六、线程中断规则</strong></p><p>　　对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。</p><p>　　<strong>七、对象终结规则</strong></p><p>　　一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><p>　　<strong>八、传递性</strong></p><p>　　如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以得出操作A先行发生于操作C。</p><h2 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="comment">//通过volatile关键字来确保安全</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么使用volatile进行修饰：</strong></p><p>实例化一个对象要分为三个步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ol><p>但是由于重排序的缘故，步骤2、3可能会发生重排序，其过程如下：</p><ol><li>分配内存空间</li><li>将内存空间的地址赋值给对应的引用</li><li>初始化对象</li></ol><p>如果2、3发生了重排序就会导致其他线程访问到还未初始化成功的对象。</p><p><strong>基于类的解决方案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案的根本就在于：<strong>利用classloder的机制来保证初始化instance时只有一个线程。JVM在类初始化阶段会获取一个锁，这个锁可以同步多个线程对同一个类的初始化</strong>。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><p> AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等）</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。 AQS通过内置的FIFO同步队列来完成线程获取资源的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><p> <strong>AQS主要提供了如下一些方法：</strong></p><ul><li><code>getState()</code>：返回同步状态的当前值；</li><li><code>setState(int newState)</code>：设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li><li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li><li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li><li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li><li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li><li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li><li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li><li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li><li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li><li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li><li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li><li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li><li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li><li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li></ul><p><strong>CLH队列</strong></p><p>AQS内部维护着一个FIFO队列，该队列就是CLH同步队列。 CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程的信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。 在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120810001.png" alt="img"></p><p><strong>入队：</strong></p><p>addWaiter(Node node)先通过快速尝试设置尾节点，如果失败（只设置一次），则调用enq(Node node)方法设置尾节点。</p><p>两个方法都是通过一个CAS方法compareAndSetTail(Node expect, Node update)来设置尾节点，该方法可以确保节点是线程安全添加的。在enq(Node node)方法中，AQS通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//新建Node</span></span><br><span class="line">      Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">      <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">      Node pred = tail;</span><br><span class="line">      <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">          node.prev = pred;</span><br><span class="line">          <span class="comment">//CAS设置尾节点</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">              pred.next = node;</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//多次尝试</span></span><br><span class="line">      enq(node);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node t = tail;</span><br><span class="line">          <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                  tail = head;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//设置为尾节点</span></span><br><span class="line">              node.prev = t;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                  t.next = node;</span><br><span class="line">                  <span class="keyword">return</span> t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>出队：</strong></p><p>CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><h3 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h3><h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>独占式，同一时刻仅有一个线程持有同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 自旋过程，其实就是一个死循环而已</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//当前线程的前驱节点是头结点，且同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取失败，线程等待--具体后面介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire(int arg)方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p><p>各个方法定义如下：</p><ol><li>tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</li><li>addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li>acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li>selfInterrupt：产生一个中断。</li></ol><p>acquireQueued方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 自旋过程，其实就是一个死循环而已</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//当前线程的前驱节点是头结点，且同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取失败，线程等待--具体后面介绍</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ol><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ol><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811001.png" alt="img"></p><h4 id="独占式获取响应中断"><a href="#独占式获取响应中断" class="headerlink" title="独占式获取响应中断"></a>独占式获取响应中断</h4><p>AQS提供了acquire(int arg)方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了acquireInterruptibly(int arg)方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先校验该线程是否已经中断了，如果是则抛出InterruptedException，否则执行tryAcquire(int arg)方法获取同步状态，如果获取成功，则直接返回，否则执行doAcquireInterruptibly(int arg)。</p><p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别。1.方法声明抛出InterruptedException异常，2.在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</p><h4 id="独占式超时获取"><a href="#独占式超时获取" class="headerlink" title="独占式超时获取"></a>独占式超时获取</h4><p>AQS除了提供上面两个方法外，还提供了一个增强版的方法：tryAcquireNanos(int arg,long nanos)。该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">          doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">//nanosTimeout &lt;= 0</span></span><br><span class="line">      <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//超时时间</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">      <span class="comment">//新增Node节点</span></span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//自旋</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="comment">//获取同步状态成功</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * 获取失败，做超时、中断判断</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="comment">//重新计算需要休眠的时间</span></span><br><span class="line">              nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">              <span class="comment">//已经超时，返回false</span></span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//如果没有超时，则等待nanosTimeout纳秒</span></span><br><span class="line">              <span class="comment">//注：该线程会直接从LockSupport.parkNanos中返回，</span></span><br><span class="line">              <span class="comment">//LockSupport为JUC提供的一个阻塞和唤醒的工具类，后面做详细介绍</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                      nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">              <span class="comment">//线程是否已经中断了</span></span><br><span class="line">              <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>针对超时控制，程序首先记录唤醒时间deadline ，deadline = System.nanoTime() + nanosTimeout（时间间隔）。如果获取同步状态失败，则需要计算出需要休眠的时间间隔nanosTimeout（= deadline - System.nanoTime()），如果nanosTimeout &lt;= 0 表示已经超时了，返回false，如果大于spinForTimeoutThreshold（1000L）则需要休眠nanosTimeout ，如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让nanosTimeout 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811002.png" alt="img"></p><h4 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h4><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS提供了release(int arg)方法释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">         Node h = head;</span><br><span class="line">         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">             unparkSuccessor(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法同样是先调用自定义同步器自定义的tryRelease(int arg)方法来释放同步状态，释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点（如何唤醒LZ后面介绍）。 这里稍微总结下：</p><blockquote><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><h4 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h4><p>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//获取失败，自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    /共享式节点</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果其前驱节点，获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//尝试获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。</p><p>tryAcquireShared(int arg)方法尝试获取同步状态，返回值为int，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。 acquireShared(int arg)方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)，这里就不做解释了。</p><h4 id="共享式同步状态的释放"><a href="#共享式同步状态的释放" class="headerlink" title="共享式同步状态的释放"></a>共享式同步状态的释放</h4><p>获取同步状态后，需要调用release(int arg)方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p><h3 id="阻塞和唤醒线程"><a href="#阻塞和唤醒线程" class="headerlink" title="阻塞和唤醒线程"></a>阻塞和唤醒线程</h3><p>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码我们可以看到，在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire(Node pred, Node node) 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//状态为signal，表示当前线程处于等待状态，直接放回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前驱节点状态 &gt; 0 ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前驱节点状态为Condition、propagate</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p><ol><li>如果当前线程的前驱节点状态为SINNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞</li><li>如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false</li></ol><p>如果 shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt() 方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态。其内部则是调用LockSupport工具类的park()方法来阻塞该方法。 当线程释放同步状态后，则需要唤醒该线程的后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用unparkSuccessor(Node node)唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//当前状态 &lt; 0 则设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为null，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，但是为何是从tail尾节点开始，而不是从node.next开始呢？原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程。最后调用LockSupport的unpark(Thread thread)方法唤醒该线程。</p><p><strong>LockSupport</strong></p><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成的。</p><blockquote><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</p></blockquote><p>每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在进程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。 LockSupport定义了一系列以park开头的方法来阻塞当前线程，unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120812001.png" alt="img"></p><p>park(Object blocker)方法的blocker参数，主要是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。 park方法和unpark(Thread thread)都是成对出现的，同时unpark必须要在park执行之后执行，当然并不是说没有不调用unpark线程就会一直阻塞，park有一个方法，它带了时间戳（parkNanos(long nanos)：为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用）。 park()方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unpark(Thread thread)方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，其内部的实现都是通过UNSAFE（sun.misc.Unsafe UNSAFE）来实现的，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure><p>两个都是native本地方法。Unsafe 是一个比较危险的类，主要是用于执行低级别、不安全的方法集合。尽管这个类和所有的方法都是公开的（public），但是这个类的使用仍然受限，你无法在自己的java程序中直接使用该类，因为只有授信的代码才能获得该类的实例。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率。</p><p><strong>ReentrantLock与synchronized的区别</strong></p><ol><li>与synchronized相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。</li><li>ReentrantLock还提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock更加适合（以后会阐述Condition）。</li><li>ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock会不容易产生死锁些。</li><li>ReentrantLock支持更加灵活的同步代码块，但是使用synchronized时，只能在同一个synchronized块结构中获取和释放。注：ReentrantLock的锁释放一定要在finally中处理，否则可能会产生严重的后果。</li><li>ReentrantLock支持中断处理，且性能较synchronized会好些。</li></ol><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>重入锁ReentrantLock是排他锁，排他锁在同一时刻仅有一个线程可以进行访问，但是在大多数场景下，大部分时间都是提供读服务，而写服务占有的时间较少。然而读服务不存在数据竞争问题，如果一个线程在读时禁止其他线程读势必会导致性能降低。所以就提供了读写锁。 读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞。 读写锁的主要特性：</p><ol><li>公平性：支持公平性和非公平性。</li><li>重入性：支持重入。读写锁最多支持65535个递归写入锁和65535个递归读取锁。</li><li>锁降级：遵循获取写锁、获取读锁在释放写锁的次序，写锁能够降级成为读锁</li></ol><p>读写锁ReentrantReadWriteLock实现接口ReadWriteLock，该接口维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p><p>ReentrantReadWriteLock与ReentrantLock一样，其锁主体依然是Sync(继承于AQS静态内部类)，它的读锁、写锁都是依靠Sync来实现的。所以ReentrantReadWriteLock实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样而已，它的读写锁其实就是两个类：ReadLock、writeLock，这两个类都是lock实现。 在ReentrantLock中使用一个int类型的state来表示同步状态，该值表示锁被一个线程重复获取的次数。但是读写锁ReentrantReadWriteLock内部维护着一对锁，需要用一个变量维护多种状态。所以读写锁采用“按位切割使用”的方式来维护这个变量，将其切分为两部分（2的16次方次方-1 = 65535 ，这是最大重入次数的由来），高16为表示读，低16为表示写。分割之后，读写锁是如何迅速确定读锁和写锁的状态呢？通过为运算。假如当前同步状态为S，那么写状态等于 S &amp; 0x0000FFFF（将高16位全部抹去），读状态等于S &gt;&gt;&gt; 16(无符号补0右移16位)。</p><p><strong>写锁</strong></p><p>写锁就是一个支持可重入的排他锁。</p><p><strong>写锁的获取</strong></p><p>写锁的获取最终会调用tryAcquire(int arg)，该方法在内部类Sync中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//当前锁个数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c != 0 &amp;&amp; w == 0 表示存在读锁</span></span><br><span class="line">        <span class="comment">//当前线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//超出最大范围</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//设置获取锁的线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和ReentrantLock的tryAcquire(int arg)大致一样，在判断重入时增加了一项条件：读锁是否存在。因为要确保写锁的操作对读锁是可见的，如果在存在读锁的情况下允许获取写锁，那么那些已经获取读锁的其他线程可能就无法感知当前写线程的操作。因此只有等读锁完全释放后，写锁才能够被当前线程所获取，一旦写锁获取了，所有其他读、写线程均会被阻塞。</p><p><strong>写锁的释放</strong></p><p>获取了写锁用完了则需要释放，WriteLock提供了unlock()方法释放写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放最终还是会调用AQS的模板方法release(int arg)方法，该方法首先调用tryRelease(int arg)方法尝试释放锁，tryRelease(int arg)方法为读写锁内部类Sync中定义了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放的线程不为锁的持有者</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">//若写锁的新线程数为0，则将锁的持有者设置为null</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁释放锁的整个过程和独占锁ReentrantLock相似，每次释放均是减少写状态，当写状态为0时表示 写锁已经完全释放了，从而等待的其他线程可以继续访问读写锁，获取同步状态，同时此次写线程的修改对后续的线程可见。</p><p><strong>读锁</strong></p><p>读锁为一个可重入的共享锁，它能够被多个线程同时持有，在没有其他写线程访问时，读锁总是或获取成功。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper详解</title>
      <link href="/2020/02/12/Zookeeper%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/12/Zookeeper%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper概览"><a href="#Zookeeper概览" class="headerlink" title="Zookeeper概览"></a>Zookeeper概览</h2><p><strong>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</strong></p><p><strong>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p><p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。</strong> 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</p><h2 id="Zookeeper重要概念"><a href="#Zookeeper重要概念" class="headerlink" title="Zookeeper重要概念"></a>Zookeeper重要概念</h2><ul><li><strong>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</strong></li><li><strong>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</strong></li><li><strong>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟</strong>（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。</li><li><strong>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong>（“读”多于“写”是协调服务的典型场景。）</li><li><strong>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</strong></li><li>ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提供数据节点监听服务。</li></ul><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>Session 指的是 ZooKeeper 服务器与客户端会话。<strong>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接</strong>。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。<strong>通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。</strong> Session的<code>sessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，<strong>只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</strong></p><p><strong>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</strong></p><h3 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h3><p><strong>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</strong></p><p>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><p><strong>在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</strong> 另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：<strong>SEQUENTIAL</strong>.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 aversion（当前ZNode的ACL版本）。</p><h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><p><strong>Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</strong></p><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限。</p><pre><code>- create：创建子节点的权限- read：获取子节点数据和子节点列表的权限- write：更新节点数据的权限- delete：删除子节点的权限- admin：设置节点ACL的权限</code></pre><p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><strong>在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色</strong>。</p><p><strong>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</strong></p><ul><li>leader：事务请求的唯一调度处理者，保证集群事务处理的顺序性；</li><li>follower：处理客户端非事务请求，转发事务请求给leader服务器；参与事务请求Proposal投票；参与leader选举</li><li>observer：和follower唯一区别在于它不参与leader选举，也不参与写操作的“过半写成功”策略，因此obverse机器可以在影响写性能的情况下提升集群的读性能</li></ul><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>Looking：</strong>选举状态。</p><p><strong>Following：</strong>Follower 节点（从节点）所处的状态。</p><p><strong>Leading：</strong>Leader 节点（主节点）所处状态。</p><p>最大 ZXID 也就是节点本地的最新事务编号，包含 epoch 和计数两部分。epoch 是纪元的意思，相当于 Raft 算法选主时候的 term。</p><p><strong>崩溃恢复流程：</strong></p><p><strong>1.Leader election</strong></p><p>​            选举阶段，此时集群中的节点处于 Looking 状态。它们会各自向其他节点发起投票，投票当中包含自己的服务器 ID 和最新事务 ID（ZXID）。</p><p>​            接下来，节点会用自身的 ZXID 和从其他节点接收到的 ZXID 做比较，如果发现别人家的 ZXID 比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的 ZXID 所属节点。</p><p>​            每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准 Leader，状态变为 Leading。其他节点的状态变为 Following。</p><p><strong>2. Discovery</strong></p><p>​        发现阶段，用于在从节点中发现最新的 ZXID 和事务日志。或许有人会问：既然 Leader 被选为主节        点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？</p><p>​        这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个 Leader 的情况。</p><p>​        所以这一阶段，Leader 集思广益，接收所有 Follower 发来各自的最新 epoch 值。Leader 从中选        出最大的 epoch，基于此值加 1，生成新的 epoch 分发给各个 Follower。</p><p>​        各个 Follower 收到全新的 epoch 后，返回 ACK 给 Leader，带上各自最大的 ZXID 和历史事务日        志。Leader 选出最大的 ZXID，并更新自身历史日志。</p><p><strong>3. Synchronization</strong></p><p>​        同步阶段，把 Leader 刚才收集得到的最新历史事务日志，同步给集群中所有的 Follower。只有当        半数 Follower 同步成功，这个准 Leader 才能成为正式的 Leader。</p><h3 id="原子广播"><a href="#原子广播" class="headerlink" title="原子广播"></a>原子广播</h3><ol><li><p>客户端发出写入数据请求给任意Follower。</p></li><li><p>Follower 把写入数据请求转发给 Leader。</p></li><li><p>Leader 采用二阶段提交方式，先发送 Propose 广播给 Follower。</p></li><li><p>Follower 接到 Propose 消息，写入日志成功后，返回 ACK 消息给 Leader。</p></li><li><p>Leader 接到半数以上 ACK 消息，返回成功给客户端，并且广播 Commit 请求给 Follower。</p></li></ol><p>ZAB 协议既不是强一致性，也不是弱一致性，而是处于两者之间的单调一致性。它依靠事务 ID 和版本号，保证了数据的更新和读取是有序的。</p><h2 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h2><p>ZooKeeper是个 CP的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性（注：也就 是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果）。但是别忘了，ZooKeeper是分布式协调服务，它的 职责是保证数据（注：配置数据，状态数据）在其管辖下的所有服务之间保持同步、一致；所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性)</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql详解</title>
      <link href="/2020/02/10/Mysql%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/10/Mysql%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql逻辑结构"><a href="#Mysql逻辑结构" class="headerlink" title="Mysql逻辑结构"></a>Mysql逻辑结构</h2><p><img src="https://img2018.cnblogs.com/blog/1075436/201902/1075436-20190215135724690-741976355.png" alt="img"></p><h3 id="长连接-and-短连接"><a href="#长连接-and-短连接" class="headerlink" title="长连接 and 短连接"></a>长连接 and 短连接</h3><p><strong>1、什么是长链接？</strong><br>数据库里面，长连接是连接成功后，如果客户端持续有请求，则一直使用同一个链接。</p><p><strong>2、什么是短连接？</strong><br>短连接则是指每次执行完很少的几次查询就断开连接，下次查询重新建立一个</p><p><strong>3、尽量使用长链接</strong><br>建立连接的过程通常是比较复杂的，所以我建议你在使用中尽量减少建立的动作，也就是使用长连接。</p><h3 id="长连接的缺点和解决方案"><a href="#长连接的缺点和解决方案" class="headerlink" title="长连接的缺点和解决方案"></a>长连接的缺点和解决方案</h3><p><strong>1、为什么MySQL占用内存涨得特别快</strong><br>但是全部是用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，</p><p>这是因为MySQL在执行过程中临时使用的内存管理在连接对象里面的，这些资源会在连接断开的时候才释放，</p><p>所以如果长链接积累下来，可能导致内存占用大，被系统强行杀掉，从现象看就是MySQL异常重启了</p><p><strong>2、如何解决MySQL占用内存涨得特别快</strong><br>1、定期断开长链接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再连接</p><p>2、如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行<strong>mysql_reset_connection</strong>来重新初始化连接资源，这个过程不需要重连或重新做权限验证，但是会将连接回复到刚刚创建完时的状态；</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ol><li>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，如果有，就直接返回给客户端</li><li>如果语句不在查询缓存中，就会继续后面的执行阶段。</li><li>执行完成后，执行结果会被存入查询缓存中，</li><li>如果查询命中缓存MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高</li></ol><p><strong>为什么大多数情况下不建议使用查询缓存？</strong></p><p>1、查询缓存的失效非常频繁，只要有一个表更新，这个表上所有的查询缓存都被清空<br>2、对于更新压力大的数据库来说，查询缓存的命中率会非常低，<br>3、除非你的业务就是有一张静态表，很长时间才会更新一次(比如一个系统配置表)</p><p><strong>1、默认语句不实用查询缓存</strong></p><p>MySQL提供的按需使用的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type 设置成 DEMAND</span><br></pre></td></tr></table></figure><p><strong>2、确定需要查询缓存的语句</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p><strong>1、优化器的作用</strong><br>1、在表里面有多个索引的时候，决定使用哪个索引</p><p>2、多表关联(ioin)的时候，决定各个表的链接顺序</p><p><strong>2、举例说明</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><p>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于20<br>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于10</p><p>这两种执行方法的逻辑结果时一样的，但是执行的效率会有不同，而优化器的作用就是决定选择哪一个方案</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p><strong>1、没有索引的执行流程</strong><br>1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中<br>2、调用引擎接口取”下一行”，重复相同的判断逻辑，直到取到这个表的最后一行<br>3、执行器将上述遍布过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p><strong>2、有索引的执行流程</strong><br>第一调用的是”取满足条件的第一行”这个接口，<br>之后循环取”满足条件的下一行”</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><strong>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</strong></p><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>Undo Log 是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</p><p><strong>缺点</strong></p><p>如果每个事务提交前都将数据和undo log写入磁盘(undo log的写入一定先于数据，因为保证undo log完整可以用来回滚事务)，这样会导致大量磁盘IO，因此性能很低；如果将数据缓存一段时间，这样会丧失持久性。所以出现了redolog.</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次更新操作都需要写进磁盘，然后磁盘找到对应的那条数据，然后在更新，整个过程的IO成本，查找成本都很高。为了解决这个问题，mysql使用WAL（WriteAhead Logging，预写式日志）：先写日志，再写磁盘；</p><p>redo log是位于mysql引擎层的（mysql大体分为server层和引擎层），并且其大小是固定的，可以循环写入（使用双指针保证可写入位置，write pos是当前记录的位置，一边写一边后移；checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文 件）</p><p>redo log保证了mysql具有crash-safe（崩溃安全）能力，</p><p><strong>保证redo log能够有比较好的IO性能</strong></p><p>A. 尽量保持Redo Log存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。<br>B. 批量写入日志。日志并不是直接写入文件，而是先写入redo log buffer.当需要将日志刷新到磁盘时(如事务提交),将许多日志一起写入磁盘.<br>C. 并发的事务共享Redo Log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的：<br>记录1: &lt;trx1, insert …&gt;<br>记录2: &lt;trx2, update …&gt;<br>记录3: &lt;trx1, delete …&gt;<br>记录4: &lt;trx3, update …&gt;<br>记录5: &lt;trx2, insert …&gt;<br>D. 因为C的原因,当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。<br>E. Redo Log上只进行顺序追加的操作，当一个事务需要回滚时，它的Redo Log记录也不会从Redo Log中删除掉。</p><h3 id="undo-redo"><a href="#undo-redo" class="headerlink" title="undo + redo"></a>undo + redo</h3><p><strong>流程：</strong></p><p><strong>假设 有A  值为1.</strong></p><p><strong>A.事务开始.</strong></p><p><strong>B.记录A=1到undo log.</strong></p><p><strong>C.修改A=3.</strong></p><p><strong>D.记录A=3到redo log.（此时redolog处于prepare状态）</strong></p><p><strong>E.告诉执行器，随时可以提交事务，然后执行器生成这个操作的binlog，并把binlog写入磁盘</strong></p><p><strong>F.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，事务完成。</strong></p><p><strong>Undo + Redo事务的特点</strong><br>A. 为了保证持久性，必须在事务提交前将Redo Log持久化。<br>B. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。<br>C. Redo Log 保证事务的持久性。<br>D. Undo Log 保证事务的原子性。<br>E. 有一个隐含的特点，数据必须要晚于redo log写入持久存储。</p><h3 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h3><p>redolog 是InnoDB特有的，是物理日志 ，记录的是“在某个数据页上做了什么修改”；，通过循环写，空间固定会用完；</p><p>binlog是server层实现，所有引擎都可以使用，逻辑日志，记录原始逻辑，比如“给ID=2这一行的c字段加1 ”；追加写入，不会覆盖以前的日志。只依靠binlog是没有crash-safe能力的。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p><img src="//qx-ljy.cn/2020/02/10/Mysql详解/C:%5CUsers%5C%E5%A4%95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200210133758200.png" alt="image-20200210133758200"></p><p><strong>不用两阶段提交，会产生什么？</strong></p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异<br>常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回<br>来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份<br>日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这<br>个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以<br>后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日<br>志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是<br>1，与原库的值不同。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务的特性</strong>：ACID ： 原子性    一致性    隔离性    持久性</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p><strong>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。</strong><br><strong>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。</strong><br><strong>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。</strong><br><strong>串行化：我的事务尚未提交，别人就别想改数据。</strong><br><strong>这4种隔离级别，并行性能依次降低，安全性依次提高。</strong></p><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><p>在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</p><p>在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。</p><p>“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念；</p><p>而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。</p><p><strong>默认使用读提交。</strong></p><p><strong>1、回滚日志什么时候删除？</strong></p><p>系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除</p><p><strong>2、什么时候不需要了？</strong></p><p>当系统里没有比这个回滚日志更早的read-view的时候。</p><p><strong>3、为什么尽量不要使用长事务</strong></p><p>长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p><h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理.</p><p>有2中不同的恢复策略：</p><blockquote><p>A. 进行恢复时，只重做已经提交了的事务。<br>B. 进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些<br>未提交的事务。</p></blockquote><p><strong>MySQL数据库InnoDB存储引擎使用了B策略</strong></p><p> InnoDB存储引擎中的恢复机制有几个特点：</p><p><strong>A. 在重做Redo Log时，并不关心事务性。</strong> 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。<br><strong>B. 使用B策略就必须要将Undo Log持久化，而且必须要在写Redo Log之前将对应的Undo Log写入磁盘。</strong>Undo和Redo Log的这种关联，使得持久化变得复杂起来。<strong>为了降低复杂度，InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中。这样undo log就可以象数据一样缓存起来，而不用在redo log之前写入磁盘了。</strong><br>包含Undo Log操作的Redo Log，看起来是这样的：<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert …&gt;<br>记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx2, update …&gt;<br>记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx3, delete …&gt;<br>C. <strong>既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？</strong><br><strong>确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中。</strong><br>一个回滚了的事务的Redo Log，看起来是这样的：<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert A…&gt;<br>记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx1, update B…&gt;<br>记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx1, delete C…&gt;<br>记录7: &lt;trx1, insert C&gt;<br>记录8: &lt;trx1, update B to old value&gt;<br>记录9: &lt;trx1, delete A&gt;</p><p><strong>一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性.</strong></p><h3 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h3><h4 id="1、脏读："><a href="#1、脏读：" class="headerlink" title="1、脏读："></a>1、脏读：</h4><p>  当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，<br>  另一个事务B 来读取了修改后的内容并且使用了，<br>  之后事务A提交了，此时就引起了脏读。 </p><p>  <strong>此情况仅会发生在： 读未提交的的隔离级别.</strong></p><h4 id="2、不可重复读："><a href="#2、不可重复读：" class="headerlink" title="2、不可重复读："></a>2、不可重复读：</h4><p>在一个事务A中多次操作数据，在事务操作过程中(未最终提交)，事务B也才做了处理，并且该值发生了改变，这时候就会导致A在事务操作的时候，发现数据与第一次不一样了。 就是不可重复读。</p><p>  <strong>此情况仅会发生在：读未提交、读提交的隔离级别.</strong></p><h4 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h4><p>  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</p><p>幻读是指当事务不是独立执行时发生的一种现象.</p><p>例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。</p><p>同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。</p><p>那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样. 一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</p><p>  <strong>此情况会回发生在：读未提交、读提交、可重复读的隔离级别.</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h3><p><img src="https://img2018.cnblogs.com/blog/1075436/201903/1075436-20190306160941579-1127184320.png" alt="img"></p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p><strong>索引类型</strong></p><p><strong>主键索引：</strong>主键索引的叶子节点存的是整行的数据(聚簇索引)，</p><p><strong>非主键索引：</strong>非主键索引的叶子节点内容是主键的值(二级索引) </p><p><strong>主键索引和普通索引的区别：</strong></p><p>1、主键索引只要搜索ID这个B+Tree即可拿到数据。<br>        如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树</p><p>2、普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)<br>        如果语句是 select * from T where k=k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到到         ID 的值为 500，再到 ID 索引树搜索一次。这个过程为回表也就是说，基于非主键索引的查询需要        多扫描一棵树</p><p><strong>也就是说，基于非主键索引的查询需要多扫描一棵树，因此，我们在应用中应该尽量使用主键查询</strong></p><p><strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong></p><p><strong>最左前缀原则</strong></p><p><strong>不只是索引的全部定义，只要满足最左前缀，就可以可利用索引来加速检索、这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</strong></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。<br>MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：</p><ul><li>1、数据更新语句（数据的增删改）</li><li>2、数据定义语句（包括建表、修改表结构等）</li><li>3、更新类事务的提交语句。</li></ul><p><strong>全局锁使用场景</strong></p><p>全局锁的典型使用场景是，做全库逻辑备份、也就是把整库每个表都 select 出来存成文本。</p><p><strong>缺点</strong></p><p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</p><ol><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟</li></ol><p><strong>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction的时候，导数据之前就会启动一个事务（可重复读），来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</strong></p><p><strong>一致性读是好，但前提是引擎要支持这个隔离级别</strong>。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL 命令了。</p><p><strong>所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。</strong>这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。  </p><p>你也许会问，既然要全库只读，<strong>为什么不使用 set global readonly=true 的方式呢？</strong>确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。<strong>而将整个 库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</strong></li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p><strong>表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></p><p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查<br>询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查（这里增删改查对于表中数据，所以出现脏读、幻读、不可重复读；记住这是表级锁，为的是表结构统一）。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><p>我们今天就主要来聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。</p><p><strong>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</strong></p><p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如<strong>两阶段锁</strong>。</p><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><h3 id="死锁和死锁等待"><a href="#死锁和死锁等待" class="headerlink" title="死锁和死锁等待"></a>死锁和死锁等待</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p><strong>当出现死锁以后，有两种策略</strong></p><p><strong>一种策略是，直接进入等待，直到超时。</strong>这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。</p><p><strong>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p><p><strong>1、InnoDB 中，innodb_lock_wait_timeout 的默认值是？</strong></p><p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s</p><p><strong>2、innodb_lock_wait_timeout 设置大小的影响</strong></p><p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，<strong>意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的</strong>。但是，我们又不可能直接把这个<strong>时间设置成一个很小的值</strong>，比如 1s。这样当出现死锁的时候，确实很快就可以解开，<strong>但如果不是死锁，而是简单的锁等待呢？</strong>所以，*<em>超时时间设置太短的话，会出现很多误伤。 *</em></p><p><strong>正常情况下我们采用第二种策略</strong></p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect 的默认值本身就是 on。<strong>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</strong>你可以想象一下这个过程<strong>：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</strong></p><p><strong>第二种策略存在的问题解决</strong></p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复<br>杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就<br>是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU<br>资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><ol><li><p><strong>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</strong></p></li><li><p><strong>控制并发度</strong>  </p><p> 根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，<strong>在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多</strong>。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p><p> 因此，<strong>这个并发控制要做在</strong></p><p> 1、数据库服务端。</p><p> 2、如果你有中间件，可以考虑在中间件实现；基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了</p><p> 3、如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p></li></ol><p><strong>悲观锁(Pessimistic Locking)，悲观锁是指在数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制实现。</strong></p><p><strong>乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。</strong></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>（1）<code>Master</code>服务器将数据的改变记录二进制<code>Binlog</code>日志，当<code>Master</code>上的数据发生改变时，则将其改变写入二进制日志中；</p><p>（2）<code>Slave</code>服务器会在一定时间间隔内对<code>Master</code>二进制日志进行探测其是否发生改变，如果发生改变，则开始一个<code>I/OThread</code>请求<code>Master</code>二进制事件</p><p>（3）同时主节点为每个<code>I/O</code>线程启动一个<code>Dump</code>线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后<code>I/OThread</code>和<code>SQLThread</code>将进入睡眠状态，等待下一次被唤醒。</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty详解</title>
      <link href="/2020/02/09/Netty%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/09/Netty%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h2><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>时间复杂度 :  大于等于 O（n）</p><p>它仅知道，有IO时间发生，却不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读取数据的流，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间越长。</p><p><strong>select本质</strong>上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p><p>   一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p><p>​    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>时间复杂度：大于等于 O(n)</p><p>poll本质和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它基于链表来存储。</p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。          </p><p>2、poll还有一个特点是“<strong>水平触发</strong>”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>时间复杂度：O(1)</p><p>epoll可以理解为 event poll,不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的IO事件通知我们。所以说epoll实际上是事件驱动（每个事件关联fd）的，此时我们对这些流的操作时无意义的。</p><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>epoll为什么要有EPOLLET触发模式？</strong></p><p>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</strong></p><p><strong>epoll的优点：</strong></p><p>1、<strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；<br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p><p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><p><strong>总结：</strong></p><p><strong>综上，在选择select，p**</strong>oll，epoll时要根据具体的使用场合以及这三种方式的自身特点。**</p><p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p><p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong> </p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。 </p><h2 id="netty中的水平触发和边缘触发"><a href="#netty中的水平触发和边缘触发" class="headerlink" title="netty中的水平触发和边缘触发"></a>netty中的水平触发和边缘触发</h2><p>在非阻塞IO中，通过Selector选出准备好的fd进行操作。有两种模式，一是水平触发（LT），二是边缘触发（ET）。</p><p>在LT模式下，只要某个fd还有数据没读完，那么下次轮询还会被选出。而在ET模式下，只有fd状态发生改变后，该fd才会被再次选出。ET模式的特殊性，使在ET模式下的一次轮询必须处理完本次轮询出的fd的所有数据，否则该fd将不会在下次轮询中被选出。</p><p><strong>在Netty中，NioChannel体系是水平触发，EpollChannel体系是边缘触发。</strong></p><h3 id="NioServerSocketChannel-水平触发"><a href="#NioServerSocketChannel-水平触发" class="headerlink" title="NioServerSocketChannel 水平触发"></a>NioServerSocketChannel 水平触发</h3><p>从源码中，NioServerSocketChannel对一次轮询出的SelectionKey.OP_ACCEPT的处理来看：</p><p>AbstractNioMessageChannel#read()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">     <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">     <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">     allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">     Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                 <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                     closed = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 allocHandle.incMessagesRead(localRead);</span><br><span class="line">             &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             exception = t;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">             readPending = <span class="keyword">false</span>;</span><br><span class="line">             pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">         &#125;</span><br><span class="line">         readBuf.clear();</span><br><span class="line">         allocHandle.readComplete();</span><br><span class="line">         pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">             closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">             pipeline.fireExceptionCaught(exception);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">             inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                 close(voidPromise());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">             removeReadOp();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 1、使用allocHandle维护一个大小合适的缓冲区</p><p>2、循环调用doReadMessage(readBuf)，该方法内部是调用java nio中的    serverSocketChannel.accept() 获得SocketChannel，并包装成netty中的NioSocketChannel，然后放入readBuf。</p><p>3、pipeline.fireChannelRead(readBuf.get(i))，让每一个NioSocketChannel经过NioServerSocketChannel的handler链进行处理。</p><p>4、finally{…}中，调用removeReadOp()，移除该Channel的SelectionKey中的OP_ACCEPT值</p><p>水平触发主要体现在4，Netty为了使每次轮询负载均衡，不至于一次轮询要的readBuf内存过大，所以限制了readBuf大小，导致每次轮询所能够处理的数据有限，这就可能使一次轮询不回读完fd中的数据。在finally{…}中移除了OP_ACCEPT是因为他工作在LT触发模式下，即使移除了，只要fd中还有数据，下次轮询仍然会把该fd选出进行处理。</p><h3 id="EpollChannel-边缘触发"><a href="#EpollChannel-边缘触发" class="headerlink" title="EpollChannel 边缘触发"></a>EpollChannel 边缘触发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">epollInReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">            <span class="keyword">if</span> (shouldBreakEpollInReady(config)) &#123;</span><br><span class="line">                clearEpollIn0();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();</span><br><span class="line">            allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">            allocHandle.reset(config);</span><br><span class="line">            allocHandle.attemptedBytesRead(<span class="number">1</span>);</span><br><span class="line">            epollInBefore();</span><br><span class="line"></span><br><span class="line">            Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        allocHandle.lastBytesRead(socket.accept(acceptedAddress));</span><br><span class="line">                        <span class="keyword">if</span> (allocHandle.lastBytesRead() == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        readPending = <span class="keyword">false</span>;</span><br><span class="line">                        pipeline.fireChannelRead(newChildChannel(allocHandle.lastBytesRead(), acceptedAddress, <span class="number">1</span>,</span><br><span class="line">                                                                 acceptedAddress[<span class="number">0</span>]));</span><br><span class="line">                    &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    exception = t;</span><br><span class="line">                &#125;</span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.fireExceptionCaught(exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                epollInFinally(config);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>epoll同样采用了allocHandle来使每次轮询负载均衡，不同的是finally{…}移除SeletionKey中该事件的处理。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">epollInFinally</span><span class="params">(ChannelConfig config)</span> </span>&#123;</span><br><span class="line">    maybeMoreDataToRead = allocHandle.isEdgeTriggered() &amp;&amp; allocHandle.maybeMoreDataToRead();</span><br><span class="line">    <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">        clearEpollIn();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readPending &amp;&amp; maybeMoreDataToRead) &#123;</span><br><span class="line">        executeEpollInReadyRunnable(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果fd中仍有未读完的数据，必须调用executeEpollReadRunnable(config)，自己触发EPOLLIN event，否则会因为没有读完数据导致socket不可用。</p><p>总结：<br> Netty为了使每次轮询负载均衡，限制了每次从fd中读取数据的最大值，造成一次读事件处理并不会读完fd中的所有数据。在NioServerSocketChannel中，由于其工作在LT模式下，所以不需要做特殊处理，在处理完一个事件后直接从SelectionKey中移除该事件即可，如果有未读完的数据，下次轮询仍会获得该事件。而在EpollServerSocketChannel中，由于其工作在ET模式下，如果一次事件处理不把数据读完，需要手动地触发一次事件作为补偿，否则下次轮询将不会有触发的事件。</p><h2 id="netty解决nio的空轮训bug"><a href="#netty解决nio的空轮训bug" class="headerlink" title="netty解决nio的空轮训bug"></a>netty解决nio的空轮训bug</h2><ul><li><p>对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，</p></li><li><p>若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。</p></li><li><p>重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</p></li></ul><h2 id="netty组件关系"><a href="#netty组件关系" class="headerlink" title="netty组件关系"></a>netty组件关系</h2><ul><li>一个 EventLoopGroup 包含一个或多个 EventLoop。</li><li>一个 EventLoop 在它的生命周期内只能与一个Thread绑定。</li><li>所有有 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理。</li><li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li><li>一个 EventLoop 可被分配至一个或多个 Channel 。</li><li>每一个新创建的Channel 都将会被分配一个新的ChannelPipeline</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链</title>
      <link href="/2020/02/07/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2020/02/07/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链共识算法"><a href="#区块链共识算法" class="headerlink" title="区块链共识算法"></a>区块链共识算法</h2><p>POW：Proof of Work，工作证明。<br>比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。</p><p>POS：Proof of Stake，股权证明。<br>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p><p>DPOS：Delegated Proof of Stake，委任权益证明<br>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p><h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p>一种网络数据同步协议–gossip，它的主要作用是致力于账本数据的安全传输，保证不同节点之间状态的同步和完整。</p><p>  在fabric的网络中gossip的message是持续存在的，一个peer节点会不断、实时的接收到来自同一channel其他peers的账本数据。每一个gossip message都携带发送方的签名信息，这可以使得接受方轻易的辨别对方的身份和校验消息的完整性和合法性。当一个peer由于延迟、网络故障等原因而错过block数据的情况发生时，可以通过从其他拥有该block的peer处去同步，从而保证了账本的完整性和一致性。</p><p>  gossip 协议的三个主要功能：</p><ul><li>peer发现和channel membership管理： 通过持续的去辨别同channel内其他peer的身份是否合法 和 校验peer是否宕机，来维持和管理channel内其他peers的信息</li><li>账本数据的传播： 同channel内任何一个peer在发现block数据缺失时，可以从其他peer拷贝正确的block数据</li><li>传输加速： 通过点对点的传输方式去更新账本，可以使得新上线的peer快速同步数据</li></ul><p>gossip协议主要是一个P2P的网络传输协议。fabric主要通过此协议来进行区块的同步。  </p><p>在gossip协议中 一个peer同时从多个peer接收数据，然后会从同channel中其他的peers选择出来一定数量N的peer，去将数据发送到这些被选中的peer中，N是一个可配置的常量。peer 也可以去主动拉去数据而不是被动的等待，整个过程不断的重复，直到ledger状态和channel的membership达到同步的状态。当一个channel的新块产生后每一个组织的leader会去从orderer节点去拉取该块，然后通过gossip协议去广播。</p><h3 id="51-算力"><a href="#51-算力" class="headerlink" title="51%算力"></a>51%算力</h3><p>比特币白皮书中，有过这样的表述：<strong>诚实节点控制算力的总和，大于有合作关系的攻击者算力的总和，该系统就是安全的。</strong></p><p>换句说，当系统中有合作关系的恶意节点所控制的算力，超过诚实节点所控制的算力，系统就是有被攻击的风险。这种由恶意节点控制超过50%算力所发起的攻击，称为51%算力攻击（51% Attack）。</p><p>那是不是所有的加密货币系统都有可能遭遇51%算力攻击的风险呢？其实并不是的，只有基于PoW（工作量证明）共识机制的加密货币，才存在51%算力攻击，比如比特币、比特现金和目前阶段的以太坊等；而非PoW共识算法的加密货币则不存在51%算力攻击，如基于DPoS（委托权益证明）共识机制的EOS、TRON等。</p><p>在了解了51%算力攻击之后，你肯定好奇，这种攻击能做哪些坏事。</p><p>1、双花（Double Spending）。双花的意思是一份”钱”花了两次甚至多次。</p><p>51%算力攻击是如何做到双花的呢？假设小黑有666BTC，他把这些币支付的大白同时，也把这些币发到自己的另一钱包地址上。换一句话说，小黑的一份钱，同时转给两个人。最终，发给大白那笔交易先被得到了确认，并打包在区块高度为N的区块内。</p><p>这时，控制了超过50%算力的小黑，发起51%算力攻击。他通过重新组装第N个区块，将发给自己那笔交易打包进区块里，并持续在这条链上延展区块，由于算力的优势，这条量将成为最长合法链。这样小黑666BTC双花成功，大白钱包里的666BTC”不翼而飞”了。</p><h3 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h3><h3 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h3><p>1、IPFS到底是什么？</p><p>IPFS，其实是一种点对点的分布式文件系统。</p><p>（1）IPFS是一个运用git分布式、去中心化存储且单一的bittorrent群集。</p><p>（2）IPFS是依据内容从而来产生地址，它提供了高吞吐量的内容寻址存储模型。</p><p>（3）IPFS主要是通过默克尔树数据结构来构建版本文件系统。</p><p>（4）IPFS不存在单独的故障点，节点之间也是不需要相互信任。</p><p>星际文件系统IPFS（InterPlanetary File System），它其实是一个面向全球、点对点的分布式版本文件系统，能将所有具有相同文件系统的计算设备连接在一起，主要目标是对我们目前统领互联网的超文本传输协议（也就是HTTP）进行补充（更甚者是“取代”）。它的原理就是利用基于内容的地址来替代基于域名的地址，简单来说，用户寻找的是存储在某地方的内容，而不是某地址，就只需确认验证内容的哈希，这样就能过获得速度更快、安全、健壮、持久的网页。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis详解</title>
      <link href="/2020/02/05/Redis%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/05/Redis%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>redis的字符串类型没有使用C语言的原生字符串类型，而是使用了一个自定义的结构体（SDS，Simple Dynamic String），他是一个带长度信息的字节数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt;&#123;</span></span><br><span class="line">    T capitity;  <span class="comment">//数组容量</span></span><br><span class="line">    T len; <span class="comment">//数组长度</span></span><br><span class="line">    byte flags; <span class="comment">//特殊标志位</span></span><br><span class="line">    byte[] content; <span class="comment">//数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用泛型T，可以在字符串比较短的时候len  ,capitity 使用byte，short表示，节约内存。redis规定字符串长度不得超过512MB，创建字符串的时候len,capitity一样长，不同长度的字符串使用不同的结构体表示。</li><li>字符串长度小于1MB时，扩容采用加倍策略，超过1MB时，每次扩容只会多分配1MB大小的空间</li></ol><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>除了hash结构使用字典外，整个redis数据库的所有key,value也组成了一个全局字典，还有带过期时间的key集合也是一个字典，zset中存储的value和score值的映射关系也是通过字典结构实现的。</p><p>字典结构内部包含两个hashtable,通常只有一个hashtable是有值的，在字典扩容时需要重新分配hashtable，然后进行渐进式搬移，知识后两个hashtable存储的分别是旧的hashtable和新的hashtable。搬移结束后，旧的hashtable被删除，新的hashtable取代。</p><p>hashtable的结构解决hash冲突采用的是拉链法（和java的hashMap相似）第一维是数组，第二维是链表，数组中存储第二维链表的第一个元素的指针。</p><p>由于数据量比较大的字典扩容是比较耗时的，这是一个O(n)级别的操作，作为单线程的redis很难支持这样的耗时操作，所以redis使用渐进式hash小步迁移。（搬移操作在redis对字典的后续操作指令中（hset,hdel等），在客户端空闲时redis的定时任务会进行主动搬迁）。</p><p>正常情况下，当hash表中的元素个数等于第一维数组的长度，就会进行扩容，变为原数组的两倍。但是，如果Redis正在做bgsave，<strong>为了减少内存也的过多分离（Copy On Write）</strong>redis尽量不去扩容，但是当元素的个数已经达到第一维数组长度的5倍，会强制扩容。</p><blockquote><h1 id="写时复制技术"><a href="#写时复制技术" class="headerlink" title="写时复制技术"></a><a href="https://www.cnblogs.com/-colin/p/7990011.html" target="_blank" rel="noopener">写时复制技术</a></h1><p>写时复制技术最初产生于Unix系统，用于实现一种傻瓜式的进程创建：当发出fork( )系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为是非常耗时的，因为它需要：</p><p>·   为子进程的页表分配页面</p><p>·   为子进程的页分配页面</p><p>·   初始化子进程的页表</p><p>·   把父进程的页复制到子进程相应的页中</p><p>创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破坏了高速缓存中的内容。在大多数情况下，这样做常常是毫无意义的，因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。</p><p>现在的Unix内核（包括Linux），采用一种更为有效的方法称之为写时复制（或COW）。这种思想相当简单：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</p></blockquote><p>缩容条件：元素个数小于数组长度的10%时，缩容不会考虑redis是否在bgsave。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set 结构底层也是字典，只不过所有的value都是null，其他和字典一样。</p><h3 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h3><p>redis为了节约内存空间，zset和hash容器对象在元素个数比较少的时候，采用压缩列表进行存储。</p><p>压缩列表是一块连续的内存空间，元素之间顺序存储，没有冗余空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">    int32 zlbytes;  <span class="comment">//整个压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset;  <span class="comment">//最后一个元素距离压缩列表起始位置的偏移量，用于快速定位最后一个节点</span></span><br><span class="line">    int16 zllength;   <span class="comment">//元素个数</span></span><br><span class="line">    T[] entries;    <span class="comment">//元素内容列表，依次紧凑存储</span></span><br><span class="line">    int8 zlend;     <span class="comment">//标志压缩列表的结束，恒为 0xFF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen;   <span class="comment">//前一个entry的字节长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding;  <span class="comment">//元素类型编码</span></span><br><span class="line">    optional byte[] content;  <span class="comment">//元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ziplist都是紧凑存储，没有冗余空间，意味着插入一个新的元素需要调用realloc拓展内存。如果ziplist占据内存过大，重新分配内存和拷贝内存就会有很大的消耗，所以ziplist不适合存储大型字符串，存储的元素也不宜过多。</p><p>压缩列表使用 zltail_offset 字段快速定位到尾部，进而实现双向遍历。</p><h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p>redis早期版本存储列表数据结构使用的是压缩列表ziplist和普通的双向链表LinkedList，元素少时使用ziplist，多时使用LinkedList。</p><p>考虑到链表附加空间（前后指针）相对太高，每个节点都需要单独分配，影响内存管理效率，后来使用quickList代替了ziplist和LinkedList。</p><p>quickList是ziplist和LinkedList的结合体，他将LinkedList按段切分，每一段使用ziplist紧凑存储，让多个ziplist之间使用双向指针串联起来。</p><p>quickList默认每个ziplist的长度为8KB，超过这个大小，就会另起一个ziplist。ziplist长度可以由参数 list-max-ziplist-size 配置.</p><p>压缩深度：quickList默认压缩深度为0，也就是不压缩。压缩深度由 list-compress-depth 决定。为了支持快速的push/pop操作，quickList首尾两个ziplist不压缩，此时压缩深度为1（几个元素不压缩）</p><h3 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h3><p>redis的zset是一个复合结构，一方面他需要一个hash结构来存储value和score的值，另一方面需要提供按照score排序的功能，还需要能够指定score的范围来获取value列表的功能。</p><p>zset的内部实现是一个hash字典加一个跳跃链表（skiplist），简单来说，<strong>给链表加多级索引的结构，就是跳跃表</strong>，<a href="https://www.cnblogs.com/hunternet/p/11248192.html" target="_blank" rel="noopener">https://www.cnblogs.com/hunternet/p/11248192.html</a></p><p>对于新插入的节点，都需要一个随机算法给它分配一个合理的层数，目前是这样的，level1 -&gt; 50%,level2-&gt;25%。。。每一层的晋升率是50%。最顶层是2的-63的概率。</p><p>如果执行zadd时，value已经存在，但是score需要更新，并且更新后改变了排序位置，那么redis会直接删除这个节点然后在执行插入。排序时，如果score相同还需要比较value的值。</p><h2 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h2><h3 id="线程IO模型"><a href="#线程IO模型" class="headerlink" title="线程IO模型"></a>线程IO模型</h3><p>redis 是一个单线程程序，使用非阻塞IO处理并发客户端连接（多路复用，select系列事件轮询API）</p><p>非阻塞IO：当数据没有完全被内核准备好时，线程不阻塞而是直接返回，再次轮询请求是否准备好，当准备好时系统调用，将内核接收的数据拷贝到用户进程空间内。</p><p>多路复用：使用一个线程监听连接，若连接就绪则开启一个线程进行处理。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>RESP（redis serialization protocol）redis 序列化协议，一种直观的文本协议，优点在于实现过程简单，解析性能好。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>redis有两种持久化机制，第一种是快照，第二种是AOF日志。</p><p>快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑。而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得无比庞大，数据库重启时需要加载AOF日志进行指令重放，这个时间会很长，所以需要定期对AOF进行重写，给AOF日志进行瘦身。</p><h4 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h4><p>redis使用多进程COW（写时复制）机制进行快照持久化。</p><p>redis在持久化时会调用glibc的函数fork()产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。</p><p>当父进程对其中一个内存页面的数据进行修改时，会将跟子进程共享的对应页面复制一份分离出来，然后对这个复制的页面进行修改，这时子进程相应的页面是没有变化的，还是进程产生那一瞬间产生的。子进程因为数据没有变化，它能看到的内存的数据是进程产生一瞬间的，所以叫做快照，接下来子进程就可以安心进行序列化写磁盘了。</p><h4 id="AOF日志原理"><a href="#AOF日志原理" class="headerlink" title="AOF日志原理"></a>AOF日志原理</h4><p>AOF日志存储的是redis服务器的顺序指令序列，AOF日志只记录对内存的修改指令记录。所以可以通过AOF日志进行重放，来恢复redis当前实例的内存数据状态。</p><p>redis是先执行指令才将日志存盘，这点不同于hbase,levledb等，先存储日志在逻辑处理。</p><p>AOF日志随时间会越来越长，重放AOF日志也会非常耗时，所以可以使用 bgrewriteaof指令进行AOF重写，原理是开辟一个子进程对内存进行遍历，转换成一系列的redis操作指令，序列化到一个新的AOF文件中，序列化完毕后再将操作期间增量AOF日志追加到新的AOF文件中，最后替换就的AOF文件。</p><p>AOF日志是文件形式存在的，当程序对AOF日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存，然后内核异步将数据刷回磁盘。</p><p>但是如果机器突然宕机，AOF日志还未刷新，就会出现日志丢失。</p><p>Linux的glibc提供了fsync(int fd)函数可以将制定文件的内容强制刷新到磁盘。在实际中，redis通常每个1S执行一次此操作。此策略可以调整。</p><h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p>redis4.0解决回复内存数据时间慢的问题，使用混合持久化。</p><p>将快照文件的内容和增量的AOF日志文件放到一起，这里的AOF不再是全量的日志，而是自持久化开始到结束的增量AOF，通常很少。</p><p>这样AOF重启可以先加载快照，在重放增量AOF日志，效率大幅提升。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>redis 事务不具备原子性，而仅仅满足事务的隔离性中的串行化—-当前事务有着不被其他事务打断的权利。</p><p>redis提供了watch机制，它是一种乐观锁。watch会在事务开始之前盯住一个或多个关键变量，当事务执行时（exec），redis会检查关键变量在watch之后是否被修改了（包括当前事务所在的客户端）。如果被修改了就回返回null，执行失败，一般客户端会选择重试。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="sentinel（哨兵模式）"><a href="#sentinel（哨兵模式）" class="headerlink" title="sentinel（哨兵模式）"></a>sentinel（哨兵模式）</h3><p>redis-sentinel集群可以看成是一个zookeeper集群，一般有3~5个节点组成，保证集群高可用。</p><p>sentinel负责持续监控主从节点的健康，当主节点挂掉，自动选择一个最优的从节点切换称为主节点。客户端来连接集群时，会首先连接sentinel，通过sentinel来询问主节点的地址，然年在连接主节点进行数据交互；当主节点故障时，客户端会重新向sentinel要地址。</p><p>redis主从采用异步复制，意味着当主节点挂掉时，从节点没有收到全部的同步信息；</p><p>为了尽量保证消息少丢失，sentinel使用两个选项限制主从延迟过大：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>第一个参数表示主节点至少有一个从节点进行<strong>正常复制</strong>，否则就停止对外写服务，丧失可用性。</p><p>第二个参数控制 <strong>正常复制</strong>的条件，单位是秒，表示如果10秒内没有收到从节点的反馈，就代表从节点同步不正常。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>分布式锁  使用  set  变量 ex 过期时间  组成原子指令，这就是分布式锁</p><p>位图 bitmap  本质是字符串（byte数组）</p><p>HyperLogLog  （去重）统计网页的UV（用户访问量） 标准误差0.81%</p><p>布隆过滤器</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2020/02/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/02/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>Consistency: 一致性</p><p>Availability: 可用性</p><p>Paritition: 分区容错性</p><p>在保证分区容错性的同时，在可用性和一致性之间做取舍。</p><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>Basically Available: 基本可用  —- 当系统故障时，保证核心可用，允许损失部分可用性</p><p>Soft State: 软状态 —-  允许系统不同节点的数据副本之间的同步存在时延</p><p>Eventually Consistent: 最终一致性 —- 系统所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h3 id="两阶段提交协议（Two-phase-Commit-，2PC）"><a href="#两阶段提交协议（Two-phase-Commit-，2PC）" class="headerlink" title="两阶段提交协议（Two-phase Commit ，2PC）"></a>两阶段提交协议（Two-phase Commit ，2PC）</h3><p>通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p><strong>运行过程</strong></p><ol><li>准备阶段：协调者询问参与者事务是否执行成功，参与者返回事务执行结果</li><li>提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，通知参与者回滚事务；</li></ol><p><strong>存在的问题</strong></p><ol><li>同步阻塞：所有的事务参与者在等待其他参与者响应的时候都处于同步阻塞状态，无法进行其他操作。</li><li>单点问题：协调者在2PC中起到非常大的作用，发生故障的时候回造成很大影响。特别是在提交阶段，所有参与者会一直等待，无法完成其他操作。</li><li>数据不一致：在提交阶段，如果协调者只发送了部分Commit消息，然后发生网络异常，那么只有部分参与者接收commit消息，使得数据不一致。</li><li>过于保守：任意一个节点失败都会导致整个事务失败，没有完善的容错机制</li></ol><h3 id="三阶段提交协议（3PC）"><a href="#三阶段提交协议（3PC）" class="headerlink" title="三阶段提交协议（3PC）"></a>三阶段提交协议（3PC）</h3><p>3PC在协调者和参与者中都引入了超时机制，并把两阶段提交协议的第一个阶段拆分成了两步：询问，然后在锁定资源，最后真正提交。</p><ol><li><p>cancommit阶段：协调者向参与者放commit请求，参与者如果可以提交就返回YES响应，否则返回NO</p></li><li><p>precommit阶段：协调者根据commit的反应来决定是否继续precommi操作</p><p> A：如果协调者从所有的参与者获取的commit都是YES响应，那么就会进行事务的预执行（协调者发送预提交请求，并进入prepared阶段）参与者收到precommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中，如果参与者成功执行事务操作，那么返回ACK响应，同时开始等待最终指令。</p><p> B:   假如有任何一个参与者向协调者发送了NO响应，或者超时等待之后，协调者都没有接受到参与者的响应，那么中断事务。协调者向所有的参与者发送abort请求，中断事务。参与者接收到abort请求（或者超时之后）执行事务的中断。</p></li><li><p>docommit阶段</p><p> A：发送提交请求：协调者接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态，并向所有的参与者发送docommit请求</p><p> B:   事务提交：参与者接收到docommit请求后，执行正式的事务提交，并在完成事务提交后释放所有的事务资源。</p><p> C:    响应反馈：事务提交完之后，向协调者发送ACK响应。</p><p> D:    完成事务：协调者接收到所有参与者的ACK响应之后，完成事务。</p><p> 中断事务：协调者没有接受到参与者发送的ACK响应（或者响应超时），那么就会中断事务。</p></li></ol><p><strong>存在问题</strong></p><p>如果进入PreCommit后，Coordinator发出的是abort请求，假设只有一个Cohort收到并进行了abort操作，<br>而其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发生不一致性。</p><p><strong>2PC和3PC的不同</strong></p><p>对于协调者(Coordinator)和参与者(Cohort)都设置了超时机制（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到cohort的消息则默认失败）。<br>在2PC的准备阶段和提交阶段之间，插入预提交阶段，使3PC拥有CanCommit、PreCommit、DoCommit三个阶段。<br>PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</p><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p> Paxos算法需要解决的问题就是如何在一个可能发生<strong>机器宕机</strong>或<strong>网络异常</strong>的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致。</strong></p><p>  Paxos由Acceptor、proposer和leaner三种角色组成</p><ul><li>proposer负责提出提案</li><li>acceptor负责对提案裁决</li><li>leaner负责学习得到的提案</li></ul><p>为了避免单点故障，会有一个acceptor集合，proposer向该集合发送提案，acceptor集合中的每个成员都有可能同意该提案并且每个acceptor只能批准一个提案，当有一半以上的成员同意，则同意该提案。</p><p>   Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><ul><li><p><strong>阶段一：</strong></p><p>  <strong>(a)</strong> Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</p><p>  <strong>(b)</strong> 如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong>作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</p></li><li><p><strong>阶段二：</strong></p><p>  <strong>(a)</strong> 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对<strong>[N,V]提案</strong>的<strong>Accept请求</strong>给<strong>半数以上</strong>的Acceptor。注意：V就是收到的<strong>响应</strong>中<strong>编号最大的提案的value</strong>，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</p><p>  <strong>(b)</strong> 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</p></li></ul><p>paxos算法是一种基于消息传递的且具有高度容错性的一种算法，解决的问题是一个分布式系统如何就某个值或者某个协议达成一致，该算法的前提是假设不存在拜占庭将军问题。</p><p>在该算法中一共有三种角色：proposer, accpetor和learner。proposer负责提出提案，acceptor负责对该提案做出裁决，learner负责学习得到的提案。为了避免单点故障，会有一个acceptor集合，proposer向该集合发送提案，acceptor集合中的每个成员都有可能同意该提案且每个acceptor只能批准一个提案，当有一半以上的成员同意，则同意该提案。</p><p>它主要分为两个阶段：分别是prepare阶段和accept阶段。首先是prepare阶段，先由proposer提出编号为Mn的提案，向accpetor集合发送prepare请求。Accept做出反馈：保证不会再接受编号比Mn小的提案；如果acceptor已经批准过某提案，会向proposer返回已经批准的编号最大的提案的value值。</p><p>如果acceptor收到一个编号为Mn的请求且编号大于accpetor已经响应的所有prepare请求的编号，则它会将自己已经批准过的编号最大的提案值反馈给proposer，同时acceptor承诺不会再接受编号比Mn小的提案。（优化:忽略编号小于已批准的提案的请求）。</p><p>如果proposer收到了集合至少一半的响应，则会发送一个针对Mn Vn的accept请求给Accpetor。Vn为收到的所有响应中编号最大的提案的值。如果响应不包括值，则可以由proposer选择任意值。</p><p>然后就是accpet阶段，accpet阶段是接受提案的要求。当Acceptor收到accpet请求后，只要未收到任何编号大于Mn的prepare请求，则通过该提案。</p><p>优化：为了避免死循环，比如两个proposer一次提出一系列编号递增的提案，可以产生一个主proposer，提案只能由主proposer负责提出。</p><p><img src="https://oscimg.oschina.net/oscnet/d77f2f61803f1f2db92551c4af6a3dc9bf0.jpg" alt="img"></p><h3 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h3><p>Raft 和 Paxos 类似，但是更容易理解，也更容易实现。</p><p><strong>Raft 主要是用来竞选主节点</strong>。</p><p>在Raft中，节点有三种角色：</p><ul><li>Leader：负责接收客户端的请求，将日志复制到其他节点并告知其他节点何时应用这些日志是安全的</li><li>Candidate：用于选举Leader的一种角色</li><li>Follower：负责响应来自Leader或者Candidate的请求</li></ul><p><strong>单个 Candidate 的竞选</strong></p><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><p>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p><p>此时 A 发送投票请求给其它所有节点。</p><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p><p><strong>多个 Candidate 竞选</strong></p><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</p><p>当重新开始投票时，由于每个节点设置的<strong>随机竞选超时时间不同</strong>，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p><p><strong>日志复制</strong></p><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p><p>Leader 会把修改复制到所有 Follower。</p><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</p><h3 id="zookeeper的ZAB算法"><a href="#zookeeper的ZAB算法" class="headerlink" title="zookeeper的ZAB算法"></a>zookeeper的ZAB算法</h3><p><strong>Looking：</strong>选举状态。</p><p><strong>Following：</strong>Follower 节点（从节点）所处的状态。</p><p><strong>Leading：</strong>Leader 节点（主节点）所处状态。</p><p>最大 ZXID 也就是节点本地的最新事务编号，包含 epoch 和计数两部分。epoch 是纪元的意思，相当于 Raft 算法选主时候的 term。</p><p><strong>崩溃恢复流程：</strong></p><p><strong>1.Leader election</strong></p><p>​            选举阶段，此时集群中的节点处于 Looking 状态。它们会各自向其他节点发起投票，投票当中包含自己的服务器 ID 和最新事务 ID（ZXID）。</p><p>​            接下来，节点会用自身的 ZXID 和从其他节点接收到的 ZXID 做比较，如果发现别人家的 ZXID 比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的 ZXID 所属节点。</p><p>​            每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准 Leader，状态变为 Leading。其他节点的状态变为 Following。</p><p><strong>2. Discovery</strong></p><p>​        发现阶段，用于在从节点中发现最新的 ZXID 和事务日志。或许有人会问：既然 Leader 被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？</p><p>​        这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个 Leader 的情况。</p><p>​        所以这一阶段，Leader 集思广益，接收所有 Follower 发来各自的最新 epoch 值。Leader 从中选出最大的 epoch，基于此值加 1，生成新的 epoch 分发给各个 Follower。</p><p>​        各个 Follower 收到全新的 epoch 后，返回 ACK 给 Leader，带上各自最大的 ZXID 和历史事务日志。Leader 选出最大的 ZXID，并更新自身历史日志。</p><p><strong>3. Synchronization</strong></p><p>​        同步阶段，把 Leader 刚才收集得到的最新历史事务日志，同步给集群中所有的 Follower。只有当半数 Follower 同步成功，这个准 Leader 才能成为正式的 Leader。**</p><p><strong>原子广播</strong></p><ol><li><p>客户端发出写入数据请求给任意Follower。</p></li><li><p>Follower 把写入数据请求转发给 Leader。</p></li><li><p>Leader 采用二阶段提交方式，先发送 Propose 广播给 Follower。</p></li><li><p>Follower 接到 Propose 消息，写入日志成功后，返回 ACK 消息给 Leader。</p></li><li><p>Leader 接到半数以上 ACK 消息，返回成功给客户端，并且广播 Commit 请求给 Follower。</p></li></ol><p>ZAB 协议既不是强一致性，也不是弱一致性，而是处于两者之间的单调一致性。它依靠事务 ID 和版本号，保证了数据的更新和读取是有序的。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/2020/02/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/02/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><p><strong>为什么要三次握手？</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><p><strong>为什么客户端最后还要等待2MSL？</strong></p><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口通俗来讲就是一种流量控制技术。（TCP首部中有16位窗口大小的字段）</p><p>​    它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来。</p><p>​    </p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>一：滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的，对应==&gt;rwnd:接收端窗口（receiver window）</p><p>对于流量控制，是一个端对端的概念。由接收端返回的rwnd控制。</p><p>二：那么对于数据的发送端就是拥塞窗口了，拥塞窗口不代表缓存，拥塞窗口指某一源端数据流在一个RTT内可以最多发送的数据包数,cwnd:发送端窗口( congestion window )。</p><p>拥塞控制： 发送端主动控制控制cwnd，有慢启动（从cwnd初始为1开始启动，指数启动），拥塞避免（到达ssthresh（慢启动阈值）后，为了避免拥塞开始尝试线性增长），快重传（接收方每收到一个报文段都要回复一个当前最大连续位置的确认，</p><p>发送方只要一连收到三个重复确认就知道接收方丢包了，快速重传丢包的报文，并TCP马上把拥塞窗口 cwnd 减小到1），快恢复（直接从ssthresh线性增长）。</p><p>三：发送方窗口是相互影响的，具体如下：</p><p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p><p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p><p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p><p>四、TCP的滑动窗口大小实际上就是socket的接收缓冲区大小的字节数，可以用上层setopt来设置。</p><p>五、对于server端的socket一定要在listen之间设置缓冲区大小，因为，accept时新产生的socket会继承监听socket</p><p>的缓冲区大小。对于client端的socket一定要在connet之前设置缓冲区大小，因为connet时需要进行三次握手过程，</p><p>会通知对方自己的窗口大小。在connet之后再设置缓冲区，已经没有什么意义。</p><p><strong>流量控制和拥塞控制的区别</strong><br>1.相同点</p><p>（1）现象都是丢包；<br>（2）实现机制都是让发送方发的慢一点，发的少一点</p><p>2.不同点</p><p>（1）丢包位置不同<br>        流量控制丢包位置是在接收端上<br>        拥塞控制丢包位置是在路由器上<br>（2）作用的对象不同<br>        流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理<br>        拥塞控制的对象是网络，怕发送发发的太快，造成网络拥塞，使得网络来不及处理</p><h2 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p><strong>状态码</strong></p><p>1xx类属于提示信息，是协议处理的中间状态，实际不常用</p><p>2xx类表示服务端收到并成功处理客户端的请求，这也是客户端最愿意看到的状态码</p><p>​        200 OK 成功状态码，一切正常</p><p>​        204 NO Content 常见的成功状态码，他的含义与200 OK基本相同，但是响应头后没有body数据</p><p>​        206 Partial Content 是http分块下载或断点续传的基础，在客户端发送范围请求时出现。状态码 206 通常还会伴随着头字段“Content-Range”， 表示响应报文里 body 数据的具体范围，供客户端确认</p><p>3xx类表示客户端请求的资源发生变动，客户端必须用新的URI重新发送请求获取资源，也就是重定向。</p><p>​        301 Moved Permanently 永久重定向</p><p>​        302 Found 临时重定向</p><p>​        304 Not Modified 它用 于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定 向已到缓存的文件”（即“缓存重定向”）。</p><p>4xx类表示客户端发送的请求报文有误，服务器无法处理。</p><p>​        400 Bad Request 是一个通用的错误码，表示请求报 文有错误，但具体是数据格式错误、缺少请求头还是 URI 超 长它没有明确说，只是一个笼统的错误</p><p>​        403 Forbidden实际上不是客户端的请求出错，而是 表示服务器禁止访问资源。</p><p>​        404 Not Found可能是我们最常看见也是最不愿意看 到的一个状态码，它的原意是资源在本服务器上未找到，所 以无法提供给客户端。</p><p>5xx类表示客户端请求报文正确，但服务器处理时内部发生了错误，无法返回应有的响应数据，是服务端的错误码</p><p>​        500 Internal Server Error与 400 类似，也是一个通 用的错误码，服务器究竟发生了什么错误我们是不知道的。</p><p>​        502 Bad Gateway通常是服务器作为网关或者代理时 返回的错误码，表示服务器自身工作正常，访问后端服务器 时发生了错误，但具体的错误原因也是不知道的。</p><p>​        503 Service Unavailable表示服务器当前很忙，暂时 无法响应服务，我们上网时有时候遇到的“网络服务正忙， 请稍后重试”的提示信息就是状态码 503。</p><p>假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用 域名“<a href="http://www.apple.com”访问，那么接下来要做的必然是域名解析。这就要用" target="_blank" rel="noopener">www.apple.com”访问，那么接下来要做的必然是域名解析。这就要用</a> DNS 协议 开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间 有缓存，可能不会费太多时间就能拿到结果。 别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一 脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而 不是目标网站的实际地址。 因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不 需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</p><p><strong>http传输大文件的方法</strong></p><ol><li>压缩 HTML 等文本文件是传输大文件最基本的方法； </li><li>分块传输可以流式收发数据，节约内存和带宽，使用响应 头字段“Transfer-Encoding: chunked”来表示，分块 的格式是 16 进制长度头 + 数据块</li><li>范围请求可以只获取部分数据，即“分块请求”，实现视 频拖拽或者断点续传，使用请求头字段“Range”和响应 头字段“Content-Range”，响应状态码必须是 206</li><li>也可以一次请求多个范围，这时候响应报文的数据类型 是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。</li></ol><p><strong>连接管理</strong></p><ol><li>早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</li><li>HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</li><li>服务器会发送“Connection: keep-alive”字段表示启用了长连接；</li><li>报文头里如果有“Connection: close”就意味着长连接即将关闭；</li><li>过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</li><li>“队头阻塞”问题（一个长连接中推积太多请求）会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</li></ol><p><strong>HTTP管线化</strong></p><p>HTTP管线化是将多个HTTP要求（request）整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过永久连接（persistent connection）完成，仅HTTP/1.1支持此技术（HTTP/1.0不支持），并且只有GET和HEAD要求可以进行管线化，而POST则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。<strong>管线化并没有解决队头阻塞的问题。</strong></p><p>浏览器将HTTP要求大批提交可大幅缩短页面的加载时间，特别是在传输延迟（lag/latency）较高的情况下（如卫星连接）。此技术之关键在于多个HTTP的要求消息可以同时塞入一个TCP分组中，所以只提交一个分组即可同时发出多个要求，借此可减少网络上多余的分组并降低线路负载。</p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>头部压缩、Server Push、多路复用</p><p>头部压缩：HTTP2.0会对HTTP的头进行一定的压缩，将原来每次都要携带的大量key value在两端建立一个索引表，对相同的头只发送索引表中的索引</p><p>Server Push：服务端可以推送消息给客户端</p><p>多路复用：HTTP2.0协议将一个TCP的连接中，切分成多个流。每个流都有自己的ID，而且流可以是客户端发服务端，也可以是服务端发客户端，它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP2.0还将所有的传输信息分割为更小的信息和帧，并对它们采用二进制格式编码。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流，再就是Data帧，用来传输正文实体。多个Data帧属于一个流</p><p><strong>连接、流和帧的关系</strong></p><ol><li>一个连接同时被多个流复用；</li><li>一个流代表一次完整的请求/响应过程，包含多个帧；</li><li>一个消息被拆分封装成多个帧进行传输；</li></ol><p><strong>存在的问题</strong></p><p>HTTP2.0 也是基于TCP协议的，tcp协议在处理包时是有严格顺序的</p><p>当其中一个数据包遇到问题，TCP连接需要等待找个包完成重传之后才能继续进行，虽然HTTP2.0通过多个stream，使得逻辑上一个tcp连接上的并行内容，进行多路数据的传输，然而这中间没有关联的数据，一前一后，前面stream2的帧没有收到，后面stream1的帧也会因此堵塞。</p><h3 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h3><p>google的 QUIC协议从TCP切换到UDP</p><ul><li><p>机制一：自定义连接机制<br>  一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</p><p>  在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64<br>  位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接；</p></li><li><p>机制二：自定义重传机制<br>  tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</p><p>  任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</p><p>  但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</p><p>  QUIC也有个序列号，是递增的，任何宇哥序列号的包只发送一次，下次就要加1，那样就计算可以准确了</p><p>  但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</p></li><li><p>机制三： 无阻塞的多路复用</p><p>  有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</p><p>  同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</p></li><li><p>机制四：自定义流量控制</p><p>  TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</p><p>  在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，<strong>因为TCP的ACK机制是基于序列号的累计应答</strong>，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</p><p>  QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。</p></li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p><img src="https://img2018.cnblogs.com/blog/1169376/201910/1169376-20191008172456510-1302410435.png" alt="img"></p><p>非对称加密：RSA</p><p>对称加密：AES</p><p>摘要算法：SHA2系列</p><p><img src="//qx-ljy.cn/2020/02/01/网络协议/C:%5CUsers%5C%E5%A4%95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200209160906951.png" alt="image-20200209160906951"></p><ol><li>客户端使用URL访问web服务器，要求与服务器建立SSL链接（SSL之间的握手协议可以查看其他资料）。</li><li>服务器收到客户端的请求后，会将网站的SSL证书信息（包含公钥）传送一份给客户端。</li><li>客户端开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书进行比对。如果没找到该CA的信息，浏览器会提示不信任网站的信息。</li><li>如果找到，浏览器从操作系统中取出颁发者CA的公钥将证书中的签名进行解密，对服务器进行认证，防止服务器是被冒充的。</li><li>一切没问题后，浏览器与服务器进行加密等级等内容进行协商产生一个对称的密钥，然后通过接受到的证书中的公钥对这个对称密钥进行加密，传送给服务器。</li><li>服务器拿到信息后用自己的私钥进行解密拿到对称密钥。于是客户端和服务器就可以通过这个对称密钥进行安全且快乐的对话了。</li></ol><p><strong>证书的签发过程</strong></p><p>a.服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；</p><p>b.CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；</p><p>c.如信息审核通过，CA 会向申请者签发认证文件-证书。</p><p>​            证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；</p><p>​            签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；</p><p>d.客户端 C 向服务器 S 发出请求时，S 返回证书文件；</p><p>e.客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；</p><p>f.客户端然后验证证书相关的域名信息、有效时间等信息；</p><p>g.客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</p><h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p> <strong>FTP（文件传输协议）</strong>。FTP 采用两个 TCP 连接来传输一个文件。</p><ol><li><strong>控制连接</strong>。服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将<strong>命令</strong>从客户端传给服务器，并传回服务器的<strong>应答</strong>。常用的命令有：lsit - 获取文件目录，reter - 取一个文件，store - 存一个文件；</li><li><strong>数据连接</strong>。每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。</li></ol><p><strong>FTP 的工作模式</strong></p><p>    在 FTP 的两个 TCP 连接中，每传输一个文件，都要新建立一个数据连接。基于这个数据连接，FTP 又有两种工作模式：<strong>主动模式（PORT）</strong>和<strong>被动模式（PASV）</strong>，要注意的是，这里的主动和被动都是站在服务器角度来说的。工作模式过程如下：</p><p><strong>主动模式工作流程</strong></p><ol><li>客户端随机打开一个大于 1024 的端口 N，向服务器的<strong>命令端口 21</strong> 发起连接，同时开放 N+1 端口监听，并向服务器发出“port N+1” 命令；</li><li>由服务器从自己的数据端口 20，<strong>主动连接到客户端指定的数据端口 N+1</strong>。</li></ol><p><strong>被动模式工作流程</strong></p><ol><li>客户端在开启一个 FTP 连接时，打开两个任意的本地端口 N（大于1024）和 N+1。然后用 N 端口连接服务器的 21 端口，提交 PASV 命令；</li><li>服务器收到命令，开启一个任意的端口 P（大于 1024），返回“227 entering passive mode”消息，消息里有服务器开放的用来进行数据传输的端口号 P。</li><li>客户端收到消息，取得端口号 P，通过 N+1 端口连接服务器的 P 端口，进行数据传输。</li></ol><h3 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h3><p>​        <strong>赖于 Tracker 的，也就是元数据集中，文件数据分散。</strong></p><p>    P2P 就是 peer-to-peer。这种方式的特点是，资源一开始并不集中存储在某些设备上，而是分散地存储在多台设备上，这些设备我们称为 peer。</p><p>    在下载一个文件时，只要得到那些已经存在了文件的 peer 地址，并和这些 peer 建立点对点的连接，就可以就近下载文件，而不需要到中心服务器上。一旦下载了文件，你的设备也就称为这个网络的一个 peer，你旁边的那些机器也可能会选择从你这里下载文件。</p><p>    通过这种方式解决上面 C/S 结构单一服务器带宽压力问题。如果使用过 P2P2 软件，例如 BitTorrent，你就会看到自己网络不仅有下载流量，还有上传流量，也就是说你加入了这个 P2P 网络，自己可以从这个网络里下载，同时别人也可以从你这里下载。这样就实现了，<strong>下载人数越多，下载速度越快的愿望</strong>。</p><p><strong>种子文件（.torent）</strong></p><p>    上面整个过程是不是很完美？是的，结果很美好，但为了实现这个美好，我们还是有很多准备工作要做的。比如，我们怎么知道哪些 peer 有某个文件呢？</p><p>    这就用到我们常说的<strong>种子（.torrent）</strong>。 .torrent 文件由<strong>Announce（Tracker URL）</strong>和<strong>文件信息</strong>两部分组成。</p><p>    其中，文件信息里有以下内容：</p><ul><li><strong>Info 区</strong>：指定该种子包含的文件数量、文件大小及目录结构，包括目录名和文件名；</li><li><strong>Name 字段</strong>：指定顶层目录名字；</li><li><strong>每个段的大小</strong>：BitTorrent（BT）协议把一个文件分成很多个小段，然后分段下载；</li><li><strong>段哈希值</strong>：将整个种子种，每个段的 SHA-1 哈希值拼在一起。</li></ul><p>    下载时，BT 客户端首先解析 .torrent 文件，得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。</p><p>    下载者再连接其他下载者，根据 .torrent 文件，两者分别对方自己已经有的块，然后交换对方没有的数据。</p><p>    可以看到，下载的过程不需要其他服务器参与，并分散了单个线路上的数据流量，减轻了服务器的压力。</p><p>    下载者每得到一个块，需要算出下载块的 Hash 验证码，并与 .torrent 文件中的进行对比。如果一样，说明块正确，不一样就需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。</p><p>    从这个过程也可以看出，这种方式特别依赖 Tracker。Tracker 需要收集所有 peer 的信息，并将从信息提供给下载者，使下载者相互连接，传输数据。虽然下载的过程是非中心化的，但是加入这个 P2P 网络时，需要借助 Tracker 中心服务器，这个服务器用来登记有哪些用户在请求哪些资源。</p><p>    所以，这种工作方式有一个弊端，一旦 Tracker 服务器出现故障或者线路被屏蔽，BT 工具就无法正常工作了。那能不能彻底去中心化呢？答案是可以的。</p><h3 id="DHT-Distributed-Hash-Table"><a href="#DHT-Distributed-Hash-Table" class="headerlink" title="DHT(Distributed Hash Table)"></a>DHT(<strong>Distributed Hash Table</strong>)</h3><p>去中心化网络</p><p><strong>DHT（Distributed Hash Table）</strong>，这个网络中，每个加入 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。</p><p>    而 <strong>Kedemlia 协议</strong> 就是一种著名的 DHT 协议。我们来基于这个协议来认识下这个神奇的 DHT 网络。</p><p>    当一个客户端启动 BitTorrent 准备下载资源时，这个客户端就充当了两个角色：</p><ol><li>peer 角色：监听一个 TCP 端口，用来上传和下载文件。对外表明我这里有某个文件；</li><li>DHT Node 角色：监听一个 UDP 端口，通过这个角色，表明这个节点加入了一个 DHT 网络。</li></ol><p>    在 DHT 网络里面，每一个 DHT Node 都有一个 ID。这个 ID 是一个长字符串。每个 DHT Node 都有责任掌握一些“知识”，也就是<strong>文件索引</strong>。也就是说，每个节点要知道哪些文件是保存哪些节点上的。注意，这里它只需要有这些“知识”就可以了，而它本身不一定就是保存这个文件的节点。</p><p>    当然，每个 DHT Node 不会有全局的“知识”，也就是说它不知道所有的文件保存位置，只需要知道一部分。这里的一部分，就是通过哈希算法计算出来的。</p><h5 id="Node-ID-和文件哈希值"><a href="#Node-ID-和文件哈希值" class="headerlink" title="Node ID 和文件哈希值"></a>Node ID 和文件哈希值</h5><p>    每个文件可以计算出一个哈希值，而 <strong>DHT Node 的 ID 是和哈希值相同长度的串</strong>。</p><p>    对于文件下载，DHT 算法是这样规定的：</p><blockquote><p>如果一个文件计算出一个哈希值，则和这个哈希值一样的那个 DHT Node，就有责任知道从哪里下载这个文件，即便它自己没保存这个文件。</p></blockquote><p>    当然不一定总这么巧，都能找到和哈希值一模一样的，有可能文件对应的 DHT Node 下线了，所以 DHT 算法还规定：</p><blockquote><p>除了一模一样的那个 DHT Node 应该知道文件的保存位置，ID 和这个哈希值非常接近的 N 个 DHT Node 也应该知道。</p></blockquote><p>DHT 一种是基于分布式的哈希算法，元数据和文件数据全部分散。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ol start="0"><li><p><strong>客户端先查找 当前浏览器缓存-&gt; 操作系统/etc/hosts文件 -&gt; 本地DNS缓存</strong></p></li><li><p><strong>客户端发出 DNS 请求给本地域名服务器</strong>。我们访问博客园，客户端会问本地域名服务器， <a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a> 的 IP 是什么？（本地域名服务器，如果网络是通过 DHCP 配置，本地 DNS 是由你的网络服务商，如电信、联通等自动分配，它通常就在网络服务商的机房里）；</p></li><li><p><strong>本地 DNS 收到来自客户端的请求，查找“地址簿”，返回 IP 或请求根域名服务器</strong>。我们可以理解为服务器上缓存了一张域名与 IP 对应的大表，如果能找到 <a href="http://www.cnblogs.com，就直接返回对应的" target="_blank" rel="noopener">www.cnblogs.com，就直接返回对应的</a> IP 地址。如果没有找到，本地 DNS 会去问它的根域名服务器；</p></li><li><p><strong>根 DNS 收到来自本地 DNS 的请求，返回 .com 对应的顶级域名服务器的地址</strong>。根域名服务器是最高层次的，全球共有 13 套，它不直接用于域名解析，而是指明怎样去查找对应 IP。它发现请求的域名后缀是 .com，就会返回 .com 对应的顶级域名服务器的地址；</p></li><li><p><strong>本地 DNS 服务器收到顶级 DNS 服务器地址，请求顶级 DNS 服务器查询域名 IP</strong>；</p></li><li><p><strong>顶级 DNS 服务器返回权威 DNS 服务器地址</strong>。顶级域名服务器就是大名鼎鼎的，负责 .com、.net、.org 这些二级域名，比如 cnblogs.com，它会返回对应的权威 DNS 服务器地址；</p></li><li><p><strong>本地 DNS 服务器收到权威 DNS 服务器地址，请求权威 DNS 服务器查询域名 IP</strong>。而 cnblogs.com 的权威 DNS 服务器就是域名解析结果的原出处；</p></li><li><p><strong>权威 DNS 服务器返回对应 IP</strong>。权威 DNS 服务器查询“地址簿”，获取到域名对应 IP 地址，返回给本地 DNS 服务器；</p></li><li><p><strong>本地 DNS 服务器收到 IP，返回给客户端</strong>；</p></li><li><p><strong>客户端与目标建立连接</strong>。</p></li></ol><p>DNS还可以做负载均衡</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，从而将数据缓存在离用户最近的位置。</li><li>CDN 最擅长的缓存是缓存静态数据。除此之外还可以缓存流媒体数据。这时候要注意防盗链问题。它也支持动态数据的缓存，一种是边缘计算，另一种是链路优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring详解</title>
      <link href="/2020/01/01/Spring%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/01/Spring%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<ol><li>Spring的IOC/AOP的实现（必考）</li></ol><h2 id="Spring-Bean的生命周期？"><a href="#Spring-Bean的生命周期？" class="headerlink" title="Spring Bean的生命周期？"></a>Spring Bean的生命周期？</h2><p>首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p>Spring上下文中的Bean生命周期也类似，如下：</p><p>（1）实例化Bean：</p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>（2）设置对象属性（依赖注入）：</p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p>（3）处理Aware接口：</p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p>（4）BeanPostProcessor：</p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><p>（5）InitializingBean 与 init-method：</p><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；</p><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p><p>（7）DisposableBean：</p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>（8）destroy-method：</p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h3 id="动态代理的实现方式"><a href="#动态代理的实现方式" class="headerlink" title="动态代理的实现方式"></a>动态代理的实现方式</h3><p><strong>Java领域中，常用的动态代理实现方式有两种，一种是利用JDK反射机制生成代理，另外一种是使用CGLIB代理。</strong></p><p><strong>JDK代理必须要提供接口，而CGLIB则不需要，可以直接代理类。</strong></p><h2 id="BeanFactory和ApplicationContext的联系和区别"><a href="#BeanFactory和ApplicationContext的联系和区别" class="headerlink" title="BeanFactory和ApplicationContext的联系和区别"></a>BeanFactory和ApplicationContext的联系和区别</h2><p><strong>BeanFactory：</strong></p><p>是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；</p><p><strong>ApplicationContext：</strong></p><p>应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；</p><p>1) 国际化（MessageSource）</p><p>2) 访问资源，如URL和文件（ResourceLoader）</p><p>3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  </p><p>4) 消息发送、响应机制（ApplicationEventPublisher）</p><p>5) AOP（拦截器）</p><p><strong>两者装载bean的区别</strong></p><p><strong>BeanFactory：</strong></p><p>BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化；</p><p><strong>ApplicationContext：</strong></p><p>ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化； </p><p><strong>我们该用BeanFactory还是ApplicationContent</strong></p><p>延迟实例化的优点：（<strong>BeanFactory</strong>）</p><p>应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势； </p><p>不延迟实例化的优点： （<strong>ApplicationContext</strong>）</p><ol><li><p>所有的Bean在启动的时候都加载，系统运行的速度快； </p></li><li><p>在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题 </p></li><li><p>建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成） </p></li></ol><ol><li>Spring如何解决循环依赖（三级缓存）</li><li>Spring的后置处理器</li><li>Spring的@Transactional如何实现的</li><li>Spring的事务传播级别</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>top100</title>
      <link href="/2019/12/10/top100/"/>
      <url>/2019/12/10/top100/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 两数之和</span><br><span class="line"></span><br><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/two-sum</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. 两数相加</span><br><span class="line"></span><br><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 <span class="number">0</span> 之外，这两个数都不会以 <span class="number">0</span> 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/add-two-numbers</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode rp = res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> a = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> b = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line"></span><br><span class="line">            temp = a + b + next;</span><br><span class="line">            cur = temp%<span class="number">10</span>;</span><br><span class="line">            next = temp/<span class="number">10</span>;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            res = res.next;</span><br><span class="line"></span><br><span class="line">            l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line"></span><br><span class="line">            l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>. 无重复字符的最长子串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-substring-without-repeating-characters</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = <span class="number">0</span>; end &lt; n; end++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">                start = Math.max(map.get(a),start);  <span class="comment">//重点理解，这个地方的max</span></span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end-start+<span class="number">1</span>);</span><br><span class="line">            map.put(a,end+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法</title>
      <link href="/2019/11/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>/2019/11/17/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找非递归实现"><a href="#二分查找非递归实现" class="headerlink" title="二分查找非递归实现"></a>二分查找非递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(array.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> end = array.length -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">       </span><br><span class="line">       mid = (end - start)/<span class="number">2</span> + start;</span><br><span class="line">      <span class="keyword">if</span>(key &gt; array[mid])&#123;</span><br><span class="line">           start = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; array[mid])&#123;</span><br><span class="line">           end = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找递归实现"><a href="#二分查找递归实现" class="headerlink" title="二分查找递归实现"></a>二分查找递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(array[mid] == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; array[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, key, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; array[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, key, start, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = x / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &lt; x) &#123;</span><br><span class="line">            left = (<span class="keyword">int</span>) (mid + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = (<span class="keyword">int</span>) (mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找峰值-（峰值元素是指其值大于左右相邻值的元素）"><a href="#寻找峰值-（峰值元素是指其值大于左右相邻值的元素）" class="headerlink" title="寻找峰值 （峰值元素是指其值大于左右相邻值的元素）"></a>寻找峰值 （峰值元素是指其值大于左右相邻值的元素）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span> || nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>] &gt; nums[nums.length-<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//注意这里的条件：由于求的是峰值，所以只有大于两侧才是峰值，</span></span><br><span class="line">        <span class="comment">//那么在判断时使用小于两侧的情况来决定二分的边界取值。</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到-K-个最接近的元素"><a href="#找到-K-个最接近的元素" class="headerlink" title="找到 K 个最接近的元素"></a>找到 K 个最接近的元素</h3><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="链表相关经典操作"><a href="#链表相关经典操作" class="headerlink" title="链表相关经典操作"></a>链表相关经典操作</h2><h3 id="迭代反转链表"><a href="#迭代反转链表" class="headerlink" title="迭代反转链表"></a>迭代反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node pre = <span class="keyword">null</span>;</span><br><span class="line">  Node next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      next = node.next;</span><br><span class="line">      node.next = pre;</span><br><span class="line">      pre = node;</span><br><span class="line">      node = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归反转链表"><a href="#递归反转链表" class="headerlink" title="递归反转链表"></a>递归反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    Node newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针找到链表中点"><a href="#快慢指针找到链表中点" class="headerlink" title="快慢指针找到链表中点"></a>快慢指针找到链表中点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">midNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">ListNode slow = head;</span><br><span class="line">ListNode fast = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中等于给定值-val-的所有节点"><a href="#删除链表中等于给定值-val-的所有节点" class="headerlink" title="删除链表中等于给定值 val 的所有节点"></a>删除链表中等于给定值 val 的所有节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == head)&#123;</span><br><span class="line">                head = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next = cur.next;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。-1-gt-3-gt-5-gt-2-gt-4"><a href="#给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。-1-gt-3-gt-5-gt-2-gt-4" class="headerlink" title="给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。(1 -&gt; 3  -&gt; 5  -&gt; 2 -&gt;  4)"></a>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。(1 -&gt; 3  -&gt; 5  -&gt; 2 -&gt;  4)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode jNode = head;</span><br><span class="line">    ListNode oNode = head.next;</span><br><span class="line">    ListNode oStart = oNode;</span><br><span class="line">    <span class="keyword">while</span>(jNode.next != <span class="keyword">null</span> &amp;&amp; oNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        jNode.next = jNode.next.next;</span><br><span class="line">        oNode.next = oNode.next.next;</span><br><span class="line">        jNode = jNode.next;</span><br><span class="line">        oNode = oNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    jNode.next = oStart;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过快慢指针找到链表中点，在此过程中把中点之前的节点压入栈</span></span><br><span class="line">    <span class="comment">//然后从中点开始进行值比较，判断是否回文</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(slow);</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点为奇数个时，将中间节点压入（看上方压入顺序，无论奇偶压入中点之前的节点）</span></span><br><span class="line">    <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow.val != stack.pop().val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表（返回入环节点）"><a href="#环形链表（返回入环节点）" class="headerlink" title="环形链表（返回入环节点）"></a>环形链表（返回入环节点）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast != slow)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到两个单链表相交的起始节点"><a href="#找到两个单链表相交的起始节点" class="headerlink" title="找到两个单链表相交的起始节点"></a>找到两个单链表相交的起始节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    解题思路：</span></span><br><span class="line"><span class="comment">    1.先分别计算两个链表a和b的长度，长度差记为lena-lenb（假设a比b长）</span></span><br><span class="line"><span class="comment">    2.长度大的a 从头节点先走lena-lenb个长度，这时a和b一样长</span></span><br><span class="line"><span class="comment">    3.然后挨个节点进行比较</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="number">0</span>;</span><br><span class="line">    ListNode tempA = headA;</span><br><span class="line">    ListNode tempB = headB;</span><br><span class="line">    <span class="keyword">while</span>(tempA != <span class="keyword">null</span>)&#123;</span><br><span class="line">        la++;</span><br><span class="line">        tempA = tempA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tempB != <span class="keyword">null</span>)&#123;</span><br><span class="line">        lb++;</span><br><span class="line">        tempB = tempB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(la &gt; lb)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;la-lb;i++)&#123;</span><br><span class="line">            headA = headA.next;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;lb-la;i++)&#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempA = headA;</span><br><span class="line">    tempB = headB;</span><br><span class="line">    <span class="keyword">while</span>(headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == headB)&#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意边界问题</span></span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cur.next != null 注意这个条件边界，这个条件可以造成的pre指向要删除节点的前一个</span></span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123; </span><br><span class="line">        cur = cur.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归合并两个有序链表"><a href="#递归合并两个有序链表" class="headerlink" title="递归合并两个有序链表"></a>递归合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">        head = l1;</span><br><span class="line">        head.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = l2;</span><br><span class="line">        head.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归合并两个有序链表"><a href="#非递归合并两个有序链表" class="headerlink" title="非递归合并两个有序链表"></a>非递归合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用辅助链表进行合并</span></span><br><span class="line">    ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = temp;<span class="comment">//注意必须返回头引用</span></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            temp.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        temp.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        temp.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数相加-2-gt-4-gt-3-5-gt-6-gt-4"><a href="#两数相加-2-gt-4-gt-3-5-gt-6-gt-4" class="headerlink" title="两数相加 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)"></a>两数相加 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head = res;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = l1.val + l2.val;</span><br><span class="line">        cur = (temp + next)%<span class="number">10</span>;</span><br><span class="line">        next =(temp + next)/<span class="number">10</span>;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">        res = res.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode( (l1.val + next)%<span class="number">10</span> );</span><br><span class="line">            next = (l1.val + next)/<span class="number">10</span>;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(l1.val);            </span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        res = res.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode((l2.val + next)%<span class="number">10</span>);</span><br><span class="line">            next = (l2.val + next)/<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(l2.val);            </span><br><span class="line">        &#125;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        res = res.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(next != <span class="number">0</span>)&#123;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个链表，旋转链表，将链表每个节点向右移动-k-个位置，其中-k-是非负数。"><a href="#给定一个链表，旋转链表，将链表每个节点向右移动-k-个位置，其中-k-是非负数。" class="headerlink" title="给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。"></a>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span></span><br><span class="line"><span class="comment">    输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;  <span class="comment">//注意这个初值和下面的  cur.next != null 对应的关系</span></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = len - (k % len); <span class="comment">//通过这个计算头引用需要迭代多少次到达新头部</span></span><br><span class="line">    cur.next = head; <span class="comment">//构成循环链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = <span class="keyword">null</span>; <span class="comment">//解开循环</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组和字符串经典操作"><a href="#数组和字符串经典操作" class="headerlink" title="数组和字符串经典操作"></a>数组和字符串经典操作</h2><h3 id="至少是其他数字两倍的最大数"><a href="#至少是其他数字两倍的最大数" class="headerlink" title="至少是其他数字两倍的最大数"></a>至少是其他数字两倍的最大数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//验证最大的数值是否是第二大的两倍即可</span></span><br><span class="line">    <span class="keyword">int</span> max1 =-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max2 =-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; max1)&#123;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; max2)&#123;</span><br><span class="line">            max2 = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max1 &gt;= <span class="number">2</span>*max2 ? maxIndex : -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一"><a href="#给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一" class="headerlink" title="给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一"></a>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = digits.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="comment">// 非9加1</span></span><br><span class="line">        <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是前一位需要进位的话那么前一位置为0,就在后一位(也就是此时的当前位+1)</span></span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="comment">// 直接把改变之后的数组返回(因为当前位不是9就不需要进位了,前面该进的位都已经进了所以直接把数组返回就行了)</span></span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逢9进0</span></span><br><span class="line">        digits[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部为9,则需要数组扩充1位</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 如果位数全部都是9的话,那么遍历原来=数组上的所有的数,都是让数组上的所有的数变成0</span></span><br><span class="line"><span class="comment">          * 也就是说明上面的if代码里面的内柔都是没有走的,就需要进行数组扩容</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制求和-给定两个二进制字符串，返回他们的和（用二进制表示）。"><a href="#二进制求和-给定两个二进制字符串，返回他们的和（用二进制表示）。" class="headerlink" title="二进制求和 给定两个二进制字符串，返回他们的和（用二进制表示）。"></a>二进制求和 给定两个二进制字符串，返回他们的和（用二进制表示）。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = a.length() -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lb = b.length() -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(la &gt;=<span class="number">0</span> || lb &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(la &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cur +=  (a.charAt(la) - <span class="string">'0'</span>);</span><br><span class="line">            la--;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(lb &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cur += (b.charAt(lb) - <span class="string">'0'</span>);</span><br><span class="line">            lb--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur += next;</span><br><span class="line"></span><br><span class="line">        res.append(cur%<span class="number">2</span>);</span><br><span class="line">        next = cur / <span class="number">2</span>;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(next != <span class="number">0</span>)&#123;</span><br><span class="line">        res.append(next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个数组-nums-和一个值-val，你需要-原地-移除所有数值等于-val-的元素，返回移除后数组的新长度"><a href="#给定一个数组-nums-和一个值-val，你需要-原地-移除所有数值等于-val-的元素，返回移除后数组的新长度" class="headerlink" title="给定一个数组 nums 和一个值 val，你需要*原地**移除所有数值等于 *val 的元素，返回移除后数组的新长度"></a>给定一个数组 <em>nums</em> 和一个值 <em>val<em>，你需要*</em>原地**移除所有数值等于 *val</em> 的元素，返回移除后数组的新长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    元素的顺序可以改变。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num != val) &#123;</span><br><span class="line">            nums[res] = num;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = s.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( start &lt; end )&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s[start];</span><br><span class="line">        s[start] = s[end];</span><br><span class="line">        s[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树问题"><a href="#二叉树问题" class="headerlink" title="二叉树问题"></a>二叉树问题</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h3><p>难度简单460</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            max++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node = queue.pollFirst();<span class="comment">//找到列表第一个元素返回，并删除</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="783-二叉搜索树结点最小距离"><a href="#783-二叉搜索树结点最小距离" class="headerlink" title="783. 二叉搜索树结点最小距离"></a><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">783. 二叉搜索树结点最小距离</a></h3><p>给定一个二叉搜索树的根结点 <code>root</code>, 返回树中任意两节点的差的最小值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [4,2,6,1,3,null,null]</span><br><span class="line">输出: 1</span><br><span class="line">解释:</span><br><span class="line">注意，root是树结点对象(TreeNode object)，而不是数组。</span><br><span class="line"></span><br><span class="line">给定的树 [4,2,6,1,3,null,null] 可表示为下图:</span><br><span class="line"></span><br><span class="line">          4</span><br><span class="line">        /   \</span><br><span class="line">      2      6</span><br><span class="line">     / \    </span><br><span class="line">    1   3  </span><br><span class="line"></span><br><span class="line">最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>二叉树的大小范围在 <code>2</code> 到 <code>100</code>。</li><li>二叉树总是有效的，每个节点的值都是整数，且不重复。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer prev, ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">            ans = Math.min(ans, node.val - prev);</span><br><span class="line">        prev = node.val;</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-into-a-Binary-Search-Tree-递归方式"><a href="#Insert-into-a-Binary-Search-Tree-递归方式" class="headerlink" title="Insert into a Binary Search Tree 递归方式"></a>Insert into a Binary Search Tree 递归方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">        root.left = insertIntoBST(root.left,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.right = insertIntoBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-into-a-Binary-Search-Tree-迭代方式"><a href="#Insert-into-a-Binary-Search-Tree-迭代方式" class="headerlink" title="Insert into a Binary Search Tree 迭代方式"></a>Insert into a Binary Search Tree 迭代方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    TreeNode temp = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.val &gt; val)&#123;<span class="comment">//进入左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;左子树为空 进行插入</span><br><span class="line">                node.left = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.right = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中实现删除操作"><a href="#二叉搜索树中实现删除操作" class="headerlink" title="二叉搜索树中实现删除操作"></a>二叉搜索树中实现删除操作</h3><ol><li>如果目标节点<strong><em>没有子节点</em></strong>，我们可以直接移除该目标节点。</li><li>如果目标节<strong><em>只有一个子节点</em></strong>，我们可以用其子节点作为替换。</li><li>如果目标节点<strong><em>有两个子节点</em></strong>，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点。（用其右子树的最小节点（最左子树）作为新节点替换，然后重新构建右子树）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode temp = search(root.right);<span class="comment">//右子树的最左子树即最小节点</span></span><br><span class="line">        root.val = temp.val;</span><br><span class="line">        root.right = deleteNode(root.right, temp.val);<span class="comment">//重新构建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">search</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个二叉树，判断它是否是高度平衡的二叉树。"><a href="#给定一个二叉树，判断它是否是高度平衡的二叉树。" class="headerlink" title="给定一个二叉树，判断它是否是高度平衡的二叉树。"></a>给定一个二叉树，判断它是否是高度平衡的二叉树。</h3><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; <span class="comment">//递归获取每个子节点是否高度平衡</span></span><br><span class="line">        isBalanced(root.right) &amp;&amp; </span><br><span class="line">        Math.abs(getHeight(root.left)-getHeight(root.right)) &lt;= <span class="number">1</span>; <span class="comment">//每个节点高度平衡的条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(getHeight(root.left),getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树的中序遍历（左 根 右）就会形成有序数组，所以有序数组的二分查找可以还原成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getTree</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = getTree(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">    root.right = getTree(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p><strong>迭代实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="comment">//都比根节点值小，去根节点的左子树继续找</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="comment">//都比根节点值大，去根节点的右子树继续找</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根节点的值大于p而小于q，说明此时的根节点即为最近公共祖先。</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">            left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">            right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h3><p>难度简单1623</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i-<span class="number">1</span>] + nums[i] : nums[i];</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum = sum + num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h3><p>难度简单840</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p>本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p><p>​    爬上 n-1n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶<br>​    爬上 n-2n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶<br>​    所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]dp[n]=dp[n−1]+dp[n−2]<br>​    同时需要初始化 dp[0]=1dp[0]=1 和 dp[1]=1dp[1]=1<br>​    时间复杂度：O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i &lt; n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum[i] = sum[i-<span class="number">1</span>] + sum[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h3><p>难度简单229</p><p>数组的每个索引做为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>思路：</strong></p><p>从地面可以直接跃向第0级或第1级，花费分别为dp[0]=cost[0]、dp[1]=cost[1]，对于跨到2阶，可以从第0阶跨两步，耗费dp[0]+cost[2]；或者可以从第1阶跨一步，耗费dp[1]+cost[2]，所以，对于跨到第n层，可以从第dp[n-2]跨两步，或者从dp[n-1]跨一步，耗费cost[n]，求出dp[n-1]和dp[n-2]的最小值就可以得到爬到第n阶的最小耗费。</p><p><strong>状态转移方程为：dp[n] = Math.min(dp[n-1],dp[n-2]) + cost[n];</strong></p><p><strong>最后比较从第n-1阶迈到楼顶的花费和从n-2阶迈到楼顶花费的最小值即可</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;cost.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[dp.length-<span class="number">2</span>],dp[dp.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h3><p>难度简单739</p><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>思路：</strong></p><ol><li><p>如果length小于1，那么不存在买入卖出，返回0</p></li><li><p>设置prices[0]为初始最小值，以及利润res = 0, 从prices[1]开始进行比较</p></li><li><p>如果prices[i]小于最小值，那么进行最小值变换</p></li><li><p>如果最小值没有发生变换，那么通过 res =  Math.max(prices[i]-min,res); 计算并变更最大利润</p></li><li><p>如果res没有变成负数，那么返回res,否则返回0</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;min)&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(prices[i]-min,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt; <span class="number">0</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quickSort;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="comment">//private static int count;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">3</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">11</span>,<span class="number">64</span>,<span class="number">55</span>,<span class="number">99</span>,<span class="number">11</span>,<span class="number">18</span>&#125;;</span><br><span class="line">System.out.println(arrayToString(num,<span class="string">"未排序"</span>));</span><br><span class="line">QuickSort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">System.out.println(arrayToString(num,<span class="string">"排序"</span>));</span><br><span class="line"><span class="comment">//System.out.println("数组个数："+num.length);</span></span><br><span class="line"><span class="comment">//System.out.println("循环次数："+count);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left数组的前针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组后针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果left等于right，即数组只有一个元素，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置最左边的元素为基准值</span></span><br><span class="line"><span class="keyword">int</span> key=num[left];</span><br><span class="line"><span class="comment">//数组中比key小的放在左边，比key大的放在右边，key值下标为i</span></span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=right;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="comment">//j向左移，直到遇到比key小的值</span></span><br><span class="line"><span class="keyword">while</span>(num[j]&gt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i向右移，直到遇到比key大的值</span></span><br><span class="line"><span class="keyword">while</span>(num[i]&lt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i和j指向的元素交换</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=num[i];</span><br><span class="line">num[i]=num[j];</span><br><span class="line">num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//将作为基准值的位置和num[i]交换位置</span></span><br><span class="line">num[left]=num[i];</span><br><span class="line">num[i]=key;</span><br><span class="line"><span class="comment">//count++;</span></span><br><span class="line">QuickSort(num,left,i-<span class="number">1</span>);</span><br><span class="line">QuickSort(num,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个int类型数组转化为字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr,String flag)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"数组为("</span>+flag+<span class="string">")："</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">str += a + <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>时间复杂度：O(nlogn)</strong></p><p><strong>空间复杂度：O(N)</strong>，归并排序需要一个与原数组相同长度的数组做辅助来排序</p><p>稳定性：归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/12/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h2><h3 id="两线程奇偶数打印"><a href="#两线程奇偶数打印" class="headerlink" title="两线程奇偶数打印"></a>两线程奇偶数打印</h3><p>有一些人这里可能会用讨巧的，用一个线程进行循环，在每次循环里面都会做是奇数还是偶数的判断，然后打印出这个我们想要的结果。在这里我们不过多讨论这种违背题目本意的做法。</p><p>其实要做这个题目我们就需要控制两个线程的执行顺序，偶线程执行完之后奇数线程执行，这个有点像通知机制，偶线程通知奇线程，奇线程再通知偶线程。而一看到通知/等待，立马就有朋友想到了Object中的wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 交替打印奇偶数 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoulutionTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (value &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (SoulutionTask.class)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + value++);</span><br><span class="line">                    SoulutionTask.class.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SoulutionTask.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> SoulutionTask(), <span class="string">"偶数"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> SoulutionTask(), <span class="string">"奇数"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程按顺序打印ABC"><a href="#多线程按顺序打印ABC" class="headerlink" title="多线程按顺序打印ABC"></a>多线程按顺序打印ABC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Solution(<span class="string">"A"</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Solution(<span class="string">"B"</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Solution(<span class="string">"C"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadName = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程私有变量，存储运行次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态变量，存储哪一个线程应该运行的标志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String flag = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(String threadName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//对flag加同步锁，防止空轮询</span></span><br><span class="line">            <span class="keyword">synchronized</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag.equals(threadName))&#123;</span><br><span class="line">                    System.out.println(threadName);</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"A"</span>.equals(threadName))&#123;</span><br><span class="line">                        flag = <span class="string">"B"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"B"</span>.equals(threadName))&#123;</span><br><span class="line">                        flag = <span class="string">"C"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"C"</span>.equals(threadName))&#123;</span><br><span class="line">                        flag = <span class="string">"A"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java实现阻塞队列"><a href="#Java实现阻塞队列" class="headerlink" title="Java实现阻塞队列"></a>Java实现阻塞队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">private</span> List queue = <span class="keyword">new</span> LinkedList();  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span>  limit = <span class="number">10</span>;  </span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> limit)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.limit = limit;  </span><br><span class="line">      &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Object item)</span>  </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException  </span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.queue.size() &gt;= <span class="keyword">this</span>.limit) &#123;  </span><br><span class="line">          wait();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queue.size() &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">          notifyAll();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.queue.add(item);  </span><br><span class="line">      &#125;  </span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">dequeue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException</span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.queue.size() == <span class="number">0</span>)&#123;  </span><br><span class="line">          wait();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.queue.size() &gt;= <span class="number">0</span>)&#123;  </span><br><span class="line">          notifyAll();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.remove();  </span><br><span class="line">      &#125;  </span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql命令总结</title>
      <link href="/2019/10/17/Mysql%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/17/Mysql%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 进入mysql命令行</span></span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示哪些线程在运行</span></span><br><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统变量信息</span></span><br><span class="line">show variables;</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2019/10/15/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/10/15/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p><img src="//qx-ljy.cn/2019/10/15/数据链路层/01.png" alt></p><p><strong>如上图所示，链路层主要有三个目的：</strong></p><ol><li><p>为IP模块发送和接收数据报  </p></li><li><p>为ARP模块发送ARP请求和接收ARP应答</p></li><li><p>为RARP发送RARP请求和接收RARP应答（RARP现在已经淘汰不用了）</p></li></ol><p><strong>链路层的三个基本问题：</strong></p><ol><li><strong>封装成帧</strong> ：将网络层传下来的数据分组添加首部和尾部，用于标记帧的开始和结束。每一种链路层协议都规定了所能传送 <strong>帧的数据部分</strong> 长度上限—-最大传输单元 MTU。</li></ol><blockquote><p>以太网（Ethernet）协议：1500字节<br>Point-to-Point：4470字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up/Modem）：576字节<br>FDDI协议：4352字节</p></blockquote><ol start="2"><li><p><strong>透明传输</strong> ：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧开始结束的地方就会错误地被判定。（在数据部分出现首部尾部相同的内容前面加上转义字符（“ESC”，16进制编码是 1B，二进制是 00011011）。如果数据部分出现转义字符，那就在转义字符前面再加上一个转义字符。接受端进行处理后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在）</p></li><li><p><strong>差错检测</strong> ：目前链路层广泛使用了循环冗余校验（CRC）来检查比特差错。</p></li></ol><p><strong>MAC地址</strong></p><p>在局域网中，硬件地址又叫做物理地址或MAC地址（因为这种地址在MAC帧中使用）</p><p>MAC地址长48比特（6个字节），在使用网卡（NIC）时，MAC地址一般会烧入到ROM（只读存储器（Read-Only Memory））中。</p><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>PPP（Point-to-Point Protocol）是指点对点，即1对1连接计算机的协议。</p><h3 id="LCP-与-NCP"><a href="#LCP-与-NCP" class="headerlink" title="LCP 与 NCP"></a>LCP 与 NCP</h3><p>PPP主要功能中包括两个协议：一个是不依赖上层的LCP协议（Link Control Protocol），一个是依赖上层的NCP协议（Network Control Protocol）。如果上层为IP，此时NCP也叫作IPCP（IP Control Protocol）。</p><p>LCP主要负责建立和断开连接，设置最大接收单元（MRU）、设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控。而IPCP负责IP地址设置以及是否进行TCP/IP首部压缩等。</p><h3 id="PPP帧格式"><a href="#PPP帧格式" class="headerlink" title="PPP帧格式"></a>PPP帧格式</h3><p><img src="//qx-ljy.cn/2019/10/15/数据链路层/02.png" alt></p><p>0x0021：IP数据报<br>0xc021：链路控制数据 (LCP)<br>0x8021：网络控制数据 (NCP)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(三)----垃圾回收算法和垃圾收集器</title>
      <link href="/2019/10/04/jvm4/"/>
      <url>/2019/10/04/jvm4/</url>
      
        <content type="html"><![CDATA[<h2 id="对象是否可被回收"><a href="#对象是否可被回收" class="headerlink" title="对象是否可被回收"></a>对象是否可被回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p><strong>实现原理：</strong> 为每个对象配备一个整形的计数器，例如，对象A，只要有任何对象引用了A，则A的引用计数器就加1，当引用失效时，减1；当A的引用计数器为0时，对象A就不可能再被使用，即可以进行回收。</p><p><strong>存在问题：</strong></p><ol><li>无法处理循环引用的问题。所以在Java垃圾回收器中，没有使用这种方法。</li></ol><blockquote><p>循环引用：有对象A和B，A中含有对象B的引用，对象B中含有A的引用；此时，A和B的计数器都不为0，即无法进行回收；但是在整个系统中，没有其他对象引用了A和B，A和B是应该被回收的对象，但由于垃圾对象之间的互相引用，从而使垃圾回收器无法识别，造成内存泄漏。</p></blockquote><ol start="2"><li>引用计数器要求每次引用产生和消除的时候，都要伴随一次加减操作，对系统性能有一定影响。</li></ol><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p><strong>实现原理：</strong> 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链时（即不可达），则此对象不可用，可以判定为可回收对象。</p><p><strong>可以作为 GC Roots 的对象：</strong>  </p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li></ol><h3 id="判断可触及性"><a href="#判断可触及性" class="headerlink" title="判断可触及性"></a>判断可触及性</h3><p>通过可达性分析法可以判断哪些对象不可达。一般来说，不可达对象需要被回收。但事实上，该对象有可能在某一条件下“复活自己”，如果这样，再回收就不合理了。为此需要定义对象的可触及性状态，并规定在什么状态下，可以安全回收对象。</p><p><strong>可触及性包含三种状态：</strong>  </p><ul><li><p>可触及的：从根节点出发，可以到达这个对象。</p></li><li><p>可复活的：对象的所有引用都被释放，但是对象有可能在 <strong>finalize()</strong> 函数中复活。</p></li><li><p>不可触及的：对象的finalize()函数被调用，并且没有复活，或者 <strong>对象的 finalize() 没有重写（没必要执行）</strong>， 那么就会进入不可触及状态，此时对象不可能被复活，因为 finalize() 只会被调用一次。</p></li></ul><p><strong>对象只有在不可触及状态时，才可以被回收。</strong></p><p><strong>注意:</strong>  </p><ul><li><p>finalize()函数是一个非常糟糕的模式，不推荐使用它释放资源。</p></li><li><p>finalize() 有可能发生引用外泄，在无意中复活对象。</p></li><li><p>finalize() 被系统调用，调用时间不明确。释放资源推荐在 try-catch-finally 中实现。</p></li></ul><h3 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h3><p>Java 提供四个级别的引用，由强到弱依次是：强引用、软引用、弱引用、虚引用。除强引用外，其他都可以在 java.lanf.ref 包中找到。</p><p><strong>不同引用级别出现的意义：</strong> 希望描述这样一类对象：当内存对象还足够时，则保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。</p><ul><li><p>强引用：类似 Object object = new Object() 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉引用的对象。</p></li><li><p>软引用：用来描述一些还有用但是非必须的对象。对于软引用关联的对象，系统将在发生内存溢出前，将这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p></li><li><p>弱引用：用来描述非必须对象。它关联的对象只能拿生存到下一次垃圾收集发生之前，当垃圾回收器工作时，无论内存是否足够，都会回收被弱引用关联的对象。</p></li><li><p>虚引用：一个对象是否有虚引用，完全不会影响其生存周期，也无法通过虚引用取得对象实例。为对象设置虚引用关联的唯一目的是能在这个对象被回收时得到系统通知。</p></li></ul><p><strong>软引用，弱引用非常适合保存可有可无的缓存数据，从而加速系统运行。</strong></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>顾名思义：此算法分为两个阶段 标记 和 清除。</p><p>标记：标记的过程其实就是，遍历所有的 GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。  </p><p>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</p><p><strong>不足：</strong>  </p><ol><li><p>效率问题：标记和清除过程的效率都不高。</p></li><li><p>空间碎片问题：标记清除后会出现大量不连续的内存碎片，空间碎片太多会导致以后程序运行无法分配较大对象时，提前触发GC。</p></li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将原有的内存空间分为两块，每次只是用其中一块，在GC时，将正在使用的内存中存活对象复制到未使用的内存块中，然后，清除正在使用内存的所有对象，交换两块内存的角色。</p><p>复制算法适合存活对象少、垃圾对象多的情况，所以复制算法很适合新生代（新生代中垃圾对象通常多于存活对象）。</p><p>新生代中的 Eden 存活下来的对象，Survivor区不能完全存放，那么这些对象会通过分配担保机制进入老年代。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法是一种老年代的回收算法。首先需要从根节点开始，对所有可达对象做一次标记，然后将所有存活对象整理到内存的一端，之后清理边界外所有的空间。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。</p><p>对于新生代，回收频率很高，但每次GC耗时很短，而老年代频率低，但会消耗更长的时间。为了支持高频率的新生代回收，虚拟机使用一种叫做卡表的数据结构。卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。</p><p>这样在新生代GC时，可以不用耗大量时间扫描所有老年代对象，来确定引用关系，可以先扫描卡表，卡表位为1时，才包含新生代引用，在新生代GC时，只需扫描卡表位为1所在的老年代空间,这样可大大加快新生代回收速度。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>分区算法将整个堆空间划分成连续的小区间。每个小区间都独立使用，独立回收。这种做法的好处是可以控制一次回收多少个小区间，从而很好的控制GC产生的停顿时间。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>新生代串行回收器：</p><ol><li><p>它只使用单线程进行垃圾回收</p></li><li><p>它是独占式的垃圾回收</p></li></ol><p>由于串行收集器只使用单线程回收，所以在垃圾回收时会出现“Stop The World”。这样会造成很槽糕的用户体验，在实时性要求较高的场景不适应。</p><p>由于新生代串行收集器使用复制算法，实现相对简单，逻辑处理特别高效，而且没有线程切换开销。在单CPU处理器等硬件平台不是特别优越的场合，它的性能可以超过并行回收器和并发回收器。  </p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>老年代串行回收器：</p><ol><li><p>使用的是标记-整理算法</p></li><li><p>串行的，它是独占式的</p></li></ol><p>可以作为CMS回收器的备用回收器  </p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>新生代并发回收器</p><ol><li><p>回收策略，算法，参数和新生代串行回收器一样</p></li><li><p>回收过程进行了多线程化，但是回收过程应用程序依旧会全部暂停</p></li></ol><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>同样也是新生代并发收集器，但是它却注重系统吞吐量。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>老年代并发回收器，使用标记-清除算法</p><ol><li>多线程并发收集器，也是一种关注吞吐量的收集器</li></ol><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>老年代并发收集器，主要关注于系统停顿时间。</p><ol><li><p>初始标记： STW（Stop The World）标记根对象</p></li><li><p>并发标记：标记所有对象</p></li><li><p>预清理：清理前准备以及控制停顿时间</p></li><li><p>重新标记：STW，修正并发标记数据</p></li><li><p>并发清理：清理垃圾</p></li><li><p>并发重置</p></li></ol><p>初始标记和重新标记是独占系统资源的，而预清理、并发标记、并发清除和并发重置是可以和用户线程一起执行的。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/10/02/designpattern/"/>
      <url>/2019/10/02/designpattern/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式（proxy模式）"><a href="#代理模式（proxy模式）" class="headerlink" title="代理模式（proxy模式）"></a>代理模式（proxy模式）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。</p></li><li><p>好处：可以在目标对象的基础上，增强额外的功能操作，即拓展目标对象的功能。<strong>只在必要时生成实例</strong></p></li><li><p>被代理的对象可以是远程对象，创建开销大的对象，需要安全控制的对象</p></li><li><p>代理模式有不同形式，主要有三种 <strong>静态代理，动态代理（JDK代理，接口代理）和 Cglib代理（可以在内存中动态的创建对象，而不需要实现接口，属于动态代理的范畴）。</strong></p></li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同父类。</strong>  </p><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teach</span> <span class="keyword">implements</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师授课中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象，静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeachProxy</span> <span class="keyword">implements</span> <span class="title">Teacherable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Teacherable target; <span class="comment">//  目标对象，通过接口聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeachProxy</span><span class="params">(Teacherable target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理开始 完成某些操作"</span>);</span><br><span class="line">        target.Teach();</span><br><span class="line">        System.out.println(<span class="string">"代理结束。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teach对象</span></span><br><span class="line"><span class="comment">     * 创建TeachProxy代理对象</span></span><br><span class="line"><span class="comment">     * 将Teach对象，交给TeachProxy对象执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象，被代理对象</span></span><br><span class="line">        Teach teach = <span class="keyword">new</span> Teach();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传递给代理对象</span></span><br><span class="line">        TeachProxy teachProxy = <span class="keyword">new</span> TeachProxy(teach);</span><br><span class="line">        <span class="comment">//通过代理对象，调用代理对象的方法</span></span><br><span class="line">        <span class="comment">//执行的是代理对象的方法，代理对象再去调用目标对象的方法</span></span><br><span class="line">        teachProxy.Teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li><p>优点：在不修改目标对象的功能前提下，能通过代理对象对目标对象功能拓展  </p></li><li><p>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类  </p></li><li><p>一旦接口增加方法，目标对象与代理对象都要维护</p></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ol><li><p>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理  </p></li><li><p>代理对象的生成，是利用JDK的API，动态在内存中构建代理对象  </p></li><li><p>动态代理也叫作：JDK代理，接口代理  </p></li></ol><p><strong>JDK生成代理对象的API：</strong>  </p><ol><li><p>代理类所在包：java.lang.reflect.Proxy</p></li><li><p>JDK实现代理只需要使用newProxyInstance方法：<strong>static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</strong>  </p></li></ol><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" : 正在授课"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象，Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，对target进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象，生成一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         *                                       Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         *                                       InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * 1. ClassLoad loader : 指定当前目标对象使用的类加载器，获取加载器的方法固定</span></span><br><span class="line"><span class="comment">         * 2. Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">         * 3. InvocationHandler h : 事件处理，执行目标对象的方法时，会触发事件处理器方法，（会把当前执行的目标对象作为参数传入）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"JDK 代理开始"</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        Object returnVal = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"JDK 代理结束"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        Teacherable target = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象</span></span><br><span class="line">        Teacherable proxyInstance = (Teacherable) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//class com.sun.proxy.$Proxy0  内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(proxyInstance.getClass());</span><br><span class="line">        <span class="comment">//通过代理对象调用目标对象的方法</span></span><br><span class="line">        proxyInstance.Teach(<span class="string">"ljy"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><ol><li><p>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候可以使用目标对象子类来实现代理，这就是Cglib代理  </p></li><li><p>Cglib代理也叫作子类代理，它在内存中构建一个子类对象从而实现对目标对象功能的拓展，有些书也将Cglib代理归属到动态代理</p></li><li><p>Cglib是一个强大的高性能的代码生成包，它可以在运行期拓展java类与实现java接口。它广泛的被许多AOP框架使用，如Spring AOP，实现方法拦截</p></li><li><p>在AOP编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理  </li></ul></li><li><p>Cglib包的底层是通过字节码处理框架ASM来转换字节码并生成新的类  </p></li><li><p>Cglib在内存中构建子类，注意代理的类不能为final，否则报错。  </p></li><li><p>目标对象的方法如果为 final/static ,那么就不会拦截，即不会执行目标对象额外的业务方法。</p></li></ol><p><strong>应用实例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象： 是target的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建一个工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2. 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 intercept 方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cglib 代理 开始"</span>);</span><br><span class="line">        Object returnVal = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"Cglib 代理 结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cglib代理: "</span> + name + <span class="string">" : 正在授课"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        Teacher target = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">//获取代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        Teacher proxyInstance = (Teacher) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法，触发intercept方法，实现对目标对象的调用</span></span><br><span class="line">        proxyInstance.Teach(<span class="string">"ljy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式（Adapter模式）"><a href="#适配器模式（Adapter模式）" class="headerlink" title="适配器模式（Adapter模式）"></a>适配器模式（Adapter模式）</h2><ol><li><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作。别名包装器（Wrapper）</p></li><li><p>适配器模式属于结构型模式</p></li><li><p>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p></li></ol><p><strong>工作原理：</strong>  </p><ol><li><p>适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</p></li><li><p>从用户角度看不到被适配者，是解耦的</p></li><li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p></li><li><p>用户收到反馈结果，感觉只是和目标接口交互  </p></li></ol><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><ol><li><p>Java是单继承机制，所以类适配器需要继承src类（被适配的类），这一点算是一个缺点。因为这要求dst（适配接口）必须是接口，有一定的局限性</p></li><li><p>src类的方法在Adapter中都会暴露出来，也增加了使用的成本</p></li><li><p>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压 : "</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5Vable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取220V电压</span></span><br><span class="line">        <span class="keyword">int</span> srcV  = output220V();</span><br><span class="line">        <span class="keyword">int</span> dstV = srcV/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charging</span><span class="params">(Voltage5Vable voltage5Vable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(voltage5Vable.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5伏，可以充电"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voltage5Vable.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压大于5伏，无法充电"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== 类适配器 ===="</span>);</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.Charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><ol><li><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实现，以解决兼容性的问题。即持有src类，实现dst类接口，完成src-&gt;dst的适配</p></li><li><p>根据“合成服用原则”，在系统中尽量使用关联关系来替代继承关系</p></li><li><p>对象适配器模式是适配器模式常用的一种</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压 : "</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入Voltage220V实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V)&#123;</span><br><span class="line">            <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220电压</span></span><br><span class="line">            System.out.println(<span class="string">"使用对象适配器转换"</span>);</span><br><span class="line">            dst = src/<span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">"适配完成: "</span>+ dst + <span class="string">"伏"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charging</span><span class="params">(Voltage5Vable voltage5Vable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(voltage5Vable.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5伏，可以充电"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voltage5Vable.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压大于5伏，无法充电"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== 类适配器 ===="</span>);</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.Charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><ol><li><p>一些书籍将之称为：适配器模式或缺省适配器模式</p></li><li><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类某些方法来实现需求</p></li><li><p>适用于一个接口不想适用其所有的方法的情况</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在AbsAdapter 将TestInterface 的方法默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter()&#123;</span><br><span class="line">            <span class="comment">//只需覆盖我们需要使用的接口方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用m1方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="职责链模式（Chain-of-Responsibility-Pattern）"><a href="#职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="职责链模式（Chain of Responsibility Pattern）"></a>职责链模式（Chain of Responsibility Pattern）</h2><ol><li><p>职责链模式又叫责任链模式，为请求创建一个接受者对象的链。这种模式对请求的发送者和接受者进行解耦</p></li><li><p>职责链模式通常每个接受者都包含另一个接受者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接受者，以此类推</p></li><li><p>属于行为型模式</p></li></ol><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>;<span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type, <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Approver approver; <span class="comment">//下一个处理者</span></span><br><span class="line">    String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver approver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.approver = approver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理请求的方法，处理是子类完成，所以该方法设置成抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//其他角色的处理与之类似，这里不再详述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请求编号id = "</span> + purchaseRequest.getId() + <span class="string">" 被 "</span> + <span class="keyword">this</span>.name + <span class="string">" 处理"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">1</span>, <span class="number">31000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建审批人</span></span><br><span class="line">        DepartmentApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">"主任"</span>);</span><br><span class="line">        CollegeApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">"院长"</span>);</span><br><span class="line">        ViceSchoolMasterApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">"副校长"</span>);</span><br><span class="line">        SchoolMasterApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">"校长"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将各级别审批下一个指向设置，即设置责任链</span></span><br><span class="line">        <span class="comment">// (处理人构成环形：可以从任意一个处理方进行调用；不设置成环形：必须从最开始进行调用)</span></span><br><span class="line">        departmentApprover.setApprover(collegeApprover);</span><br><span class="line">        collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">        viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">        schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul><li>动态的将新功能附加到对象上。在对象拓展功能方面，它比继承更有弹性，装饰者模式也体现了开闭原则（OCP）。</li></ul><h3 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h3><ol><li><p>Component：增加功能时的核心角色</p></li><li><p>ConcreteComponent：实现了Component角色所定义的接口（API）的具体</p></li><li><p>Decorator：</p></li><li><p>ConcreteDecorator：</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO详解</title>
      <link href="/2019/10/02/NIO/"/>
      <url>/2019/10/02/NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h1><p>Java NIO Buffer用于和NIO Channel交互。我们从Channel中读取数据到Buffer中，从Buffer把数据写到Channel。</p><p><strong>核心缓冲区如下：</strong></p><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p></li><li><p>LongBuffer</p></li></ul><p><strong>利用Buffer读写数据，通常遵循四个步骤：</strong></p><ol><li><p>把数据写入Buffer（Buffer被创建时是写模式）</p></li><li><p>调用flip（）函数（将Buffer从写模式，转换为读模式）</p></li><li><p>从Buffer中读取数据</p></li><li><p>调用buffer.clear()或者buffer.compact() （重置Buffer，转为写模式）</p></li></ol><p>当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过 flip() 方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，转换为写入操作。清空buffer有两种方式：调用 clear() 或 compact() 方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。</p><p><strong>Buffer的三种属性：</strong></p><ul><li><p>capacity容量</p><blockquote><p>容量（Capacity） 作为一块内存，buffer有一个固定的大小，叫做capacit（容量）。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据.</p></blockquote></li><li><p>position位置</p><blockquote><p>位置（Position） 当写入数据到Buffer的时候需要从一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.<br>当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</p></blockquote></li><li><p>limit限制</p><blockquote><p>上限（Limit） 在写模式，limit的含义是我们所能写入的最大数据量，它等同于buffer的容量。一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。</p></blockquote></li></ul><h2 id="Buffer-常见用法"><a href="#Buffer-常见用法" class="headerlink" title="Buffer 常见用法"></a>Buffer 常见用法</h2><p>这里用ByteBuffer为例</p><h3 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">28</span>);</span><br></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(i)</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x; <span class="comment">//hb为存放在heap的底层数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;  <span class="comment">//这里offset初始值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.flip() <span class="comment">//将写入模式转换为读取模式</span></span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用flip()方法，会将limit位置设置为写入模式时的position，即limit变为写入数据的最大坐标；position设置为0，代表可以从0开始读取数据；mark = -1 ,即将mark重置。</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.get()</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())]; <span class="comment">//hb为存放在heap的底层数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复读取"><a href="#重复读取" class="headerlink" title="重复读取"></a>重复读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.rewind()</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer.rewind()方法将position置为0，这样我们可以重复读取buffer中的数据。limit保持不变。</p><h3 id="Buffer重置"><a href="#Buffer重置" class="headerlink" title="Buffer重置"></a>Buffer重置</h3><p>重置后变为写模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf.compact()</span><br></pre></td></tr></table></figure><p>一旦Buffer中读取完数据，需要复用Buffer为下次写数据做准备。</p><ul><li><p>clear()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><ul><li><p>compact()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.arrayCopy(Object srcArray,<span class="keyword">int</span> srcPos,Object destArray ,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">Object srcArray 原数组（要拷贝的数组）</span><br><span class="line"><span class="keyword">int</span> srcPos 要复制的原数组的起始位置（数组从<span class="number">0</span>位置开始）</span><br><span class="line">Object destArray 目标数组</span><br><span class="line"><span class="keyword">int</span> destPos 目标数组的起始位置</span><br><span class="line"><span class="keyword">int</span> length 原数组的长度</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset; <span class="comment">//offset 默认为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">discardMark</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</p><h3 id="Buffer标记"><a href="#Buffer标记" class="headerlink" title="Buffer标记"></a>Buffer标记</h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Buffer-比较"><a href="#Buffer-比较" class="headerlink" title="Buffer 比较"></a>Buffer 比较</h3><ul><li>equals()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == ob)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> ByteBuffer))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ByteBuffer that = (ByteBuffer)ob;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remaining() != that.remaining())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.limit() - <span class="number">1</span>, j = that.limit() - <span class="number">1</span>; i &gt;= p; i--, j--)</span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="keyword">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compareTo()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断两个buffer相对，需满足：</p><ul><li>类型相同</li><li>buffer中剩余字节数相同</li><li>所有剩余字节相等</li></ul><p>从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。 compareTo(): compareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的：</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="Java-NIO-Channel-的特点"><a href="#Java-NIO-Channel-的特点" class="headerlink" title="Java NIO Channel 的特点"></a>Java NIO Channel 的特点</h2><ul><li><p>OIO流一般是单向的（只能读或者写），通道可以读也可以写</p></li><li><p>OIO流读写是阻塞的，而通道可以是异步读写的。</p></li><li><p>通道总是基于缓冲区Buffer来读写。</p></li></ul><h2 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h2><ol><li><p>FileChannel</p><p>用于文件读写操作</p></li><li><p>DatagramChannel  </p><p>用于UDP数据读写</p></li><li><p>SocketChannel</p><p>用于TCP数据读写</p></li><li><p>ServerSocketChannel</p><p>允许我们监听TCP链接请求，每个请求会创建一个SocketChannel</p></li></ol><h2 id="Channel的使用"><a href="#Channel的使用" class="headerlink" title="Channel的使用"></a>Channel的使用</h2><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取FileChannel对象</span></span><br><span class="line">    RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    FileChannel fileChannel = file.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据到Buffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">int</span> bytesRead = fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    buf.clear();</span><br><span class="line">    buf.put(newData.getBytes());</span><br><span class="line">    buf.flip();</span><br><span class="line">    <span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">        fileChannel.write(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    fileChannel.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强制刷新磁盘</span></span><br><span class="line">    <span class="comment">//FileChannel的force()方法将所有未写入的数据从通道刷新到磁盘中。</span></span><br><span class="line">    <span class="comment">// 在你调用该force()方法之前，出于性能原因，操作系统可能会将数据缓存在内存中，</span></span><br><span class="line">    <span class="comment">// 因此您不能保证写入通道的数据实际上写入磁盘。</span></span><br><span class="line">    fileChannel.force(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><ul><li>UDP Server</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUDPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOUDPServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立DatagramChannel</span></span><br><span class="line">            DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">            <span class="comment">//设置为非阻塞模式</span></span><br><span class="line">            datagramChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//获取DatagramSocket</span></span><br><span class="line">            DatagramSocket datagramSocket = datagramChannel.socket();</span><br><span class="line">            <span class="comment">//设置接收的buffer最大值</span></span><br><span class="line">            datagramSocket.setReceiveBufferSize(<span class="number">10240</span>);</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            datagramSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//DatagramChannel注册到Selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            datagramChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">"UDPServer 正在监听端口："</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分配数据缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录接收的字节总数</span></span><br><span class="line">            <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//如果选择器数目为0，则结束循环</span></span><br><span class="line">                <span class="keyword">int</span> selectNum = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(selectNum == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//得到选择键列表</span></span><br><span class="line">                Set keys = selector.selectedKeys();</span><br><span class="line">                Iterator iterator = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey k = (SelectionKey) iterator.next();</span><br><span class="line">                    <span class="comment">//通过位运算得到通道是否正常准备</span></span><br><span class="line">                    <span class="keyword">if</span>( (k.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ )&#123;</span><br><span class="line">                        <span class="comment">//获取客户端准备好的channel</span></span><br><span class="line">                        DatagramChannel datagramChannelClient = (DatagramChannel) k.channel();</span><br><span class="line">                        datagramChannelClient.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//先将buffer清除，防止数据混合</span></span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        <span class="comment">//接收数据到buffer,返回代表客户端的SocketAddress对象</span></span><br><span class="line">                        SocketAddress socketAddressClient = datagramChannelClient.receive(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//读取数据</span></span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        <span class="comment">//判空操作</span></span><br><span class="line">                        <span class="keyword">if</span>(byteBuffer.remaining() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"datagramChannelClient channel is null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录接收的字节总数</span></span><br><span class="line">                        number += byteBuffer.remaining();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;byteBuffer.remaining();i++)&#123;</span><br><span class="line">                            bytes[i] = byteBuffer.get(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String in = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br><span class="line">                        System.out.println(number + <span class="string">"::: Server 接收到："</span> + in );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//返回响应</span></span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        byteBuffer.put(<span class="string">"welcome !!!"</span>.getBytes());</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        datagramChannelClient.send(byteBuffer,socketAddressClient);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keys.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOUDPServer(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UDP Client</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUDPClient</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录每个client发送的字节数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOUDPClient</span><span class="params">(String host,<span class="keyword">int</span> port,<span class="keyword">int</span> threadNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadNum;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//构建客户端channel</span></span><br><span class="line">            DatagramChannel datagramChannelClient = DatagramChannel.open();</span><br><span class="line">            SocketAddress serverSocketAddress = <span class="keyword">new</span> InetSocketAddress(host,port);</span><br><span class="line">            datagramChannelClient.connect(serverSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建发送数据包</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.put(<span class="string">"testClient"</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判空操作</span></span><br><span class="line">            <span class="keyword">if</span>(byteBuffer.remaining() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"client data is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送数据</span></span><br><span class="line">            <span class="keyword">int</span> sendNum = datagramChannelClient.send(byteBuffer,serverSocketAddress);</span><br><span class="line">            number += sendNum;</span><br><span class="line">            System.out.println(<span class="string">"客户端发送的字节数："</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接收服务器响应</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            datagramChannelClient.receive(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取服务器响应</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;byteBuffer.remaining();i++)&#123;</span><br><span class="line">                bytes[i] = byteBuffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">            String res = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"client 接收 Server 响应 ： "</span> + res);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOUDPClient(<span class="string">"127.0.0.1"</span>,<span class="number">1024</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServerSocketChannel-和-SocketChannel"><a href="#ServerSocketChannel-和-SocketChannel" class="headerlink" title="ServerSocketChannel 和 SocketChannel"></a>ServerSocketChannel 和 SocketChannel</h3><ul><li>TCP Server</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOTCPServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立 ServerSocketChannel</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//设置成非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//获取ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将ServerSocketChannel注册到Selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">"TCP Server 正在监听端口： "</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//进行事件监听轮询</span></span><br><span class="line">                <span class="keyword">int</span> selectNum = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (selectNum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取选择键的迭代器</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey selectionKey = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断选择键事件类型，进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">//通过选择键获取ServerSocketChannel</span></span><br><span class="line">                        ServerSocketChannel serverSocketChannela = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//通过ServerSocketChannel 获取相应的 SocketChannel，建立连接: 将Client的SocketChannel注册到</span></span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannela.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">                        System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                + socketChannel.socket().getPort() + <span class="string">" 连接上了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//创建接收数据的容器</span></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//从SocketChannel中读取数据到ByteBuffer</span></span><br><span class="line">                            socketChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="comment">//                          客户端异常断开连接</span></span><br><span class="line">                            System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                    + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + socketChannel.socket().getPort() + <span class="string">" 已断开连接"</span>);</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = byteBuffer.array();</span><br><span class="line">                        String msg = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (msg.equals(<span class="string">"退出"</span>)) &#123;</span><br><span class="line"><span class="comment">//                          客户端主动断开连接</span></span><br><span class="line">                            System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                    + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + socketChannel.socket().getPort() + <span class="string">" 已断开连接"</span>);</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(</span><br><span class="line">                                socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                        + socketChannel.socket().getPort() + <span class="string">"："</span> + msg);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line"><span class="comment">//                          System.out.println("可写");</span></span><br><span class="line">                            CharsetEncoder encoder = Charset.forName(<span class="string">"UTF-8"</span>).newEncoder();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                socketChannel.write(encoder.encode(CharBuffer.wrap(<span class="string">"server receive your message "</span>)));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                                System.out.println(<span class="string">"写入io错误"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NIOTCPServer niotcpServer = <span class="keyword">new</span> NIOTCPServer(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TCP  Client</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CharsetDecoder decoder = Charset.forName(<span class="string">"UTF-8"</span>).newDecoder();</span><br><span class="line">    <span class="keyword">private</span> CharsetEncoder encoder = Charset.forName(<span class="string">"UTF-8"</span>).newEncoder();</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SelectionKey clientKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOTCPClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socket = SocketChannel.open();</span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            clientKey = socket.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            InetSocketAddress ip = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">1024</span>);</span><br><span class="line">            socket.connect(ip);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select(<span class="number">1</span>);</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                            channel.finishConnect();</span><br><span class="line">                        &#125;</span><br><span class="line">                        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        System.out.println(<span class="string">"连接服务器端成功！"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"与服务器："</span></span><br><span class="line">                                    + channel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + channel.socket().getPort() + <span class="string">"的连接已断开"</span>);</span><br><span class="line">                            channel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;<span class="comment">//这一句是为了让你看到打印信息</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        String msg = decoder.decode(buffer).toString();</span><br><span class="line">                        System.out.println(</span><br><span class="line">                                channel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                        + channel.socket().getPort() + <span class="string">"："</span> + msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel client = (SocketChannel) clientKey.channel();</span><br><span class="line">            client.write(encoder.encode(CharBuffer.wrap(msg)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发送信息失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NIOTCPClient client = <span class="keyword">new</span> NIOTCPClient();</span><br><span class="line">        client.start();</span><br><span class="line">        BufferedReader sin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String readline;</span><br><span class="line">            <span class="keyword">while</span>((readline = sin.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(readline.equals(<span class="string">"bye"</span>))&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                client.send(readline);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><h2 id="Selector介绍"><a href="#Selector介绍" class="headerlink" title="Selector介绍"></a>Selector介绍</h2><p>Selector一般称为选择器,当然也可以翻译为多路复用器。它是Java NIO核心组件中的一个,用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channel,也就是可以管理多个网络链接。 使用Selector的好处在于:使用更少的线程来就可以来处理通道了,相比使用多个线程,避免了线程上下文切换带来的开销。</p><p>并不是所有的Channel，都是可以被Selector 复用的。比如：FileChannel就不能被选择器复用。</p><p>判断一个Channel 能被Selector 复用，有一个前提：判断他是否继承了一个抽象类SelectableChannel。如果继承了SelectableChannel，则可以被复用，否则不能。</p><p><strong>每个Channel的继承定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ScatteringByteChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">ServerSocketChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NetworkChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">DatagramChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">GatheringByteChannel</span>, <span class="title">MulticastChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">SocketChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span></span></span><br></pre></td></tr></table></figure><p><strong>上述继承关系，跟socket有关的类都继承自AbstractSelectableChannel，而AbstractSelectableChannel又继承自SelectableChannel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectableChannel</span></span></span><br></pre></td></tr></table></figure><p>SelectableChannel类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有socket通道，都继承了SelectableChannel类都是可选择的，包括从管道(Pipe)对象的中获得的通道。而FileChannel类，没有继承SelectableChannel，因此是不是可选通道。</p><p>通道和选择器不是一对一的关系。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</p><p>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p><h2 id="Selector基本使用"><a href="#Selector基本使用" class="headerlink" title="Selector基本使用"></a>Selector基本使用</h2><ol><li>创建Selector</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ol start="2"><li>Channel设置为非阻塞的，注册channel到Selector,并设置感兴趣的监听事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>register() 方法的第二个参数。这是一个“ interest集合 ”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li><p>Connect</p></li><li><p>Accept</p></li><li><p>Read</p></li><li><p>Write</p></li></ul><p>通道触发了一个事件意思是该事件已经就绪。比如：<br>某个Channel成功连接到另一个服务器称为”连接就绪”。一个ServerSocketChannel准备好接收新进入的连接称为”接收就绪”。一个有数据可读的通道可以说是”读就绪”。等待写数据的通道可以说是”写就绪”。<br>这四种事件用SelectionKey的四个常量来表示： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE</p><p>如果你对不止一种事件感兴趣，使用或运算符即可，如下： int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">key.attachment(); <span class="comment">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span></span><br><span class="line">key.channel(); <span class="comment">// 返回该SelectionKey对应的channel。</span></span><br><span class="line">key.selector(); <span class="comment">// 返回该SelectionKey对应的Selector。</span></span><br><span class="line">key.interestOps(); <span class="comment">//返回代表需要Selector监控的IO操作的bit mask</span></span><br><span class="line">key.readyOps(); <span class="comment">// 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span></span><br></pre></td></tr></table></figure><h3 id="key-interestOps-的使用"><a href="#key-interestOps-的使用" class="headerlink" title="key.interestOps()的使用"></a>key.interestOps()的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="key-readyOps-的使用"><a href="#key-readyOps-的使用" class="headerlink" title="key.readyOps()的使用"></a>key.readyOps()的使用</h3><p>ready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建ready集合的方法</span></span><br><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line"><span class="comment">//检查这些操作是否就绪的方法</span></span><br><span class="line"><span class="keyword">boolean</span> key.isAcceptable();<span class="comment">//是否可读，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isWritable()：<span class="comment">//是否可写，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isConnectable()：<span class="comment">//是否可连接，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isAcceptable()：<span class="comment">//是否可接收，是返回 true</span></span><br></pre></td></tr></table></figure><h3 id="SelectionKey附加信息"><a href="#SelectionKey附加信息" class="headerlink" title="SelectionKey附加信息"></a>SelectionKey附加信息</h3><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">key.attach(theObject);</span><br><span class="line">Object attachedObj = key.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="select-方法的使用"><a href="#select-方法的使用" class="headerlink" title="select()方法的使用"></a>select()方法的使用</h3><p><strong>Selector维护的三种类型SelectionKey集合:</strong>  </p><ul><li><p>已注册的键的集合(Registered key set)</p></li><li><p>已选择的键的集合(Selected key set)</p></li><li><p>已取消的键的集合(Cancelled key set)</p></li></ul><p>在刚初始化的Selector对象中，这三个集合都是空的。 通过Selector的select（）方法可以选择已经准备就绪的通道 （这些通道包含你感兴趣的的事件）。比如: 对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。</p><p>下面是Selector几个重载的select()方法：</p><ul><li><p>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</p></li><li><p>int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。</p></li><li><p>int selectNow()：非阻塞，只要有通道就绪就立刻返回。</p></li></ul><p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。</p><p><strong>停止选择的方法：</strong>  </p><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下两种方式可以唤醒在select（）方法中阻塞的线程。</p><ul><li><p>wakeup()方法 ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</p></li><li><p>close()方法 ：通过close（）方法关闭Selector 该方法使得任何一个在选择操作中阻塞的线程都被唤醒(类似wakeup()),同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p></li></ul><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">1024</span>));</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> readyNum = selector.select();</span><br><span class="line">    <span class="keyword">if</span> (readyNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = it.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 接受连接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 通道可读</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 通道可写</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA/Java%20NIO%E4%B9%8BSelector(%E9%80%89%E6%8B%A9%E5%99%A8).md" target="_blank" rel="noopener">https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA/Java%20NIO%E4%B9%8BSelector(%E9%80%89%E6%8B%A9%E5%99%A8).md</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode系列</title>
      <link href="/2019/10/02/LeetCode/"/>
      <url>/2019/10/02/LeetCode/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode1"><a href="#leetcode1" class="headerlink" title="leetcode1"></a>leetcode1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span></span><br><span class="line"><span class="comment">     * You may assume that each input would have exactly one solution, and you may not use the same element twice.</span></span><br><span class="line"><span class="comment">     * Example:</span></span><br><span class="line"><span class="comment">     * Given nums = [2, 7, 11, 15], target = 9,</span></span><br><span class="line"><span class="comment">     * Because nums[0] + nums[1] = 2 + 7 = 9,</span></span><br><span class="line"><span class="comment">     * return [0, 1].</span></span><br><span class="line"><span class="comment">     * ————————————————</span></span><br><span class="line"><span class="comment">     * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定 nums = [2, 7, 11, 15], target = 9</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为 nums[0] + nums[1] = 2 + 7 = 9</span></span><br><span class="line"><span class="comment">     * 所以返回 [0, 1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/two-sum</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *方法1.从第一个数开始，用 target-此数 ，得到数值与接下来的数值进行对比，如果有则返回，如果没有；则继续此操作。</span></span><br><span class="line"><span class="comment">     * 使用此种方法，时间复杂度O(n²) ，空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 方法2.设置一个Map,键设置为数值 值设置为下标。</span></span><br><span class="line"><span class="comment">     * 从第一个数1开始，用 target-数1 ，得到 数值2</span></span><br><span class="line"><span class="comment">     * 查看Map中是否有此键，如果有则返回;如果没有，将数1的值作为键，下标作为值 存入Map.</span></span><br><span class="line"><span class="comment">     * 时间复杂度O(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode2"><a href="#leetcode2" class="headerlink" title="leetcode2"></a>leetcode2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span></span><br><span class="line"><span class="comment">     * 输出：7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="comment">     * 原因：342 + 465 = 807</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/add-two-numbers</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">            ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode current = dummy;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> dig = l1.val + l2.val + carry;</span><br><span class="line">                <span class="keyword">int</span> val = dig%<span class="number">10</span>;</span><br><span class="line">                carry = dig/<span class="number">10</span>;</span><br><span class="line">                ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current.next = newNode;</span><br><span class="line">                current = current.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = (l1.val +carry)%<span class="number">10</span>;</span><br><span class="line">                carry = (l1.val+carry)/<span class="number">10</span>;</span><br><span class="line">                current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current = current.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = (l2.val + carry)%<span class="number">10</span>;</span><br><span class="line">                carry = (l2.val + carry)/<span class="number">10</span>;</span><br><span class="line">                current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current = current.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>) current.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode3"><a href="#leetcode3" class="headerlink" title="leetcode3"></a>leetcode3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "abcabcbb"</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "bbbbb"</span></span><br><span class="line"><span class="comment">     * 输出: 1</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "pwwkew"</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     *      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 map 数据结构存储（k,v）key值为字符，value值字符位置 +1 ，+1 表示从字符位置 后一个才开始不重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>, start = <span class="number">0</span>; end &lt; n; end++) &#123;</span><br><span class="line">            <span class="keyword">char</span> alpha = s.charAt(end);</span><br><span class="line">            <span class="comment">//如果map中包含end位置的字符，则重置start</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(alpha)) &#123;</span><br><span class="line">                start = Math.max(map.get(alpha), start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进行比较更新，得到此时最大子串的长度</span></span><br><span class="line">            ans = Math.max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将 end 位置的字符加入map</span></span><br><span class="line">            map.put(s.charAt(end), end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode7"><a href="#leetcode7" class="headerlink" title="leetcode7"></a>leetcode7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode7</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 123</span></span><br><span class="line"><span class="comment">     * 输出: 321</span></span><br><span class="line"><span class="comment">     *  示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: -123</span></span><br><span class="line"><span class="comment">     * 输出: -321</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 120</span></span><br><span class="line"><span class="comment">     * 输出: 21</span></span><br><span class="line"><span class="comment">     * 注意:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/reverse-integer</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  32位int取值范围[-2^31,2^31-1]</span></span><br><span class="line"><span class="comment">     *将数字逆转可以通过 newNum = res*10 + x%10 关系式解决，正负数都符合此式</span></span><br><span class="line"><span class="comment">     * 不过还需处理数值溢出的情况，如果将得到的新值，按算式返回得到原值，如果与原值不等，则溢出，返回0；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> newNum = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((newNum - x%<span class="number">10</span>)/<span class="number">10</span> != res) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = newNum;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode9"><a href="#leetcode9" class="headerlink" title="leetcode9"></a>leetcode9</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 121</span></span><br><span class="line"><span class="comment">     * 输出: true</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: -121</span></span><br><span class="line"><span class="comment">     * 输出: false</span></span><br><span class="line"><span class="comment">     * 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 10</span></span><br><span class="line"><span class="comment">     * 输出: false</span></span><br><span class="line"><span class="comment">     * 解释: 从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/palindrome-number</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数值为负数，则一定不相等，直接返回false</span></span><br><span class="line"><span class="comment">     * 如果为正数，将此数通过倒序后，与原数比较，返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> src = x;</span><br><span class="line">        <span class="keyword">int</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            newNum = newNum*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src == newNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode14"><a href="#leetcode14" class="headerlink" title="leetcode14"></a>leetcode14</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode14</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果不存在公共前缀，返回空字符串 ""。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: ["flower","flow","flight"]</span></span><br><span class="line"><span class="comment">     * 输出: "fl"</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: ["dog","racecar","car"]</span></span><br><span class="line"><span class="comment">     * 输出: ""</span></span><br><span class="line"><span class="comment">     * 解释: 输入不存在公共前缀。</span></span><br><span class="line"><span class="comment">     * 说明:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所有输入只包含小写字母 a-z 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/longest-common-prefix</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中最长公共前缀，需要两两相比较，先找出之间的最大公共部分，</span></span><br><span class="line"><span class="comment">     * 然后在用此公共部分去跟下一个字符串比较。如此反复。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode58"><a href="#LeetCode58" class="headerlink" title="LeetCode58"></a>LeetCode58</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果不存在最后一个单词，请返回 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：一个单词是指由字母组成，但不包含任何空格的字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: "Hello World"</span></span><br><span class="line"><span class="comment">输出: 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/length-of-last-word</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = s.length()  -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">' '</span>) end--;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = end;</span><br><span class="line">        <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; s.charAt(start)!=<span class="string">' '</span>) start--;</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode160"><a href="#LeetCode160" class="headerlink" title="LeetCode160"></a>LeetCode160</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">相交链表</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set temp = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.contains(headB)) <span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode136"><a href="#LeetCode136" class="headerlink" title="LeetCode136"></a>LeetCode136</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: [2,2,1]</span></span><br><span class="line"><span class="comment">输出: 1</span></span><br><span class="line"><span class="comment">示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: [4,1,2,1,2]</span></span><br><span class="line"><span class="comment">输出: 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/single-number</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : nums) &#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            count = count == <span class="keyword">null</span> ? <span class="number">1</span> : ++count;</span><br><span class="line">            map.put(i, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            Integer count = map.get(i);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// can't find it.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty自定义解码器</title>
      <link href="/2019/09/08/netty01/"/>
      <url>/2019/09/08/netty01/</url>
      
        <content type="html"><![CDATA[<h2 id="netty自定义解码器"><a href="#netty自定义解码器" class="headerlink" title="netty自定义解码器"></a>netty自定义解码器</h2><p>实现自定义开始结束标志符，实现TCP粘包，拆包。</p><p><strong>使用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder(开始标志符,结束标志符);</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDecoder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDecoder</span><span class="params">(<span class="keyword">byte</span> start,<span class="keyword">byte</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MyDecoder.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"进入Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start != end)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = in.readableBytes();</span><br><span class="line">            <span class="keyword">int</span> start_flag = in.indexOf(<span class="number">0</span>,length,start);</span><br><span class="line">            <span class="keyword">int</span> end_flag = in.indexOf(<span class="number">0</span>,length,end);</span><br><span class="line">            logger.info(<span class="string">"start_flag: "</span>+ start_flag + <span class="string">";  end_flag: "</span> + end_flag);</span><br><span class="line">            <span class="keyword">if</span>( (start_flag &gt;= <span class="number">0</span> &amp;&amp; end_flag &gt;= <span class="number">0</span>) &amp;&amp; ((end_flag - start_flag) &gt; <span class="number">0</span>) )&#123;</span><br><span class="line">                out.add(in.copy(start_flag,end_flag - start_flag + <span class="number">1</span>));</span><br><span class="line">                in.skipBytes(in.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = in.readableBytes();</span><br><span class="line">            <span class="keyword">int</span> start_flag = in.indexOf(<span class="number">0</span>,length,start);</span><br><span class="line">            <span class="keyword">if</span>(start_flag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> end_flag = in.indexOf(start_flag+<span class="number">1</span>,length-start_flag,end);</span><br><span class="line">            <span class="keyword">if</span>(end_flag &gt; start_flag)&#123;</span><br><span class="line">                logger.info(<span class="string">"start_flag: "</span>+ start_flag + <span class="string">";  end_flag: "</span> + end_flag);</span><br><span class="line">                out.add(in.copy(start_flag,end_flag - start_flag + <span class="number">1</span>));</span><br><span class="line">                in.skipBytes(in.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装TDengine JDBC工具</title>
      <link href="/2019/09/08/tdengine01/"/>
      <url>/2019/09/08/tdengine01/</url>
      
        <content type="html"><![CDATA[<h4 id="封装的TDengine-JDBC-工具类"><a href="#封装的TDengine-JDBC-工具类" class="headerlink" title="封装的TDengine JDBC 工具类"></a>封装的TDengine JDBC 工具类</h4><p><strong>代码如下：</strong>  </p><p><strong>配置加载：</strong></p><p>配置文件tsdb.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taos.host=x.x.x.x</span><br><span class="line">taos.username=root</span><br><span class="line">taos.password=taosdata</span><br><span class="line">taos.port=0</span><br><span class="line">taos.dbname=iot</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSDBconfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_PROTOCAL = <span class="string">"jdbc:TAOS://"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String dbName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//在static方法中，通过类加载器得到配置文件</span></span><br><span class="line">            InputStream in = TSDBconfig.class.getClassLoader().getResourceAsStream(<span class="string">"tsdb.properties"</span>);</span><br><span class="line">            prop.load(in);     <span class="comment">///加载属性列表</span></span><br><span class="line">            host = prop.getProperty(<span class="string">"taos.host"</span>);</span><br><span class="line">            username  = prop.getProperty(<span class="string">"taos.username"</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">"taos.password"</span>);</span><br><span class="line">            port = Integer.parseInt(prop.getProperty(<span class="string">"taos.port"</span>));</span><br><span class="line">            dbName = prop.getProperty(<span class="string">"taos.dbname"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jdbcUrl = String.format(<span class="string">"%s%s:%d/%s?user=%s&amp;password=%s"</span>, JDBC_PROTOCAL, host, port, dbName,</span><br><span class="line">                username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工具类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.beans.BeanMap;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.ljy.iot.util.TDengineUtil.getFieldNameBySetter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTDengineUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MyTDengineUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSDB_DRIVER = <span class="string">"com.taosdata.jdbc.TSDBDriver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(TSDB_DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Connection connection;</span><br><span class="line">    <span class="comment">//是否开启数据库列名下划线转驼峰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseColumnHumpToLine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTDengineUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTDengineUtil</span><span class="params">(String jdbcUrl, <span class="keyword">boolean</span> databaseColumnHumpToLine)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = DriverManager.getConnection(jdbcUrl);</span><br><span class="line">        <span class="keyword">this</span>.databaseColumnHumpToLine = databaseColumnHumpToLine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getOne</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Method[] setMethods = getSetMethods(clazz);</span><br><span class="line">        ResultSet resultSet = connection.createStatement().executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        resultSet.next();</span><br><span class="line">        <span class="keyword">return</span> resultSetToObject(resultSet,setMethods,clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getList</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Method[] setterMethods = getSetMethods(clazz);</span><br><span class="line">        ResultSet resultSet = connection.createStatement().executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(resultSetToObject(resultSet, setterMethods, clazz));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(String tableName,Object o)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = o.getClass();</span><br><span class="line">        Map&lt;String,Object&gt; map = BeanMap.create(o);</span><br><span class="line">        String sql = createInsertSql(tableName,map);</span><br><span class="line">        <span class="keyword">return</span> connection.createStatement().execute(sql);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createInsertSql</span><span class="params">(String tableName,Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        buffer.append(<span class="string">"INSERT INTO "</span>).append(tableName).append(<span class="string">" ("</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Object&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        StringBuilder keys = <span class="keyword">new</span> StringBuilder(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder value = <span class="keyword">new</span> StringBuilder(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; entry : set)&#123;</span><br><span class="line">            keys.append(humpToLine(entry.getKey())).append(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue().getClass().equals(Date.class))&#123;</span><br><span class="line">                    Date d = (Date)entry.getValue();</span><br><span class="line">                    value.append(d.getTime()).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    value.append(<span class="string">"'"</span>).append(entry.getValue()).append(<span class="string">"'"</span>).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys.deleteCharAt(keys.length()-<span class="number">1</span>);</span><br><span class="line">        value.deleteCharAt(value.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        buffer.append(keys).append(<span class="string">") VALUES( "</span>).append(value).append(<span class="string">")"</span>);</span><br><span class="line">        buffer.append(<span class="string">";"</span>);</span><br><span class="line">        System.out.println( buffer.toString());</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">resultSetToObject</span><span class="params">(ResultSet resultSet, Method[] setterMethods, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = clazz.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"请检查类"</span> + clazz.getCanonicalName() + <span class="string">"是否有无参构造方法"</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : setterMethods)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                String fieldName = getFieldNameBySetter(method);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//因为标准的setter方法只会有一个参数，所以取一个就行了</span></span><br><span class="line">                Class getParamClass = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获得查询的结果</span></span><br><span class="line">                Object resultObject;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//是否启用驼峰转下划线规则获得数据库字段名</span></span><br><span class="line">                <span class="keyword">if</span> (databaseColumnHumpToLine)</span><br><span class="line">                &#123;</span><br><span class="line">                    resultObject = resultSet.getObject(humpToLine(fieldName));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    resultObject = resultSet.getObject(fieldName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果实体类的类型是String类型，那么无论x数据库类型是什么，都调用其toString方法获取值</span></span><br><span class="line">                <span class="keyword">if</span> (getParamClass.equals(String.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    method.invoke(result, resultObject.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (getParamClass.equals(Date.class) &amp;&amp; resultObject.getClass().equals(Long.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    method.invoke(result, <span class="keyword">new</span> Date((Long) resultObject));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        method.invoke(result, resultObject);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (IllegalArgumentException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//对象字段与数据库类型(通过jdbc读取到的)不一致的情况下，将尝试强制转型</span></span><br><span class="line">                        method.invoke(result, getParamClass.cast(resultObject));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ignored)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所有的转型都失败了，则使用默认值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFieldNameBySetMethod</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toLowerCaseFirstOne(method.getName().substring(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首字母转小写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toLowerCaseFirstOne</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toLowerCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] getSetMethods(Class clazz)&#123;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        Method[] setMethods = <span class="keyword">new</span> Method[methods.length/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.getName().startsWith(<span class="string">"set"</span>))&#123;</span><br><span class="line">                setMethods[i] = m;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern humpPattern = Pattern.compile(<span class="string">"[A-Z]"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驼峰转下划线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">humpToLine</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Matcher matcher = humpPattern.matcher(str);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            matcher.appendReplacement(sb, <span class="string">"_"</span> + matcher.group(<span class="number">0</span>).toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ljy.iot.config.TSDBconfig;</span><br><span class="line"><span class="keyword">import</span> com.ljy.iot.entity.TestEntity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSDB_DRIVER = <span class="string">"com.taosdata.jdbc.TSDBDriver"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(TSDB_DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        MyTDengineUtil tDengineUtil = <span class="keyword">new</span> MyTDengineUtil(<span class="string">"jdbc:TAOS://49.235.215.208:0/iot?user=root&amp;password=taosdata"</span>,<span class="keyword">true</span>);</span><br><span class="line">        TestEntity testEntity = <span class="keyword">new</span> TestEntity();</span><br><span class="line">        testEntity.setMyTs(<span class="string">"2019-09-20 10:05:22"</span>);</span><br><span class="line">        testEntity.setMyId(<span class="number">1</span>);</span><br><span class="line">        testEntity.setMyAddress(<span class="string">"test001"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果sql是select查询语句，返回值为true；</span></span><br><span class="line"><span class="comment">         * 否则是false；</span></span><br><span class="line"><span class="comment">         * 如果语句本身错误会抛出异常。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> isSussess = tDengineUtil.insert(<span class="string">"test"</span>,testEntity);</span><br><span class="line">        List&lt;TestEntity&gt; testEntity1 = tDengineUtil.getList(<span class="string">" select * from test where my_ts &gt;= '2019-09-20 10:05:20';"</span>,TestEntity.class);</span><br><span class="line">        System.out.println(testEntity1.get(<span class="number">1</span>).getMyAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDengine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump命令详解</title>
      <link href="/2019/09/07/linux03/"/>
      <url>/2019/09/07/linux03/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2019/09/07/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2019/09/07/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="IP协议学习"><a href="#IP协议学习" class="headerlink" title="IP协议学习"></a>IP协议学习</h2><h3 id="1、-IP协议功能"><a href="#1、-IP协议功能" class="headerlink" title="1、 IP协议功能"></a>1、 IP协议功能</h3><ul><li><p>寻址和路由（根据对方的IP地址，寻找最佳路径传输信息）</p></li><li><p>传递服务  </p><ol><li><p><strong>不可靠：</strong> IP仅提供最好的传输服务，不能保证IP数据报能成功到达目的地。任何要求的可靠性必须由上层来提供（如：tcp）</p></li><li><p><strong>无连接：</strong> IP并不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP数据报可以不按发送顺序接收。</p></li></ol></li><li><p>数据包的分片和重组</p></li></ul><h3 id="2、-IP地址分类"><a href="#2、-IP地址分类" class="headerlink" title="2、 IP地址分类"></a>2、 IP地址分类</h3><p>在Internet（ipv4）中,ip地址是一个32位的二进制地址，为了方便记忆，将它们分为4组，每组8位，由小数点分开，用四个字节来表示，而且每个字节数值范围是 0~255 。</p><table><thead><tr><th align="left">类别</th><th align="left">网段</th><th align="left">区分</th><th align="left">地址范围</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">0~127</td><td align="left">二进制首位为0</td><td align="left">1.0.0.1~127.255.255.254</td></tr><tr><td align="left">B</td><td align="left">128~191</td><td align="left">二进制首位为10</td><td align="left">172.16.0.0~172.31.255.254</td></tr><tr><td align="left">C</td><td align="left">192~223</td><td align="left">二进制首位为110</td><td align="left">192.168.0.1~192.168.255.254</td></tr><tr><td align="left">D</td><td align="left">224~239</td><td align="left">二进制首位为1110</td><td align="left">224.0.0.0~239.255.255.254</td></tr><tr><td align="left">E</td><td align="left">240~255</td><td align="left">二进制首位为1111</td><td align="left">240.0.0.0~255.255.255.255</td></tr></tbody></table><ul><li><p>(1) A类地址，一个A类地址是由一个字节的网络地址和三个字节的主机地址组成，网络地址的最高位必须是“0”</p></li><li><p>(2) B类地址，一个B类地址是由两个字节的网络地址和两个字节的主机地址组成，网络地址的最高位必须是“10”</p></li><li><p>(3) C类地址，一个C类地址是由三个字节的网络地址和一个字节的主机地址组成，网络地址的最高位必须是“110”</p></li><li><p>(4) D类地址，不区分网络地址和主机地址，D类地址是一种组播地址，D类地址的第一个字节以1110开始。目前D类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p></li><li><p>(5) E类地址，不区分网络地址和主机地址，E类地址是保留地址用于以后使用。E类地址的第一个字节以1111开始。</p></li></ul><h4 id="2-1-特殊IP地址"><a href="#2-1-特殊IP地址" class="headerlink" title="2.1 特殊IP地址"></a>2.1 特殊IP地址</h4><ol><li><p><strong>私有地址</strong>  </p><p>A类地址的私有地址是：10.0.0.0~10.255.255.255</p><p>B类地址的私有地址是：172.16.0.0~172.31.255.255.255</p><p>C类地址的私有地址是：192.168.0.0~192.168.255.255</p><p>这些地址不会被Internet分配，他们再Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以和 Internet通讯（NAT技术）。</p><blockquote><p>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术.</p></blockquote></li><li><p><strong>环回地址</strong><br>1、功能：</p><p>（1）本机网络测试。通信设备发出的数据包又返回（环回）到本设备上，用于测试设备能否正常使用以及节点是否有效。</p><p>（2）进程间通信。</p><p>2、IP地址为127.X.X.X，一般使用127.0.0.1。</p><p>3、发送到这个地址的数据包不会出现在网络实体中，而是送给系统的环回接口。</p><p>4、环回地址使得A类地址少了一个网络号。</p></li></ol><blockquote><p>【小技巧】 　　<br>Ping 127.0.0.1,如果反馈信息失败,说明TCP/IP协议栈有错,必须重新安装TCP/IP协议。如果成功,ping本机IP地址,如果反馈信息失败,说明你的网卡不能和IP协议栈进行通信。 　</p></blockquote><blockquote><p>但是直接ping 0.0.0.0是不行的，他在IPV4中表示的是无效的目标地址，但是在服务器端它表示本机上的所有IPV4地址.</p></blockquote><ol start="3"><li><p><strong>广播地址</strong></p><p>TCP/IP规定，主机号全为”1”的网络地址用于广播之用（二进制地址中主机地址全为1，即 10进制的255），叫做广播地址。所谓广播，指同时向同一子网所有主机发送报文。</p></li></ol><h4 id="2-2-子网掩码"><a href="#2-2-子网掩码" class="headerlink" title="2.2 子网掩码"></a>2.2 子网掩码</h4><p>子网掩码(subnet mask)又叫网络掩码，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p><ul><li><p>对于A类地址来说，默认的子网掩码是255.0.0.0；</p></li><li><p>对于B类地址来说默认的子网掩码是255.255.0.0；</p></li><li><p>对于C类地址来说默认的子网掩码是255.255.255.0。</p></li></ul><h3 id="3、IP报文格式"><a href="#3、IP报文格式" class="headerlink" title="3、IP报文格式"></a>3、IP报文格式</h3><p><img src="//qx-ljy.cn/2019/09/07/网络层/ip1.png" alt></p><ul><li><p>版本号：4个bit，用来标识IP版本号。这个4位字段的值设置为二进制的0100表示IPv4，设置为0110表示IPv6。目前使用的IP协议版本号是4。</p></li><li><p>首部长度：4个bit。标识包括选项在内的IP头部字段的长度。由于它是一个 四比特 字段，所以IP首部最长为60个字节，最少为20字节（没有任何选择项，此字段值为5）。</p></li><li><p>服务类型：8个bit。服务类型字段被划分成两个子字段：3bit的优先级字段和4bit TOS字段，最后一位置为0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小花费。4bit中只能将其中一个bit位置1。如果4个bit均为0，则代表一般服务。</p></li><li><p>总长度：16个bit。接收者用IP数据报总长度减去IP报头长度就可以确定数据报中数据内容起始位置和长度。IP数据报最长可达65535字节。</p></li><li><p>标识：16个bit。唯一的标识主机发送的每一份数据报。接收方根据分片中的标识字段是否相同来判断这些分片是否是同一个数据报的分片，从而进行分片的重组。通常每发送一份报文它的值就会加1。</p></li><li><p>标志：3个bit。用于标识数据报是否分片。第1位没有使用，第2位是不分段（DF）位。当DF位被设置为1时，表示路由器不能对数据包进行分段处理。如果数据包由于不能分段而未能被转发，那么路由器将丢弃该数据包并向源发送ICMP不可达。第3位是分段（MF）位。当路由器对数据包进行分段时，除了最后一个分段的MF位被设置为0外，其他的分段的MF位均设置为1，以便接收者直到收到MF位为0的分片为止。</p></li><li><p>片偏移：13个bit。在接收方进行数据报重组时用来标识分片的顺序。用于指明分段起始点相对于报头起始点的偏移量。由于分段到达时可能错序，所以片偏移字段可以使接收者按照正确的顺序重组数据包。当数据包的长度超过它所要去的那个数据链路的MTU时，路由器要将它分片。数据包中的数据将被分成小片，每一片被封装在独立的数据包中。接收端使用标识符，分段偏移以及标记域的MF位来进行重组。</p></li><li><p>生存时间:8个bit。TTL域防止丢失的数据包在无休止的传播。该域包含一个8位整数，此数由产生数据包的主机设定。TTL值设置了数据报可以经过的最多的路由器数。TTL的初始值由源主机设置（通常为32或64），每经过一个处理它的路由器，TTL值减1。如果一台路由器将TTL减至0，它将丢弃该数据包并发送一个ICMP超时消息给数据包的源地址。</p></li><li><p>协议：8个bit。用来标识是哪个协议向IP传送数据。ICMP为1，IGMP为2，TCP为6，UDP为17，GRE为47，ESP为50。</p></li><li><p>首部检验和：根据IP首部计算的校验和码。</p></li><li><p>源地址：IP报文发送端的IP地址</p></li><li><p>目的地址：IP报文接收端的IP地址</p></li><li><p>选项：是数据报中的一个可变长的可选信息。选项字段以32bit为界，不足时插入值为0的填充字节。保证IP首部始终是32bit的整数倍。</p></li></ul><h3 id="4、IP分片偏移"><a href="#4、IP分片偏移" class="headerlink" title="4、IP分片偏移"></a>4、IP分片偏移</h3><h4 id="4-1-分片原因"><a href="#4-1-分片原因" class="headerlink" title="4.1 分片原因"></a>4.1 分片原因</h4><p>以太网的MTU（最大传输单元）是1500字节，如果IP层有数据包要传，而长度超过了MTU，那么IP层就要对数据包进行分片操作。</p><h4 id="4-2-不同传输层协议的分片"><a href="#4-2-不同传输层协议的分片" class="headerlink" title="4.2 不同传输层协议的分片"></a>4.2 不同传输层协议的分片</h4><ol><li>TCP协议</li></ol><p>对于TCP协议来说尽量避免分片，因为当在IP层进行了分片后，如果其中的某片数据丢失，则需对整个数据报进行重传。因为IP层本身没有超时重传机制，当来自TCP报文段的某一片丢失后，TCP在超时后重发整个TCP报文段，该报文段对应于一份IP数据报，没有办法只重传数据报中的一个数据分片。</p><p>TCP协议可以避免分片，避免的机制是首先，TCP在建立连接时会进行3次握手，而在这3次握手中，客户端和服务端通常会协商一个值，那就是MSS（最长报文大小），用来表示本段所能接收的最大长度的报文段。MSS=MTU-TCP首部大小-IP首部大小，MTU值通过查询链路层得知。</p><p>当两端确认好MSS后进行通信，TCP层往IP层传输数据时，如果TCP层缓冲区的大小大于MSS，那么TCP层都会将其中的数据分组进行传输，这样就避免了在IP层进行分片。</p><ol start="3"><li>UDP协议  </li></ol><p>对于UDP而言，由于UDP是不需要保证可靠性的，没有超时和重传机制，这使得UDP很容易导致IP分片。</p><p>UDP协议分片会根据IP报文字段中的标识字段、标志字段、片偏移字段来解决。</p><p>对于每份IP数据报来说，其16位标识字段都包含一个唯一值。在数据报被分片时，这个值同时被复制到每个片中。用来识别分片的数据是否为同一个数据报文。</p><p>在IP首部中，我们看到有一个占了3位的标志字段，其中第1位是R作为保留字段未用；第2位分段是DF用来表示一个数据报是否允许在IP层被分片，DF=0时允许分片，DF=1时不允许分片；而第3位是MF更多分片字段，则是当数据报被分片时，让接收端知道在什么时候完成所有的分片组装，除了最后一片外，其他每个组成数据报的片都要把该比特置1。</p><p>而如果将其中的分段标志比特位置1，表示不允许IP层对数据报进行分片。例如当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特，路由器会丢弃数据报并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”）。</p><p>IP首部的13位片偏移字段表示IP分片再整个数据流中的位置，第一个数据报分片的偏移量置为0，而后续的分片偏移量则是根据网络的MTU大小设置，且必须为8的整数倍。</p><p><img src="//qx-ljy.cn/2019/09/07/网络层/ip2.png" alt></p><p>以上图中我们看到把一个报文长度为3800字节的报文分片为三个。他们每一个分片都会含有一个标识（IP地址 + 标识），到达目的地要对其所有的分片进行重新组装；<br>片偏移计算过程；首部分大体的内容是一样，因为都属于同一个数据报文！</p><h3 id="5、IP报文重组"><a href="#5、IP报文重组" class="headerlink" title="5、IP报文重组"></a>5、IP报文重组</h3><p>IP报文分片后进行重组，只能在目标主机进行重组。</p><p>IP报文分片重组时，采用了一组重组定时器，片重组的控制主要根据数据首部中的标识、标志、偏移字段进行重组。</p><p><strong>分片重组策略如下：</strong></p><p>（1）第一个分片的偏移值时0</p><p>（2）将第一个分片携带的数据长度除以8，结果就是第二个分片的偏移值</p><p>（3）将第一个和第二个分片携带数据的总长度除以8，结果就是第二个分片的偏移值</p><p>（4）继续以上过程。直到之后分片的MF标志位为0</p><h3 id="6、报文校验"><a href="#6、报文校验" class="headerlink" title="6、报文校验"></a>6、报文校验</h3><h4 id="6-1-IP报文校验和计算方式"><a href="#6-1-IP报文校验和计算方式" class="headerlink" title="6.1 IP报文校验和计算方式"></a>6.1 IP报文校验和计算方式</h4><p>（1）为了计算一份数据报的IP检验和，首先需要把检验和字段置为0</p><p>（2）对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16bit的字组成）</p><p>PS：路由器收到IP报文，然后转发之后，是需要对TTL（Time to Live）字段减一，那么这样的话IP报文校验和数值也需要进行相应改变</p><h4 id="6-2-IP报文不对数据校验原因"><a href="#6-2-IP报文不对数据校验原因" class="headerlink" title="6.2 IP报文不对数据校验原因"></a>6.2 IP报文不对数据校验原因</h4><p>上层传输层是端到端的协议，进行端到端的校验比进行点到点的校验开销小。</p><h4 id="6-3-IP报文对IP首部校验原因"><a href="#6-3-IP报文对IP首部校验原因" class="headerlink" title="6.3 IP报文对IP首部校验原因"></a>6.3 IP报文对IP首部校验原因</h4><p>IP首部属于IP层协议的内容，上层协议无法处理。</p><p>IP首部的部分字段在点到点的传递过程中是不断变化的，只能在每个中间点重新形成校验数据，在相邻点完成校验。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="/2019/08/04/java02/"/>
      <url>/2019/08/04/java02/</url>
      
        <content type="html"><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="//qx-ljy.cn/2019/08/04/java02/01.png" alt></p><p>JDK中定义了一套完整的异常处理机制，所有异常都是Throwable的子类，分为Error（致命错误，程序无法处理，只能人工介入）和 Exception（非致命异常）；Exception又分为checked异常（受检异常）和 unchecked异常（非受检异常）。  </p><p>checked异常是需要在程序中显示处理的异常，否则编译出错。<br>unchecked异常是运行时异常（数组越界，空指针异常等），它们都继承自RuntimeException，不需要程序进行显示的捕捉和处理。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>定式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  需要监控的可能会抛出异常的代码块</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">  出现异常后的处理代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  回收资源的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>  </p><p>如果try中的代码块发生异常，它将被抛出，在catch代码块中捕捉异常并用合理的方式来处理该异常。无论是否发生异常，发生什么异常，finally从句中的代码块一定会执行，除非在之前通过 <strong>System.exit(0);</strong> 语句终止程序；此外，<strong>finally是在return表达式执行结束后执行的</strong>。</p><p><strong>下面看这一段代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn_exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnException01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            temp = <span class="number">666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> z = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++x;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> ++y;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ++z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test01()); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"test02() value: "</span> + test02());</span><br><span class="line">        System.out.println(<span class="string">"x: "</span>+ x);</span><br><span class="line">        System.out.println(<span class="string">"y: "</span>+ y);</span><br><span class="line">        System.out.println(<span class="string">"z: "</span>+ z);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * test02() value: 101</span></span><br><span class="line"><span class="comment">         * x: 1</span></span><br><span class="line"><span class="comment">         * y: 10</span></span><br><span class="line"><span class="comment">         * z: 101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>  </p><ol><li><p>test01() ：</p><p>finally是在return表达式执行结束后执行的,即将要return的结果暂时存起来，待finally代码块执行完后再将暂存的返回值返回。</p></li><li><p>test02() :  </p><p>由于最后在finally代码块中执行了return操作，所以return返回值被刷新。</p></li></ol><h2 id="异常处理中代码规范"><a href="#异常处理中代码规范" class="headerlink" title="异常处理中代码规范"></a>异常处理中代码规范</h2><ol><li><p>在finally中 <strong>不建议执行赋值语句（对返回值进行改变等赋值）</strong> ， <strong>拒绝使用return语句</strong>，<strong>应该存放内存回收相关代码</strong>。</p></li><li><p>尽量减少try监控的代码块，尽量对单一过程监控，不要一个try中监控好几个会出现异常的代码块；要try在最贴近异常出现的代码位置。</p></li><li><p>如果try中有一个对象object指向了一块比较大的内存空间，而且之后不会在再使用，那么在finall中建议写上 <strong>object = null;</strong> 这样能提升内存使用效率。</p></li><li><p>try catch 中如果用到了 ArrayList，HashMap等集合对象，而且之后这些对象不会在使用，那么在finally建议调用 <strong>clear()</strong> 方法清空集合。</p></li><li><p>同理 IO读写，连接数据库，如果后序不再需要，则需要在finally中进行回收。  </p></li></ol><h2 id="throw，throws的区别"><a href="#throw，throws的区别" class="headerlink" title="throw，throws的区别"></a>throw，throws的区别</h2><ol><li><p>throws 出现在声明方法的位置，而 throw 出现在函数体内。</p></li><li><p>如果某个函数内部使用throw抛出异常，那么在声明函数时，一定要配套使用 throws ,否则出现错误。</p></li><li><p>在子类方法中不应该抛出比父类范围更广的异常。  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>自定义异常：定义一个派生于Exception的类，或者派生于Exception子类的类；<br>习惯上，定义的类应该包含两个构造器，一个默认的构造器；另一个是带有详细描述信息的构造器。</p><p><strong>代码如下：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn_exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnException03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"test MyException!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * learn_exception.MyException: test MyException!!!</span></span><br><span class="line"><span class="comment">     * at learn_exception.LearnException03.test(LearnException03.java:19)</span></span><br><span class="line"><span class="comment">     * at learn_exception.LearnException03.main(LearnException03.java:23)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux零拷贝技术</title>
      <link href="/2019/08/03/linux02/"/>
      <url>/2019/08/03/linux02/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>零复制（英语：Zero-copy；也译零拷贝）技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p></blockquote><p>零拷贝操作减少了在用户空间与内核空间之间切换模式的次数。</p><p><img src="//qx-ljy.cn/2019/08/03/linux02/01.png" alt></p><p><strong>传统的I/O操作进行了3次用户空间与内核空间的上下文切换，以及4次数据拷贝。其中4次数据拷贝中包括了2次DMA拷贝和2次CPU拷贝。</strong></p><h2 id="Linux-中零拷贝技术的实现方向"><a href="#Linux-中零拷贝技术的实现方向" class="headerlink" title="Linux 中零拷贝技术的实现方向"></a>Linux 中零拷贝技术的实现方向</h2><h3 id="一、直接-I-O"><a href="#一、直接-I-O" class="headerlink" title="一、直接 I/O"></a>一、直接 I/O</h3><p>对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，但是硬件上的数据不会拷贝一份到内核空间，而是直接拷贝至了用户空间，因此直接I/O不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</p><h3 id="二、copy-on-write-写时复制技术"><a href="#二、copy-on-write-写时复制技术" class="headerlink" title="二、copy-on-write(写时复制技术)"></a>二、copy-on-write(写时复制技术)</h3><p>在某些情况下，Linux操作系统的内核空间缓冲区可能被多个应用程序所共享，操作系统有可能会将用户空间缓冲区地址映射到内核空间缓存区中。当应用程序需要对共享的数据进行修改的时候，才需要真正地拷贝数据到应用程序的用户空间缓冲区中，并且对自己用户空间的缓冲区的数据进行修改不会影响到其他共享数据的应用程序。所以，如果应用程序不需要对数据进行任何修改的话，就不会存在数据从系统内核空间缓冲区拷贝到用户空间缓冲区的操作。</p><h3 id="三、数据传输不经过用户进程地址空间"><a href="#三、数据传输不经过用户进程地址空间" class="headerlink" title="三、数据传输不经过用户进程地址空间"></a>三、数据传输不经过用户进程地址空间</h3><p>在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 mmap()，sendfile() 以及 splice()。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/08/03/linux02/mmap.png" alt></p><p><strong>过程：</strong></p><ol><li><p>应用进程调用了 mmap() 之后，数据会先通过 DMA 拷贝到操作系统内核缓冲区中去。接着，应用进程跟操作系统共享这个缓冲区。这样，操作系统内核和应用进程存储空间就不需要再进行任何的数据拷贝操作。</p></li><li><p>应用进程再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态 。</p></li><li><p>socket缓冲区再把数据发到网卡。</p></li></ol><p>使用 mmap 并不一定能获得理想的数据传输性能。数据传输的过程中仍然需要一次 CPU 拷贝操作，而且映射操作也是一个开销很大的虚拟存储操作，这种操作需要通过更改页表以及冲刷 TLB （使得 TLB 的内容无效）来维持存储的一致性。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile()"></a>sendfile()</h4><p>为了简化用户接口，同时减少 CPU 的拷贝次数，Linux 在版本 2.1 中引入了 sendfile() 这个系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/08/03/linux02/sendfile.png" alt></p><p><strong>过程：</strong></p><ol><li><p>sendfile() 系统调用利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中。</p></li><li><p>然后数据被拷贝到与 socket 相关的内核缓冲区中去。</p></li><li><p>接下来，DMA 引擎将数据从内核 socket 缓冲区中拷贝到协议引擎中去。</p></li></ol><p>sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile() 只是适用于应用程序地址空间不需要对所访问数据进行处理的情况。相对于 mmap() 方法来说，因为 sendfile 传输的数据没有越过用户应用程序 / 操作系统内核的边界线，所以 sendfile () 也极大地减少了存储管理的开销。</p><p>现在，已经减少了数据拷贝的次数，但是仍然存在一次CPU拷贝，就是页缓存到socket缓存的拷贝。  </p><p>借助于硬件的帮助，可以把这个拷贝省略掉。即：</p><p><img src="//qx-ljy.cn/2019/08/03/linux02/DMASendfile.png" alt></p><p><strong>sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。</strong></p><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>splice() 可以被看成是类似于基于流的管道的实现，管道可以使得两个文件描述符相互连接，splice 的调用者则可以控制两个设备（或者协议栈）在操作系统内核中的相互连接。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p>splice（）在两个文件描述符之间移动数据，而不在内核地址空间和用户地址空间之间进行复制。它将文件描述符fd_in中的len个字节的数据传输到文件描述符fd_out，其中一个描述符必须引用一个管道。  </p><p>如果fd_in引用一个管道，那么off_in必须为NULL。如果fd_in没有引用管道并且off_in为NULL，则从当前文件偏移量开始从fd_in读取字节，并且适当地调整当前文件偏移量。如果fd_in没有引用管道并且off_in不是NULL，那么off_in必须指向一个缓冲区，该缓冲区指定从fd_in读取字节的起始偏移量; 在这种情况下，fd_in的当前文件偏移量不会改变。类似的语句适用于fd_out和off_out。</p><p>flags参数是一个位掩码，它由零个或多个下列值组成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SPLICE_F_NONBLOCK：   splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O</span><br><span class="line">                     ，那么调用 splice 有可能仍然被阻塞。</span><br><span class="line"></span><br><span class="line">SPLICE_F_MORE：       告知操作系统内核下一个 splice 系统调用将会有更多的数据传来。</span><br><span class="line"></span><br><span class="line">SPLICE_F_MOVE：       如果输出是文件，这个值则会使得操作系统内核尝试从输入管道缓冲区直接将数据读入</span><br><span class="line">                      到输出地址空间，这个数据传输过程没有任何数据拷贝操作发生。如果内核不能从pipe</span><br><span class="line">                      移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据。</span><br></pre></td></tr></table></figure><h4 id="splice-和-sendfile-的区别与联系"><a href="#splice-和-sendfile-的区别与联系" class="headerlink" title="splice() 和 sendfile() 的区别与联系"></a>splice() 和 sendfile() 的区别与联系</h4><p>联系：用户应用进程必须拥有两个已经打开的文件描述符，一个用于表示输入设备，一个用于表示输出设备。  </p><p>区别：<br>    1. splice() 允许任意两个文件之间互相连接<br>    2. sendfile()只适用于文件到 socket 进行数据传输。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络IO模型</title>
      <link href="/2019/08/03/linux01/"/>
      <url>/2019/08/03/linux01/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-IO-模式"><a href="#Linux-IO-模式" class="headerlink" title="Linux IO 模式"></a>Linux IO 模式</h1><p>初学netty,但是由于许多铺垫的基础知识了解的并不多，所以从这里开始我的netty学习之路。</p><h2 id="一、概念说明"><a href="#一、概念说明" class="headerlink" title="一、概念说明"></a>一、概念说明</h2><p><strong>1. 用户空间和系统内核</strong>  </p><p>现代操作系统都是虚拟储存器，对于32位操作系统而言，它的寻址空间（虚拟存储空间）为 4G （2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p><strong>2. 进程的阻塞</strong></p><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><p><strong>3. 文件描述符</strong>  </p><p>内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p><p><strong>4. 缓存I/O</strong>  </p><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 I/O 的缺点：  </p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="二、IO模式"><a href="#二、IO模式" class="headerlink" title="二、IO模式"></a>二、IO模式</h2><p>由于对于一次IO操作，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>即两个阶段：</strong></p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)  </li></ol><p>因为这两个阶段产生了五种网络IO模式：</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p><strong>1.  阻塞 I/O（blocking IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/blockingIO.png" alt>  </p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。(IO执行的两个阶段都被block了)  </p><p><strong>2. 非阻塞 I/O（nonblocking IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/nonblockingIO.png" alt>  </p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在只专门提供某种功能的系统中才有。</p><p><strong>3. I/O 多路复用（ IO multiplexing）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/IOmultiplexing.png" alt></p><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。  </p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。  </p><p>整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><p><strong>4. 信号驱动 I/O（ signal driven IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/signaldrivenIO.png" alt>  </p><p>首先开启套接口的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p><p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间，进程不被阻塞。主循环可以继续执行，只要不时等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。  </p><p><strong>5. 异步 I/O（asynchronous IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/asynchronousIO.png" alt></p><p>异步I/O（asynchronous I/O）由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到我们自己的缓冲区）完成后通知我们。</p><h2 id="各种模型的比较"><a href="#各种模型的比较" class="headerlink" title="各种模型的比较"></a>各种模型的比较</h2><p><img src="//qx-ljy.cn/2019/08/03/linux01/io.png" alt>  </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java String 对象的分析</title>
      <link href="/2019/08/03/Java01/"/>
      <url>/2019/08/03/Java01/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-String-对象的分析"><a href="#Java-String-对象的分析" class="headerlink" title="Java String 对象的分析"></a>Java String 对象的分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)String 常量存放在常量池中，Java虚拟机处于优化的考虑，会让内容一致的对象共享内存块，</span></span><br><span class="line"><span class="comment">     * 但变量是放在堆内存空间中的，new定义的不同变量内存地址不会相同。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2）String 常量 连接 常量，还是 常量，依然用常量池管理，但 变量 连接 常量 就是 变量了。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(a == b );</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">        Integer ia = <span class="number">1</span>;</span><br><span class="line">        Integer ib = <span class="number">1</span>;</span><br><span class="line">        System.out.println(ia == ib);</span><br><span class="line">        System.out.println(ia.equals(ib));</span><br><span class="line"></span><br><span class="line">        String sc = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String sd = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(sc == sd);</span><br><span class="line">        System.out.println(a == sc);</span><br><span class="line">        System.out.println(sc.equals(sd));</span><br><span class="line"></span><br><span class="line">        String c = <span class="string">"a"</span>;</span><br><span class="line">        String d = c + <span class="string">"bc"</span>;</span><br><span class="line">        String e = <span class="string">"a"</span> + <span class="string">"bc"</span>;</span><br><span class="line">        System.out.println(a == d);</span><br><span class="line">        System.out.println(a == e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String 是不可变的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过new操作在内存中开辟一块空间存放“123”，然后让s1指向存放“123”的内存</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新开辟一块内存存放“abc”，s1 指向 “abc” ， 但是原先 “123” 并没有改变，在垃圾回收时会进行回收。</span></span><br><span class="line">        s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder 是直接在对象上操作</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"abc"</span>).append(<span class="string">"123"</span>);</span><br><span class="line">        stringBuilder.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象用法总结：</strong>  </p><ol><li><p>尽可能使用常量 String s = “abc”; ,避免使用变量，如：String a = new String(“123”);</p></li><li><p>尽量避免大规模针对String的操作（如连接字符串）操作，因为这样会频繁产生内存碎片。这种情况下，建议使用StringBuilder（线程不安全） 和 StringBuffer（线程安全）。如果在单线程下，考虑性能，建议使用StringBuilder。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(三)----类加载机制</title>
      <link href="/2019/08/01/jvm3/"/>
      <url>/2019/08/01/jvm3/</url>
      
        <content type="html"><![CDATA[<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="//qx-ljy.cn/2019/08/01/jvm3/01.png" alt></p><ol><li>加载，验证，准备，初始化，卸载 这五个阶段先后顺序是确定的。但是解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（动态绑定或晚期绑定）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态绑定：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），</span><br><span class="line">此时由编译器或其它连接程序实现。  </span><br><span class="line"></span><br><span class="line">所有私有方法、静态方法、构造器及初始化方法&lt;clinit&gt;都是采用静态绑定机制。</span><br><span class="line">在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要</span><br><span class="line">进行一次常量池解析即可。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">动态绑定：动态绑定（后期绑定）是指：在程序运行过程中，根据具体的实例对象</span><br><span class="line">才能具体确定是哪个方法。</span><br><span class="line"></span><br><span class="line">通俗的是指，对象在调用方法的时候能够自己判断该调用谁的方法。所以动态绑定</span><br><span class="line">一般发生在继承、方法重载时。  </span><br><span class="line"></span><br><span class="line">假设，对象o是类C1的实例，其中C1是C2的子类，C2是C3的子类，那么o也是C2，C3</span><br><span class="line">的实例。如果对象o调用一个方法p，JVM会依次在类C1，C2，C3中查找方法p的实现</span><br><span class="line">，直到找到为止。</span><br><span class="line"></span><br><span class="line">类对象方法的调用必须在运行过程中采用动态绑定机制：</span><br><span class="line"></span><br><span class="line">         首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：</span><br><span class="line"></span><br><span class="line">         ① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。</span><br><span class="line"></span><br><span class="line">         ② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将</span><br><span class="line">         参数类型进行自动转型之后再进行匹配。如果匹配到多个自动转型后的</span><br><span class="line">         方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)</span><br><span class="line">         方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。</span><br><span class="line"></span><br><span class="line">         ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。</span><br><span class="line"></span><br><span class="line">         然后，根据在堆中创建对象的实际类型找到对应的方法表，从中确定具体的方法在内存中的位置。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>JVM规范没有强制约束 <strong>加载</strong> 过程何时开始，这部分可以由虚拟机的具体实现自由把握。但是对于初始化阶段，虚拟机规范严格规定了<strong>有且只有</strong> <strong>5种情况</strong> 必须立即对类进行初始化操作（加载 验证 准备自然要在此之前开始）。</p><ol><li><p>遇到new、getstatic、putstatic、invokestatic四条字节码指令时，如果类没有进行初始化，则必须先触发其初始化操作。</p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化操作。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p></li><li><p>虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类</p></li><li><p>当使用JDK1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄时，并且这个句柄对应的类没有进行初始化，虚拟机需要先触发其初始化操作。</p></li></ol></li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>加载阶段虚拟机需要完成以下3件事情：</strong>  </p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口</p></li></ol><p>对于数组类而言，情况就有所不同，数组本身不通过类加载器创建，它是由虚拟机直接创建的。但是数组类和类加载器仍有密切联系，因为数组类的元素类型最终是要靠类加载器去创建的。</p><p><strong>数组类创建规则：</strong>  </p><ol><li><p>如果数组的元素类型是引用类型，那就使用系统提供的或者用户自定义的类加载器去加载。该数组将在 加载数组元素类型 的类加载器 的类命名空间上被标识。（一个类必须与类加载器一起确定唯一性）</p></li><li><p>如果数组的元素类型不是引用类型（如 int[] 数组），虚拟机会把该数组标记为与引导类加载器关联。</p></li><li><p>数组类的可见性和数组元素类型可见性一致，如果元素类型不是引用类型，那么可见性默认为public。  </p></li></ol><p><strong>加载完成后：</strong></p><p>虚拟机将外部二进制字节流按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机自行实现。然后在内存中实例化一个java.lang.Class对象（Class对象比较特殊，它虽然是对象，但是存放在方法区中），这个对象将作为程序访问方法区中类型数据的外部接口。</p><p>加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段进行的动作，仍属于连接阶段的内容。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机得到要求，不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的动作：</strong>  </p><ol><li><p>文件格式验证</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否有不被支持的常量类型<br>。。。。。</li></ul><p>验证点还有很多，这里不一一列举。该验证阶段主要保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个描述Java类型信息的要求。</p><p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区进行存储，后面的验证阶段全部是基于方法区的存储结构进行的，不会再直接操作部字节流。</p></li><li><p>元数据验证</p><p>此阶段是对类的元数据信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</p><p>此阶段部分验证点如下：</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法</p><p>。。。。。</p></li></ul></li><li><p>字节码验证  </p><p>此阶段是验证阶段最复杂的一个阶，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。此阶段对类的方法体进行校验分析，保证校验的类在运行时不会做出危害虚拟机安全的事件。</p></li></ol><p>在JDK1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流分析校验则是唯一选择，不允许退回类型推导的校验方式。</p><ol start="4"><li><p>符号引用验证</p><p>此阶段的验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段—-解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p><p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将抛出java.lang.IncompatibleClassChangeError异常的子类。</p></li></ol><p>对于虚拟机来说，验证阶段是一个非常重要，但不是一定必要的阶段。如果运行的代码经过反复使用和验证，那么在实施阶段可以考虑使用 <strong>-Xverify:none</strong> 参数来关闭大部分的验证措施，缩短类加载时间。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的的内存在方法区中被分配。</p><p>此阶段进行内存分配的仅包括类变量（static修饰），而不包括实例变量，实例变量将会在对象实例化时分配在堆中。此外，这里的初始值是数据类型的零值。但是被 final修饰的类变量 会直接用程序中定义的值进行值初始化。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><ul><li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够使用时能无歧义地定位到目标即可。</p></li><li><p>直接引用：直接引用是可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  初始化阶段是执行类构造器&lt;clinit()&gt;方法的过程</p><ol><li><p>&lt;clinit()&gt;方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}）中的语句结合并产生的。编译器收集顺序是由语句在源代码中出现的顺序决定的，静态语句块中只能访问到定义静态语句块之前的变量。定义在它之后的变量，静态语句块可以赋值，但不能访问。</p></li><li><p>&lt;clinit()&gt;方法和类的构造函数（实例构造器&lt;init()&gt;）不同,它不需要显示地调用父类构造器，虚拟机会保证子类的&lt;clinit()&gt;方法执行之前，父类的&lt;clinit()&gt;方法已经执行完毕。所以虚拟机第一个执行的&lt;clinit()&gt;方法肯定是java.lang.Object。</p></li><li><p>&lt;clinit()&gt;方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit()&gt;方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成&lt;clinit()&gt;方法。但是接口与类不同，执行接口的&lt;clinit()&gt;方法不需要先执行父接口的&lt;clinit()&gt;方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit()&gt;方法。</p></li><li><p>虚拟机会保证一个类的&lt;clinit()&gt;方法在多线程环境中被正确地加锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行类的&lt;clinit()&gt;方法，其他线程需要阻塞等待。</p></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每个类加载器都有一个独立的命名空间。</p><p>比较两个类是否相等：只有这两个类是由同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="//qx-ljy.cn/2019/08/01/jvm3/02.png" alt></p><ol><li><p>启动类加载器（Bootstrap ClassLoader）：这个类负责将存放在<java_home>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法直接被Java程序引用，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</java_home></p></li><li><p>扩展类加载器（Extension ClassLoader）：这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <java_home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</java_home></p></li><li><p>应用程序加载器（Application ClassLoader）：这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ol><p><strong>工作过程：</strong>  </p><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲委派模型的工作过程源码</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            <span class="comment">//父类加载器无法完成类加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order to find the class</span></span><br><span class="line">            <span class="comment">//子加载器进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要链接过程，参数传入</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）当前类加载器从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><p>（2）如果没有找到，就去委托父类加载器去加载（如代码c = parent.loadClass(name, false)所示）。父类加载器也会采用同样的策略，查看自己已经加载过的类中是否包含这个类，有就返回，没有就委托父类的父类去加载，一直到启动类加载器。因为如果父加载器为空了，就代表使用启动类加载器作为父加载器去加载。</p><p>（3）如果启动类加载器加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），则会抛出一个异常ClassNotFoundException，然后再调用当前加载器的findClass()方法进行加载。 </p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p> <strong>自定义类加载器：</strong></p><p> 自定义一个People.java类做例子<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"><span class="comment">//该类写在记事本里，在用javac命令行编译成class文件，放在d盘根目录下</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am a people, my name is "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义一个类加载器，需要继承ClassLoader类，并实现findClass方法。其中defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class（只要二进制字节流的内容符合Class文件规范）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数里使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader mcl = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"People"</span>, <span class="keyword">true</span>, mcl);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getClassLoader());<span class="comment">//打印出我们的自定义类加载器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(四)----docker-compose.yml V3.x 指令详解</title>
      <link href="/2019/07/28/docker04/"/>
      <url>/2019/07/28/docker04/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-compopse-yml-版本和Docker兼容性表"><a href="#docker-compopse-yml-版本和Docker兼容性表" class="headerlink" title="docker-compopse.yml 版本和Docker兼容性表"></a>docker-compopse.yml 版本和Docker兼容性表</h2><p><img src="//qx-ljy.cn/2019/07/28/docker04/001.png" alt>  </p><p><strong>详情请看<a href="https://docs.docker.com/compose/compose-file/#reference-and-guidelines" target="_blank" rel="noopener">官网文档</a></strong>  </p><h2 id="顶级配置项"><a href="#顶级配置项" class="headerlink" title="顶级配置项"></a>顶级配置项</h2><ul><li><p>version 定义了版本信息</p></li><li><p>services 定义了服务的配置信息</p></li><li><p>networks 定义了网络信息，提供给 services 中的 具体容器使用</p></li><li><p>volumes 定义了卷信息，提供给 services 中的 具体容器使用</p></li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  result:</span><br><span class="line">    image: dockersamples/examplevotingapp_result:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5001:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      labels: [APP=VOTING]</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 10s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">  backend:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><h2 id="services配置指令"><a href="#services配置指令" class="headerlink" title="services配置指令"></a>services配置指令</h2><p><strong>1. container_name</strong>  </p><p>指定容器名称</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: redis_test</span><br></pre></td></tr></table></figure><p><strong>2. image</strong>  </p><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br></pre></td></tr></table></figure><p><strong>3. build</strong>  </p><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">也可以使用 context 指令指定 Dockerfile 所在文件夹的路径（或者是git仓库的URL）。同时使用 dockerfile 指令指定 Dockerfile 文件名。</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-name</span><br></pre></td></tr></table></figure><p><strong>注意：<br>如果同时指定了 image和 build， image 不在具有单独使用它的意义，而是指定了目前要构建的镜像的名称。 也就是说 Compose 会使用 build 指令中指定的 Dockerfile  构建的镜像，之后构建的镜像名称使用 image 中指定的名字 webapp:tag命名。</strong></p><p><strong>4. command</strong>  </p><p>使用 command 可以覆盖容器启动后默认执行的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写成shell形式</span></span><br><span class="line"><span class="built_in">command</span>: bundle <span class="built_in">exec</span> thin -p 3000</span><br><span class="line"><span class="comment">#写成Dockerfile中的exec格式</span></span><br><span class="line"><span class="built_in">command</span>: [bundle, <span class="built_in">exec</span>, thin, -p, 3000]</span><br></pre></td></tr></table></figure><p><strong>5. depends_on</strong>   </p><p>解决容器的依赖、启动先后的问题。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: redis_test</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br></pre></td></tr></table></figure><p><strong>6. environment</strong>  </p><p>设置环境变量。可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上的对应变量的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: <span class="string">'true'</span></span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=<span class="literal">true</span></span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**7. expose**  </span><br><span class="line"></span><br><span class="line">暴露端口，但不映射到宿主机，只被连接的服务访问。</span><br><span class="line"></span><br><span class="line">仅可以指定容器内部的端口为参数</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><p><strong>8. ports</strong></p><p>映射端口信息。</p><p>宿主端口：容器端口 (即：HOST:CONTAINER) 的格式格式，或者仅仅指定容器的端口（宿主将会随机选择端口）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"3000-3005"</span></span><br><span class="line"> - <span class="string">"8000:8000"</span></span><br><span class="line"> - <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"> - <span class="string">"49100:22"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"> - <span class="string">"6060:6060/udp"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p></blockquote><p><strong>9. extra_hosts</strong>  </p><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。会在启动后的服务容器中 /etc/hosts 文件中添加host映射信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - <span class="string">"somehost:162.242.195.82"</span></span><br><span class="line"> - <span class="string">"otherhost:50.31.209.229"</span></span><br></pre></td></tr></table></figure><p><strong>10. networks</strong>  </p><p>要加入的网络，使用顶级 networks 定义下的条目 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure><p><strong>11. entrypoint</strong>  </p><p>指定服务容器启动后执行的入口文件。</p><p><strong>12. user</strong>  </p><p>指定容器中运行应用的用户名。</p><p><strong>13. working_dir</strong>  </p><p>指定容器中工作目录。</p><p><strong>14. restart</strong></p><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境 中推荐配置为 always 或者 unless-stopped 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure><p><strong>15. alias</strong>  </p><p>网络上此服务的别名（备用主机名）。同一网络上的其他容器可以使用服务名称或此别名连接到其中一个服务的容器。<br>由于aliases是网络范围的，因此相同的服务可以在不同的网络上具有不同的别名。<br>注意：网络范围的别名可以由多个容器共享，甚至可以由多个服务共享。如果是，则无法保证名称解析为的容器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">         - alias3</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br></pre></td></tr></table></figure><h2 id="volumes配置指令"><a href="#volumes配置指令" class="headerlink" title="volumes配置指令"></a>volumes配置指令</h2><p>数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure><h2 id="volumes配置指令-1"><a href="#volumes配置指令-1" class="headerlink" title="volumes配置指令"></a>volumes配置指令</h2><p><strong>1. 未显式声明网络环境的docker-compose.yml</strong>  </p><p><strong>使用docker-compose up启动容器后，这些容器都会被加入app_default网络中。使用docker network ls可以查看网络列表，docker network inspect <container id>可以查看对应网络的配置。</container></strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    mage: nginx:latest</span><br><span class="line">    container_name: web</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"9090:80"</span></span><br><span class="line">    links:</span><br><span class="line">      - db</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: db</span><br></pre></td></tr></table></figure><p><strong>2. networks关键字指定自定义网络</strong>  </p><p>例如下面的docker-compose.yml文件，定义了front和back网络，实现了网络隔离。其中proxy和db之间只能通过app来实现通信。其中，custom-driver-1并不能直接使用，你应该替换为host, bridge, overlay等选项中的一种。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - back</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front:</span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  back:</span><br><span class="line">    <span class="comment"># Use a custom driver which takes special options</span></span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: <span class="string">"1"</span></span><br><span class="line">      bar: <span class="string">"2"</span></span><br></pre></td></tr></table></figure><p><strong>3. 配置默认网络</strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8000:8000"</span></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    driver: custom-driver-1</span><br></pre></td></tr></table></figure><p><strong>4. 使用已存在的网络</strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: my-pre-existing-network</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(三)----Docker 网络详解</title>
      <link href="/2019/07/26/docker03/"/>
      <url>/2019/07/26/docker03/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-网络详解"><a href="#Docker-网络详解" class="headerlink" title="Docker 网络详解"></a>Docker 网络详解</h2><ul><li><p>Bridge contauner   桥接式网络模式</p></li><li><p>Host(open) container   开放式网络模式</p></li><li><p>Container(join) container   联合挂载式网络模式，是host网络模式的延伸</p></li><li><p>None(Close) container   封闭式网络模式</p></li></ul><h2 id="Bridge-桥接式网络模式"><a href="#Bridge-桥接式网络模式" class="headerlink" title="Bridge(桥接式网络模式)"></a>Bridge(桥接式网络模式)</h2><p><strong>1. 介绍</strong>  </p><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机启动的Docker容器会连接到这个虚拟网桥上，默认分配网段为172.17.0.0/16，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机，附加在其上的任何网卡之间都能自动转发数据包。  </p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机创建一对虚拟网卡<a href="https:/www.cnblogs.com/bakari/p/10613710.html" target="_blank" rel="noopener">veth pair 设备</a>,Docker将veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主句中，以vethxxx这样的名字命名，并将这个网络设备加入到docker0网桥中。  </p><p>veth 是 Virtual ETHernet 的缩写，是一种虚拟网络设备。它的特点是：当它被创建以后，总是以两张虚拟网卡（Veth peer）形式成对出现，并且在一个网卡上的数据包可直接转发给另一个与之对应的网卡上，即使这两个网卡不在同一个namespace中。</p><p><strong>2. 容器与容器间的通信</strong>  </p><p>容器1（172.17.0.2）ping 容器2（172.17.0.3）；<br>根据路由规则，数据包从容器1（172.17.0.2）的eth0转发至与之对应的veth上，该veth桥接在了docker0上，此时数据包到达了docker0,docker0扮演交换机的角色，并广播ARP请求寻找容器2（172.17.0.3）的mac地址，而此时容器2的另一个veth 设备桥接在了docker0，并收到ARP请求，发现自己是172.17.0.3 ，故将其mac地址回复给容器1，此时容器1和容器2就可以进行通信了，并且在容器1可以查看到缓存的容器2的mac地址。</p><p><strong>3. 容器与外部网络通讯</strong></p><p>同理，如果容器ping另一个主机，它发出去的数据包经过docker0网桥流向宿主机的eth0网卡，eth0再将数据包转发给与之相通的主机，于是，容器便可以跟其它主机通信了。（主要宿主机eth0能到达，容器都可以与之通信）  </p><p><strong>4. 宿主机与容器通讯</strong></p><p>当宿主机访问容器时，数据包从docker0流入到与容器的eth0对应的veth设备，veth与容器的eth0相通信。  </p><p><strong>5. 外部访问容器</strong>  </p><p>默认情况，其他外部网络（宿主机以外）无法访问到容器内的端口，通常的做法是使用-p或者-P选项，来暴露容器中的端口到宿主机上，外部网络通过访问宿主机的端口从而访问到容器端口。本质上来说，该方式是通过iptables规则转发实现的。  </p><p><strong>6. 自定义网桥</strong>  </p><p>除了使用默认docker0作网桥以为还可以使用docker network 相关命令自定义网桥，以下将创建一个br1的网络，子网是172.30.0.0/16，网关为172.30.0.1。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建br1网桥</span></span><br><span class="line">docker network create -d bridge --subnet <span class="string">'172.30.0.0/16'</span> --gateway <span class="string">'172.30.0.1'</span> br1</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看docker网络</span></span><br><span class="line"> docker network ls</span><br><span class="line"></span><br><span class="line"> NETWORK ID          NAME                    DRIVER              SCOPE</span><br><span class="line"> b9c01f82c16b        br1                     bridge              <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#自定义网桥的使用</span></span><br><span class="line"> docker run -it --network br1 镜像名称 bash</span><br></pre></td></tr></table></figure><h2 id="Host（开放式网络模式）"><a href="#Host（开放式网络模式）" class="headerlink" title="Host（开放式网络模式）"></a>Host（开放式网络模式）</h2><p>Host模式使用是在容器启动时候指明–network host，此时容器共享宿主机的Network Namespace，容器内启动的端口直接是宿主机的端口，并且容器不会创建网卡和IP，直接使用宿主机的网卡和IP，但是容器内的其他资源是隔离的，如文件系统、用户和用户组。这种模式的好处就是效率高，因为不需要额外的网络开始，直接使用宿主机网络。</p><pre><code class="sh">docker run -d --name nginx --network host nginx:latest</code></pre><p><img src="//qx-ljy.cn/2019/07/26/docker03/nginx.png" alt></p><h2 id="Container-联合挂载式网络模式"><a href="#Container-联合挂载式网络模式" class="headerlink" title="Container(联合挂载式网络模式)"></a>Container(联合挂载式网络模式)</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo回环 通信。同样，kubernetes中的pod的话，pod内的网络也是靠这样的共享方式来实现的。</p><h2 id="None（封闭式网络模式）"><a href="#None（封闭式网络模式）" class="headerlink" title="None（封闭式网络模式）"></a>None（封闭式网络模式）</h2><p>使用–network none选项指定其网络模式，在该模式下虽然容器有着自己的Network Namespace，但是容器内没有网卡、IP、路由信息，只有一个lo回环接口。如果需要网络配置则需要用户手动进行配置网卡、ip以及路由信息，通常这样的容器用于承担某些无需网络介入的工作，如离线任务、备份等。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据类型</title>
      <link href="/2019/07/24/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/24/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a>串数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">1~255个字符的定长串。它的长度必须在创建时指定，否则Mysql假定为CHAR(1)</td></tr><tr><td align="left">ENUM</td><td align="left">接受最多64K个串组成的有个预定义集合的某个串</td></tr><tr><td align="left">LONGTEXT</td><td align="left">与TEXT相同，但最大长度为4GB</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">与TEXT相同，但最大长度为16K</td></tr><tr><td align="left">SET</td><td align="left">接受最多64个串组成的一个预定义集合的零个或多个串</td></tr><tr><td align="left">TEXT</td><td align="left">最大长度为64K的变长文本</td></tr><tr><td align="left">TINYTEXT</td><td align="left">与TEXT相同，但最大长度为256字节</td></tr><tr><td align="left">VARCHAR</td><td align="left">长度可变，最多不超过255个字节。如果在创建时指定为VARCHAR(n),则可存储0-n个字符的变长串（其中 n &lt;= 255 ）</td></tr></tbody></table><p><strong>注意：<br>无论使用何种串数据类型，串值都必须在引号内（通常单引号更好）。</strong></p><h2 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">BIT</td><td align="left">位字段，1～64位。（在MySQL 5之前，BIT在功能上等价于TINYINT</td></tr><tr><td align="left">BIGINT</td><td align="left">整数值，支持-9223372036854775808～9223372036854775807（如果是UNSIGNED，为0～18446744073709551615）的数</td></tr><tr><td align="left">BOOLEAN（或BOOL）</td><td align="left">布尔标志，或者为0或者为1，主要用于开/关（on/off）标志</td></tr><tr><td align="left">DECIMAL（或DEC）</td><td align="left">精度可变的浮点值</td></tr><tr><td align="left">DOUBLE</td><td align="left">双精度浮点值</td></tr><tr><td align="left">FLOAT</td><td align="left">单精度浮点值</td></tr><tr><td align="left">INT（或INTEGER）</td><td align="left">整数值，支持 -2147483648～2147483647（如果是UNSIGNED为0～4294967295）的数</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">整数值，支持 -8388608～8388607（如果是UNSIGNED，为0～16777215）的数</td></tr><tr><td align="left">REAL</td><td align="left">4字节的浮点值</td></tr><tr><td align="left">SMALLINT</td><td align="left">整数值，支持 -32768～32767（如果是UNSIGNED，为0～65535）的数</td></tr><tr><td align="left">TINYINT</td><td align="left">整数值，支持 -128～127（如果为UNSIGNED，为0～255）的数</td></tr></tbody></table><h2 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">表示1000-01-01～9999-12-31的日期，格式为YYYY-MM-DD</td></tr><tr><td align="left">DATETIME</td><td align="left">DATE和TIME的组合</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">功能和DATETIME相同（但范围较小）</td></tr><tr><td align="left">TIME</td><td align="left">格式为HH:MM:SS</td></tr><tr><td align="left">YEAR</td><td align="left">用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年</td></tr></tbody></table><h2 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">BLOB</td><td align="left">Blob最大长度为64 KB</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">Blob最大长度为16 MB</td></tr><tr><td align="left">LONGBLOB</td><td align="left">Blob最大长度为4 GB</td></tr><tr><td align="left">TINYBLOB</td><td align="left">Blob最大长度为255字节</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习(一)----k8s集群部署</title>
      <link href="/2019/07/24/k8s001/"/>
      <url>/2019/07/24/k8s001/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><table><thead><tr><th align="left">角色</th><th align="left">ip</th></tr></thead><tbody><tr><td align="left">master1</td><td align="left">10.10.44.123</td></tr><tr><td align="left">node1</td><td align="left">10.10.44.124</td></tr><tr><td align="left">node2</td><td align="left">10.10.44.125</td></tr><tr><td align="left">node3</td><td align="left">10.10.44.127</td></tr></tbody></table><p>Docker: 18.06.0-ce<br>Kubernetes: v1.15.1</p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>1.关闭交换空间：</p><ul><li>sudo swapoff -a  </li></ul><p>2.避免开机启动交换空间：</p><ul><li>注释 /etc/fstab 中的 swap  </li></ul><p>3.关闭防火墙：  </p><ul><li>systemctl stop firewalld.service            #停止firewall  </li><li>systemctl disable firewalld.service        #禁止firewall开机启动  </li></ul><p>4.安装Docker(这里不再详述，镜像下载速度慢可设置镜像加速器)  </p><p>5.设置hostname  </p><ul><li>hostnamectl set-hostname [hostname]  </li></ul><p>6.创建操作目录</p><ul><li>mkdir -p /opt/kubernetes  </li></ul><h2 id="安装kubeadm，kubelet，kubectl"><a href="#安装kubeadm，kubelet，kubectl" class="headerlink" title="安装kubeadm，kubelet，kubectl"></a>安装kubeadm，kubelet，kubectl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">kubelet --version</span><br><span class="line"><span class="comment">#Kubernetes v1.15.1</span></span><br></pre></td></tr></table></figure><h2 id="配置Kubeadm"><a href="#配置Kubeadm" class="headerlink" title="配置Kubeadm"></a>配置Kubeadm</h2><ol><li>创建并修改配置文件  </li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出配置文件</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  <span class="comment">#修改为主节点 IP</span></span><br><span class="line">  advertiseAddress: 10.10.44.123</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: k8s-master1</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line"><span class="comment"># 国内不能访问，修改为阿里云地址</span></span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line"><span class="comment"># 修改版本号</span></span><br><span class="line">kubernetesVersion: v1.15.1</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line"> <span class="comment"># 配置成 Calico 的默认网段</span></span><br><span class="line">  podSubnet: <span class="string">"192.168.0.0/16"</span></span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line"><span class="comment">#开启IPVS模式</span></span><br><span class="line"><span class="comment">#IPVS (IP Virtual Server，IP虚拟服务器)是基于Netfilter的、作为linux内核的一部分实现传输层负载均衡的技术，通常称为第4层LAN交换。</span></span><br><span class="line"><span class="comment">#kube-proxy是为service构建路由规则的模块，之前依赖iptables来实现主要service类型的支持，比如(ClusterIP和NodePort)。</span></span><br><span class="line"><span class="comment">#但是iptables很难支持上万级的service，因为iptables纯粹是为防火墙而设计的，并且底层数据结构是内核规则的列表。</span></span><br><span class="line"><span class="comment">#基于IPVS的集群内负载均衡就可以完美的解决这个问题。IPVS是专门为负载均衡设计的，并且底层使用哈希表这种非常高效的数据结构，几乎可以允许无限扩容。</span></span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">featureGates:</span><br><span class="line">  SupportIPVSProxyMode: <span class="literal">true</span></span><br><span class="line">mode: ipvs</span><br></pre></td></tr></table></figure><ol start="2"><li>查看拉去镜像</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所需镜像列表</span></span><br><span class="line">kubeadm config images list --config kubeadm.yml</span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yml</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/07/24/k8s001/k8s01.png" alt>  </p><h2 id="安装-kubernetes-主节点"><a href="#安装-kubernetes-主节点" class="headerlink" title="安装 kubernetes 主节点"></a>安装 kubernetes 主节点</h2><p>执行以下命令初始化主节点，该命令指定了初始化时需要使用的配置文件，其中添加 –experimental-upload-certs 参数可以在后续执行加入节点时自动分发证书文件。追加的 tee kubeadm-init.log 用以输出日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=kubeadm.yml --experimental-upload-certs | tee kubeadm-init.log</span><br><span class="line"></span><br><span class="line">Flag --experimental-upload-certs has been deprecated, use --upload-certs instead</span><br><span class="line">[init] Using Kubernetes version: v1.15.1</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING Hostname]: hostname <span class="string">"k8s-master3"</span> could not be reached</span><br><span class="line">[WARNING Hostname]: hostname <span class="string">"k8s-master3"</span>: lookup k8s-master3 on 202.198.176.1:53: server misbehaving</span><br><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action <span class="keyword">in</span> beforehand using <span class="string">'kubeadm config images pull'</span></span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">"/var/lib/kubelet/kubeadm-flags.env"</span></span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">"/var/lib/kubelet/config.yaml"</span></span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder <span class="string">"/etc/kubernetes/pki"</span></span><br><span class="line">[certs] Generating <span class="string">"ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver-kubelet-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver"</span> certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.10.44.123]</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver-etcd-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/peer"</span> certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 localhost] and IPs [10.10.44.123 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"etcd/healthcheck-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/server"</span> certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 localhost] and IPs [10.10.44.123 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"sa"</span> key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder <span class="string">"/etc/kubernetes"</span></span><br><span class="line">[kubeconfig] Writing <span class="string">"admin.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"kubelet.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"controller-manager.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"scheduler.conf"</span> kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-apiserver"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-controller-manager"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-scheduler"</span></span><br><span class="line">[etcd] Creating static Pod manifest <span class="keyword">for</span> <span class="built_in">local</span> etcd <span class="keyword">in</span> <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[<span class="built_in">wait</span>-control-plane] Waiting <span class="keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="string">"/etc/kubernetes/manifests"</span>. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 35.504680 seconds</span><br><span class="line">[upload-config] Storing the configuration used <span class="keyword">in</span> ConfigMap <span class="string">"kubeadm-config"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap <span class="string">"kubelet-config-1.15"</span> <span class="keyword">in</span> namespace kube-system with the configuration <span class="keyword">for</span> the kubelets <span class="keyword">in</span> the cluster</span><br><span class="line">[upload-certs] Storing the certificates <span class="keyword">in</span> Secret <span class="string">"kubeadm-certs"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">[upload-certs] Using certificate key:</span><br><span class="line">7c96a0027e3c3ef4da2869ea68094f98f593f16b42526f706ef0450dab94f723</span><br><span class="line">[mark-control-plane] Marking the node k8s-master3 as control-plane by adding the label <span class="string">"node-role.kubernetes.io/master=''"</span></span><br><span class="line">[mark-control-plane] Marking the node k8s-master3 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: abcdef.0123456789abcdef</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="keyword">in</span> order <span class="keyword">for</span> nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation <span class="keyword">for</span> all node client certificates <span class="keyword">in</span> the cluster</span><br><span class="line">[bootstrap-token] Creating the <span class="string">"cluster-info"</span> ConfigMap <span class="keyword">in</span> the <span class="string">"kube-public"</span> namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.10.44.123:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:39ddf7bea129f622b444d3257a9e93b5868240683e62596f6ad22c030cd9f8ee</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用 kubeadm 配置 slave 节点  </span></span><br><span class="line"></span><br><span class="line">将 slave 节点加入到集群中很简单，只需要在 slave 服务器上安装 kubeadm，kubectl，kubelet 三个工具，然后使用 kubeadm join 命令加入即可.</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"><span class="comment">#上一节中日志最后部分已经给出加入集群的命令</span></span><br><span class="line">kubeadm join 10.10.44.123:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:39ddf7bea129f622b444d3257a9e93b5868240683e62596f6ad22c030cd9f8ee</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME          STATUS     ROLES    AGE     VERSION</span><br><span class="line">k8s-master3   NotReady   master   9m9s    v1.15.1</span><br><span class="line">k8s-node1     NotReady   &lt;none&gt;   6m22s   v1.15.1</span><br><span class="line">k8s-node2     NotReady   &lt;none&gt;   5m11s   v1.15.1</span><br><span class="line">k8s-node3     NotReady   &lt;none&gt;   5m19s   v1.15.1</span><br></pre></td></tr></table></figure><h2 id="安装网络"><a href="#安装网络" class="headerlink" title="安装网络"></a>安装网络</h2><p>这里选择 calico 作为网络插件  </p><blockquote><p>什么是calico ?<br>Calico 为容器和虚拟机提供了安全的网络连接解决方案，并经过了大规模生产验证（在公有云和跨数千个集群节点中），可与 Kubernetes，OpenShift，Docker，Mesos，DC / OS 和 OpenStack 集成。<br>Calico 还提供网络安全规则的动态实施。使用 Calico 的简单策略语言，您可以实现对容器，虚拟机工作负载和裸机主机端点之间通信的细粒度控制。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 在 Master 节点操作即可</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.7/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line">日志如下：</span><br><span class="line">configmap/calico-config created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">daemonset.extensions/calico-node created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">deployment.extensions/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br></pre></td></tr></table></figure><p><strong>确认安装是否成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch kubectl get pods --all-namespaces</span><br><span class="line"></span><br><span class="line"># 需要等待所有状态为 Running，注意时间可能较久，3 - 5 分钟的样子</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(二)----Docker基础命令</title>
      <link href="/2019/07/23/docker02/"/>
      <url>/2019/07/23/docker02/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>- 镜像</strong>  </p><p>  Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文 件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含任何动态数据，其内容在构建之后也不会被改变。  </p><p>  镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后 一层上的任何改变只发生在自己这一层。  </p><p><strong>- 容器</strong>  </p><p>  镜像（ Image ）和容器（ Container ）的关系，就像 类 和 实例 的关系一样。容器的实质是进程，但与宿主机执行的进程不一样。容器进程运行于属于自己的独立的命名空间（容器可以拥有自己的 root 文件系统，网络配置，进程空间，甚至自己的用户ID空间）。</p><p>  每一个容器运行时，是以镜像为基础层， 在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存 于容器存储层的信息都会随容器删除而丢失。  </p><p>  <strong>注意：</strong> 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有文件的写入操作，都应该使用 数据卷（VOLUME），或者绑定宿主机目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。  </p><p>  数据卷的生存周期独立于容器，容器消亡，数据卷不会。使用数据卷后，容器删除或者重新运行，数据不会丢失。  </p><p><strong>- 仓库</strong>  </p><p>  一个集中地存储、分发镜像的服务，叫做docker仓库(Docker Registry)<br>  仓库可以是私有的，也可以是公开的。</p><h2 id="二、Docker环境信息相关命令"><a href="#二、Docker环境信息相关命令" class="headerlink" title="二、Docker环境信息相关命令"></a>二、Docker环境信息相关命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录docker hub</span></span><br><span class="line">docker login</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行后从指定服务器登出，默认为官方服务器。</span></span><br><span class="line"> docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看docker详细信息</span></span><br><span class="line">docker info</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"><span class="comment">#查看docker 版本信息</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="三、Docker镜像相关命令"><a href="#三、Docker镜像相关命令" class="headerlink" title="三、Docker镜像相关命令"></a>三、Docker镜像相关命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在镜像仓库中搜索</span></span><br><span class="line">docker search [OPTIONS] ImageName  </span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">--automated :只列出 automated build类型的镜像；</span><br><span class="line"></span><br><span class="line">--no-trunc :显示完整的镜像描述；</span><br><span class="line"></span><br><span class="line">-s :列出收藏数不小于指定值的镜像。</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#镜像拉取</span></span><br><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line"></span><br><span class="line">-a :拉取所有 tagged 镜像</span><br><span class="line"></span><br><span class="line">--<span class="built_in">disable</span>-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出镜像列表</span></span><br><span class="line">docker images ls</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看镜像、容器、数据卷所占用的空间</span></span><br><span class="line">docker system df</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">```sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本操作</title>
      <link href="/2019/07/20/git/"/>
      <url>/2019/07/20/git/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 仓库操作</strong></p><ul><li>git init   (创建一个Git仓库)</li><li>git clone [url]  （拷贝一个git仓库到本地）</li></ul><blockquote><p>工作流 ：<br>本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index）,它像个缓存区域，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。  </p></blockquote><p><strong>2. 将文件添加到缓存区</strong></p><ul><li><p>git add [filename]  </p></li><li><p>git add .  </p><p>不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</p></li><li><p>git add -u .  </p><p>-u  == –update ，表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</p></li><li><p>git add -A .  </p><p>-A == –all  ， 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。  </p></li></ul><p><strong>3. 将改动提交到 HEAD，但是不到远端仓库</strong>  </p><ul><li>git commit -m “代码提交信息”</li></ul><p><strong>4. 推送改动</strong></p><ul><li><p>git push origin master  </p><p>git commit 之后，你的改动已经在本地仓库的HEAD中了，执行此上命令，可提交至远端仓库，master 可换成你想推送的任何分支。</p></li><li><p>git remote add origin [url]  </p><p>使用此命令可将你的仓库连接到某个远程服务器，此后你就可以将改动推送到添加的服务器中了。</p></li></ul><p><strong>5. 分支</strong></p><ul><li><p>git checkout -b [分支名称]  </p><p>新建分支并切换到该分支</p></li><li><p>git checkout master<br>切换到指定分支  </p></li><li><p>git branch -d [分支命称]<br>将新建分支删掉  </p></li></ul><p><strong>6. 更新与合并</strong>  </p><ul><li><p>git pull<br>按照git branch 设置的默认跟踪的服务器和分支来拉取  </p></li><li><p>git pull origin master<br>拉取远程服务器origin 的master分支  </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(二)----JVM内存结构</title>
      <link href="/2019/07/14/jvm2/"/>
      <url>/2019/07/14/jvm2/</url>
      
        <content type="html"><![CDATA[<p><strong>经典JVM内存布局（JDK8以上）</strong>  </p><p><img src="//qx-ljy.cn/2019/07/14/jvm2/jvm2.png" alt></p><h2 id="一、Heap（堆区）"><a href="#一、Heap（堆区）" class="headerlink" title="一、Heap（堆区）"></a>一、Heap（堆区）</h2><p><strong>Heap存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各个子线程共享使用。</strong> 通常情况下，它占用的空间是所有内存区域中最大的，同时也是OOM（Out Of Memory）故障最主要的发源地。  </p><p>堆的内存空间既可以固定大小，也可以在运行时动态地调整。  </p><p>通过如下参数设置初始值和最大值，比如-Xms256M -Xmx1024M （-X表示它是JVM运行参数，ms是memory start（最小堆容量）的简称，mx是memory max（最大堆容量）的简称）。由于服务器在不断运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以在线上生产环境中，JVM的Xms Xmx 设置成一样大小，避免在GC调整堆大小时带来的额外压力。</p><p><strong>堆分为两大块：新生代和老年代。</strong> 对象产生之初在新生代，步入暮年进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。  </p><p><strong>新生代 = 1个Eden区 + 2个Survivor区。</strong> 绝大部分对象在Eden区生成，当Eden区填满的时候，后触发Young Garbage Collection（YGC）。垃圾回收的时候在Eden区实现清除策略，没有被引用的对象则直接回收。仍然存活的对象会被移送到Survivor区。Survivor区被分为S0和S1两块内存空间，每次YGC的时候，他们将存活的对象复制到未使用那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Survivor区容量的上限，则直接移交给老年代。<br><strong>每个对象都有一个计数器，每次YGC都会加1。-XX:MaxTenuringThreshold参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升到老年代。默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</strong> 如果参数配置为1，那么从新生代的Eden区直接移至老年代。<br>如果Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代进行分配；如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。可设置参数 -XX:+HeapDumpOnOutOfMemoryError,让JVM遇到OOM时输出堆内信息。  </p><h2 id="二、方法区"><a href="#二、方法区" class="headerlink" title="二、方法区"></a>二、方法区</h2><ul><li><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>元空间的前身为永久代（Perm），在JDK8之后被淘汰，在JDK7及之前的版本中，只有Hotspot才有Perm区，译为永久代，它在启动的时候固定大小，很难进行调优，并且FGC时会移动类元信息。  </p></li><li><p>区别于永久代，元空间在本地内存中分配。在JDK8里，Perm区中的所有内容中  字符串常量移至堆内存，其他内容包括类元信息，字段，静态属性，方法，常量等移动至元空间内。</p></li></ul><h2 id="三、JVM-Stack（虚拟机栈）"><a href="#三、JVM-Stack（虚拟机栈）" class="headerlink" title="三、JVM Stack（虚拟机栈）"></a>三、JVM Stack（虚拟机栈）</h2><ul><li><p>java虚拟机栈是线程私有的，生命周期与线程相同。  </p></li><li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈入栈到出栈的过程。</p></li><li><p>Java虚拟机规范中对这个区域规定两种异常情况：   </p><ol><li>OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；</li><li>StackOverflowError（线程请求的栈深度 &gt; 虚拟机所允许的深度）；</li></ol></li></ul><p>  虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。  </p><p><strong>1. 局部变量表</strong>  </p><p>  局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段，局部变量没有准备阶段，必须显式化初始化。如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。  </p><p><strong>2. 操作栈</strong>  </p><p>操作栈是一个初始状态为空的桶式结构栈。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的stack属性中。</p><p><strong>3. 动态连接</strong>  </p><p>每个栈帧中包含一个在常量池中对当前方法的引用，目的就是支持方法调用过程的动态连接。  </p><p><strong>4. 方法返回地址</strong>  </p><p>方法执行有两种退出情况：第一，正常退出；第二，异常退出。无论哪种退出情况，都将返回至方法当前被调用的位置。方法退出相当于弹出当前栈帧。</p><p><strong>退出的三种方式：</strong>  </p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给能够处理的栈帧</li><li>PC计数器指向方法调用后的下一条指令  </li></ul><h2 id="四、本地方法栈"><a href="#四、本地方法栈" class="headerlink" title="四、本地方法栈"></a>四、本地方法栈</h2><ul><li><p>本地方法栈描述的是Native方法执行的内存模型  </p></li><li><p>可能抛出的异常：与 Java 虚拟机栈一样。  </p></li></ul><p>本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，而本地方法栈“主外”。本地方法栈为Native方法服务。<br>线程开始调用本地方法时，会进入一个不再受JVM约束的世界。本地方法可以通过JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为他的出错信息比较黑盒。对于内存不足的情况，本地方法栈还是会抛出native heap OutOfMemory。  </p><h2 id="五、程序计数器（Program-Counter-Register，PC）"><a href="#五、程序计数器（Program-Counter-Register，PC）" class="headerlink" title="五、程序计数器（Program Counter Register，PC）"></a>五、程序计数器（Program Counter Register，PC）</h2><ul><li><p>程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p>JVM多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，所以，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程互不影响，独立存储，线程私有。</p></li><li><p>线程执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行Native方法，这个计数器值为空（Undefined）。</p></li><li><p>此区域是唯一一个JVM规范中没有规定任何OOM（OutOfMemoryError）情况的区域。  </p></li></ul><p>  每个线程创建后，都会产生自己的程序计数器和栈帧，程序计数器都用来存放执行指令的偏移量和行号指示器等，线程执行和恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。  </p><p><strong>从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本地方法栈、程序计数器是线程内部私有的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(一)----JVM基本概念</title>
      <link href="/2019/07/13/jvm1/"/>
      <url>/2019/07/13/jvm1/</url>
      
        <content type="html"><![CDATA[<p><strong>一、什么是JVM</strong>  </p><p>JVM(Java Virtual Machine) ,中文名java虚拟机，是由软件技术模拟出计算机运行的一个虚拟计算机。</p><p>java程序经过编译后，产生 .class 文件， jvm 才能识别并运行它，jvm 针对每个操作系统开发出对应的编译器，所以只要其操作系统有对应版本的jvm，那么java程序便能运行起来，这是java可以一次编译，到处运行的原因。</p><p><strong>二、JRE、JDK和JVM的关系</strong>  </p><p><strong>JRE（Java Runtime Environment， Java运行环境）</strong> 是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。</p><p><strong>JDK（Java Development Kit，Java开发工具包）</strong> 是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API ）。</p><p><strong>JVM（Java Virtual Machine， Java虚拟机）</strong> 是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性。</p><p><strong>三、JVM基本概念</strong></p><p>jvm基本结构如下:  </p><p> <img src="//qx-ljy.cn/2019/07/13/jvm1/jvm1.png" alt="jvm基本结构"></p><p> <strong>说明：</strong> 方法区：线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也称之为永久代，有一个别名叫做Non-Heap（非堆）。  </p><p>在JDK8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域取代。元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在于虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入元空间，字符串和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统实际可用空间控制。</p><p><strong>采用元空间代替永久代的原因：</strong>  </p><ol><li>字符串存在永久代中，容易出现性能和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出（因为堆内存有限，此消彼长）</li><li>永久代会为GC带来不必要的复杂度，并且回收效率低。</li></ol><p><strong>四、JVM生命周期</strong></p><ol><li><strong>启动：</strong> 启动一个Java程序，一个JVM实例就产生。拥有public static void main(String[] args)函数的class可以作为JVM实例运行的起点。</li><li><strong>运行：</strong> main()作为程序初始线程的起点，任何其他线程均可由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM使用，程序可以指定创建的线程为守护线程。</li><li><strong>消亡：</strong> 当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</li></ol><p><strong>五、JVM体系</strong></p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(一)----Dockerfile基础指令</title>
      <link href="/2019/07/06/docker01/"/>
      <url>/2019/07/06/docker01/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Dockerfile简介"><a href="#一、Dockerfile简介" class="headerlink" title="一、Dockerfile简介"></a>一、Dockerfile简介</h2><p>  Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令，Docker程序将这些Dockerfile指令翻译真正的Linux命令；Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile，Docker程序将读取Dockerfile，根据指令生成定制的image。</p><p>  Dockerfile的指令是忽略大小写的，建议使用大写，使用#作为注释，每一行只支持一条指令，每条指令可以携带多个参数。</p><p>  Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层， 因此每一条指令的内容，就是描述该层应当如何构建。  </p><h2 id="二、dockerfile指令详解"><a href="#二、dockerfile指令详解" class="headerlink" title="二、dockerfile指令详解"></a>二、dockerfile指令详解</h2><p><strong>1. FROM</strong>  </p><p>  功能为指定基础镜像，并且必须是第一条指令。  </p><p>  除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为scratch。这个镜像 是虚拟的概念，并不实际存在，它表示一个空白的镜像。<br>  如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始构建。  </p><p>  不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如swarm、coreos/etcd 。对于Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小 巧。使用Go语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><p><strong>2. MAINTAINER</strong>  </p><p>  格式为 MAINTAINER <name>，指定维护者信息。</name></p><p><strong>3. RUN</strong>  </p><p>  用来执行命令行命令  </p><ul><li>shell格式：RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样</li><li>exec格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式  </li></ul><p>使用 &amp;&amp; 符连接多个命令； \ 符进行换行。</p><p>为防止镜像臃肿，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉（编译构建所需要的软件，所有下载、展开的文件，apt缓存文件等）。  </p><p><strong>4. CMD</strong>  </p><ul><li>shell格式：CMD &lt;命令&gt;</li><li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li><li>参数列表格式：CMD [“参数1”, “参数2”…]，提供给 ENTRYPOINT 的默认参数  </li></ul><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p><p>Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用upstart/systemd去启动后台服务，容器内没有后台服务的概念。   </p><p>CMD service nginx start ，如果这样写会出现容器执行后立即退出了，这主要是因为没搞明白前台和后台的概念，没有区分容器和虚拟机的差异，对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，进而退出，其他辅助进程不是他关心的内容。 上述命令可以理解为 CMD[ “sh”, “-c”, “service nginx start”]  ，因此主进程是sh ,sh结束，主进程退出，自然容器也会退出。正确的做法是 CMD [ “nginx”, “-g”, “daemon off;” ]</p><p><strong>5. ENTRYPOINT</strong>  </p><p>两种格式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”]</li><li>ENTRYPOINT command param1 param2（shell中执行）  </li></ul><p>配置容器启动后执行的命令，ENTRYPOINT 在运行时也可以替代，不过比CMD要略显繁琐，需要通过docker run的参数 -entrypoint来指定。</p><p><strong>当指定了ENTRYPOINT后，CMD的含义就发生了改变：</strong></p><p>如果CMD中不是完整的命令，则将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为 ENTRYPOINT CMD。  </p><p>如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效。  </p><p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。  </p><p><strong>6. EXPOSE</strong>  </p><ul><li>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]  </li></ul><p>功能为暴漏容器运行时的监听端口给外部，但是EXPOSE并不会使容器访问主机的端口，如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数。  </p><p>-P：大写P为自动映射，会将EXPOSE暴露出来的端口随机映射到宿主机的端口上，如果没有暴露端口，就不会有映射。<br>-p：小写p为手动映射，需要自己指定宿主机的端口和容器的端口，形式为：<br>-p    宿主机端口：容器端口</p><p>（1）无论有没有暴露端口、自动映射或者手动映射，宿主机都可以通过容器ip+port（port随容器内部服务监听端口改变而改变）端口访问服务；  </p><p>（2）要通过宿主机ip+端口的方式访问服务，宿主机的端口必须与容器端口有映射关系；</p><p>（3）如果没有暴露端口，-P自动映射不会映射任何端口，-p可以指定宿主机端口和容器端口形成映射。</p><p><strong>7. ENV</strong>  </p><ol><li>ENV &lt;键&gt; &lt;值&gt;</li><li>ENV &lt;键&gt;=&lt;值&gt; …  </li></ol><p>两者的区别就是第一种是一次设置一个，第二种是一次设置多个  </p><p>下列指令可以支持环境变量展开：<br><strong>ADD、COPY 、ENV、EXPOSE 、LABEL 、USER 、WORKDIR 、VOLUME 、STOPSIGNAL、ONBU ILD</strong>  </p><p><strong>使用环境变量方式： $环境变量</strong>  </p><p><strong>8. COPY</strong></p><p>将从构建上下文目录中&lt;源路径&gt;的文件或者目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。  </p><p>此外，还需要注意一点，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git 进行管理的时候。  </p><ul><li>COPY：&lt;源路径&gt;… &lt;目标路径&gt;   </li><li>COPY： [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY src1 \</span><br><span class="line">     src2 \</span><br><span class="line">     WORKDIR/</span><br></pre></td></tr></table></figure><p>执行上述操作会发现将src1 src2 下的文件全部复制到WORKDIR下，并没有复制目录src1 src2，官方对于COPY解释是：</p><blockquote><p>Note: The directory itself is not copied, just its contents.</p></blockquote><p>即：COPY指令拷贝一个文件夹只会拷贝文件夹的内容。  </p><p>上述指令可以这样写：  </p><pre><code class="sh">COPY src1 \     src2 \     WORKDIR/src</code></pre><p>这样将COPY的文件，放在了新创建的src目录下。  </p><p><strong>9. ADD</strong>  </p><p>ADD指令和COPY的格式和性质基本一致，不过&lt;源文件&gt;可以是一个URL,同时如果源文件是一个压缩文件，ADD会自动执行解压缩。  </p><p>因此在COPY 和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩的场合使用ADD 。  </p><p><strong>10. VOLUME</strong>  </p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]   </li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存 动态数据的应用，其数据库文件应该保存于卷(volume)中。  </p><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p><p><strong>如何使用：</strong><br>在Dockerfile中定义匿名卷，运行容器时，使用参数 <strong>-v 宿主机目录:匿名卷</strong>  进行挂载，实现了数据持久化。  </p><p><strong>11. WORKDIR</strong>  </p><ul><li>WORKDIR &lt;工作目录路径&gt;   </li></ul><p>使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。  </p><p>可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。  </p><pre><code class="sh">WORKDIR /aWORKDIR bWORKDIR cRUN <span class="built_in">pwd</span>  则最终路径为 /a/b/c。</code></pre><p><strong>12. USER</strong></p><ul><li>USER &lt;用户名&gt;   </li></ul><p>USER是改变之后层的执行RUN ,CMD以及ENTRYPOINT这类命令的身份。USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。  </p><p><strong>13. ONBUILD</strong>  </p><ul><li>ONBUILD &lt;其它指令&gt;   </li></ul><p>ONBUILD是一个特殊的指令，它后面跟的是其它指令，比如RUN ,COPY等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br>Dockerfile中的其它指令都是为了定制当前镜像而准备的，唯有ONBUILD是为了帮助别人定制自己而准备的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown的基本使用</title>
      <link href="/2019/07/05/markdown1/"/>
      <url>/2019/07/05/markdown1/</url>
      
        <content type="html"><![CDATA[<h2 id="MarkDown基本使用"><a href="#MarkDown基本使用" class="headerlink" title="MarkDown基本使用"></a>MarkDown基本使用</h2><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>‘#’ 符号 + 空格 +  标题<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure></p><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul><li><p>斜体  </p><p>要倾斜的文字左右分别用一个*号包起来</p></li><li><p>加粗  </p><p>要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体加粗  </p><p>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线  </p><p>要加删除线的文字左右分别用两个~~号包起来</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;  三个&gt;&gt;&gt;</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">**********************</span><br></pre></td></tr></table></figure><hr><hr><h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">  ![测试图片](test.jpg)</span><br></pre></td></tr></table></figure><p>  <img src="//qx-ljy.cn/2019/07/05/markdown1/test.jpg" alt="测试图片"></p><h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul><li>无序列表  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><ol><li>列表内容  </li><li>列表内容</li><li>列表内容</li></ol><ul><li>列表嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上一级和下一级之间敲三个空格即可</span><br></pre></td></tr></table></figure><h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(```java)</span><br><span class="line">(```)</span><br><span class="line"></span><br><span class="line">注：为了防止转义，加了小括号。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
