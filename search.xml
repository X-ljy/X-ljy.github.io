<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git基本操作</title>
      <link href="/2019/07/20/git/"/>
      <url>/2019/07/20/git/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 仓库操作</strong></p><ul><li>git init   (创建一个Git仓库)</li><li>git clone [url]  （拷贝一个git仓库到本地）</li></ul><blockquote><p>工作流 ：<br>本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index）,它像个缓存区域，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。  </p></blockquote><p><strong>2. 将文件添加到缓存区</strong></p><ul><li><p>git add [filename]  </p></li><li><p>git add .  </p><p>不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</p></li><li><p>git add -u .  </p><p>-u  == –update ，表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</p></li><li><p>git add -A .  </p><p>-A == –all  ， 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。  </p></li></ul><p><strong>3. 将改动提交到 HEAD，但是不到远端仓库</strong>  </p><ul><li>git commit -m “代码提交信息”</li></ul><p><strong>4. 推送改动</strong></p><ul><li><p>git push origin master  </p><p>git commit 之后，你的改动已经在本地仓库的HEAD中了，执行此上命令，可提交至远端仓库，master 可换成你想推送的任何分支。</p></li><li><p>git remote add origin [url]  </p><p>使用此命令可将你的仓库连接到某个远程服务器，此后你就可以将改动推送到添加的服务器中了。</p></li></ul><p><strong>5. 分支</strong></p><ul><li><p>git checkout -b [分支名称]  </p><p>新建分支并切换到该分支</p></li><li><p>git checkout master<br>切换到指定分支  </p></li><li><p>git branch -d [分支命称]<br>将新建分支删掉  </p></li></ul><p><strong>6. 更新与合并</strong>  </p><ul><li><p>git pull<br>按照git branch 设置的默认跟踪的服务器和分支来拉取  </p></li><li><p>git pull origin master<br>拉取远程服务器origin 的master分支  </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列（二）</title>
      <link href="/2019/07/14/jvm2/"/>
      <url>/2019/07/14/jvm2/</url>
      
        <content type="html"><![CDATA[<p><strong>经典JVM内存布局（JDK8以上）</strong>  </p><p><img src="//x-ljy.github.io/2019/07/14/jvm2/jvm2.png" alt="经典JVM布局"></p><p><strong>一、Heap（堆区）</strong>  </p><p><strong>Heap存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各个子线程共享使用。</strong> 通常情况下，它占用的空间是所有内存区域中最大的，同时也是OOM（Out Of Memory）故障最主要的发源地。  </p><p>堆的内存空间既可以固定大小，也可以在运行时动态地调整。  </p><p>通过如下参数设置初始值和最大值，比如-Xms256M -Xmx1024M （-X表示它是JVM运行参数，ms是memory start（最小堆容量）的简称，mx是memory max（最大堆容量）的简称）。由于服务器在不断运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以在线上生产环境中，JVM的Xms Xmx 设置成一样大小，避免在GC调整堆大小时带来的额外压力。</p><p><strong>堆分为两大块：新生代和老年代。</strong> 对象产生之初在新生代，步入暮年进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。  </p><p><strong>新生代 = 1个Eden区 + 2个Survivor区。</strong> 绝大部分对象在Eden区生成，当Eden区填满的时候，后触发Young Garbage Collection（YGC）。垃圾回收的时候在Eden区实现清除策略，没有被引用的对象则直接回收。仍然存活的对象会被移送到Survivor区。Survivor区被分为S0和S1两块内存空间，每次YGC的时候，他们将存活的对象复制到未使用那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Survivor区容量的上限，则直接移交给老年代。<br><strong>每个对象都有一个计数器，每次YGC都会加1。-XX:MaxTenuringThreshold参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升到老年代。默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</strong> 如果参数配置为1，那么从新生代的Eden区直接移至老年代。<br>如果Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代进行分配；如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。可设置参数 -XX:+HeapDumpOnOutOfMemoryError,让JVM遇到OOM时输出堆内信息。  </p><p><strong>二、Metaspace(元空间)</strong>  </p><p>  元空间的前身为永久代（Perm），在JDK8之后被淘汰，在JDK7及之前的版本中，只有Hotspot才有Perm区，译为永久代，它在启动的时候固定大小，很难进行调优，并且FGC时会移动类元信息。  </p><p>  区别于永久代，元空间在本地内存中分配。在JDK8里，Perm区中的所有内容中  字符串常量移至堆内存，其他内容包括类元信息，字段，静态属性，方法，常量等移动至元空间内。</p><p><strong>三、JVM Stack（虚拟机栈）</strong>  </p><p>  虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。  </p><p><strong>1. 局部变量表</strong>  </p><p>  局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段，局部变量没有准备阶段，必须显式化初始化。如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。  </p><p><strong>2. 操作栈</strong>  </p><p>操作栈是一个初始状态为空的桶式结构栈。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的stack属性中。</p><p><strong>3. 动态连接</strong>  </p><p>每个栈帧中包含一个在常量池中对当前方法的引用，目的就是支持方法调用过程的动态连接。  </p><p><strong>4. 方法返回地址</strong>  </p><p>方法执行有两种退出情况：第一，正常退出；第二，异常退出。无论哪种退出情况，都将返回至方法当前被调用的位置。方法退出相当于弹出当前栈帧。</p><p><strong>退出的三种方式：</strong>  </p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给能够处理的栈帧</li><li>PC计数器指向方法调用后的下一条指令  </li></ul><p><strong>四、本地方法栈</strong>  </p><p>本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，而本地方法栈“主外”。本地方法栈为Native方法服务。<br>线程开始调用本地方法时，会进入一个不再受JVM约束的世界。本地方法可以通过JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为他的出错信息比较黑盒。对于内存不足的情况，本地方法栈还是会抛出native heap OutOfMemory。  </p><p><strong>五、程序计数器（Program Counter Register，PC）</strong><br>  每个线程创建后，都会产生自己的程序计数器和栈帧，程序计数器都用来存放执行指令的偏移量和行号指示器等，线程执行和恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。  </p><p><strong>从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本地方法栈、程序计数器是线程内部私有的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列（一）</title>
      <link href="/2019/07/13/jvm1/"/>
      <url>/2019/07/13/jvm1/</url>
      
        <content type="html"><![CDATA[<p><strong>一、什么是JVM</strong>  </p><p>JVM(Java Virtual Machine) ,中文名java虚拟机，是由软件技术模拟出计算机运行的一个虚拟计算机。</p><p>java程序经过编译后，产生 .class 文件， jvm 才能识别并运行它，jvm 针对每个操作系统开发出对应的编译器，所以只要其操作系统有对应版本的jvm，那么java程序便能运行起来，这是java可以一次编译，到处运行的原因。</p><p><strong>二、JRE、JDK和JVM的关系</strong>  </p><p><strong>JRE（Java Runtime Environment， Java运行环境）</strong> 是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。</p><p><strong>JDK（Java Development Kit，Java开发工具包）</strong> 是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API ）。</p><p><strong>JVM（Java Virtual Machine， Java虚拟机）</strong> 是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性。</p><p><strong>三、JVM基本概念</strong></p><p>jvm基本结构如下:  </p><p> <img src="//x-ljy.github.io/2019/07/13/jvm1/jvm1.png" alt="jvm基本结构"></p><p> <strong>说明：</strong> 方法区：线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也称之为永久代，有一个别名叫做Non-Heap（非堆）。  </p><p>在JDK8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域取代。元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在于虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入元空间，字符串和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统实际可用空间控制。</p><p><strong>采用元空间代替永久代的原因：</strong>  </p><ol><li>字符串存在永久代中，容易出现性能和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出（因为堆内存有限，此消彼长）</li><li>永久代会为GC带来不必要的复杂度，并且回收效率低。</li></ol><p><strong>四、JVM生命周期</strong></p><ol><li><strong>启动：</strong> 启动一个Java程序，一个JVM实例就产生。拥有public static void main(String[] args)函数的class可以作为JVM实例运行的起点。</li><li><strong>运行：</strong> main()作为程序初始线程的起点，任何其他线程均可由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM使用，程序可以指定创建的线程为守护线程。</li><li><strong>消亡：</strong> 当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</li></ol><p><strong>五、JVM体系</strong></p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(一)</title>
      <link href="/2019/07/06/docker01/"/>
      <url>/2019/07/06/docker01/</url>
      
        <content type="html"><![CDATA[<p><strong>一、Dockerfile简介</strong>  </p><p>  Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令，Docker程序将这些Dockerfile指令翻译真正的Linux命令；Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile，Docker程序将读取Dockerfile，根据指令生成定制的image。</p><p>  Dockerfile的指令是忽略大小写的，建议使用大写，使用#作为注释，每一行只支持一条指令，每条指令可以携带多个参数。</p><p>  Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层， 因此每一条指令的内容，就是描述该层应当如何构建。  </p><p><strong>二、dockerfile指令详解</strong>   </p><p><strong>1. FROM</strong>  </p><p>  功能为指定基础镜像，并且必须是第一条指令。  </p><p>  除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为scratch。这个镜像 是虚拟的概念，并不实际存在，它表示一个空白的镜像。<br>  如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始构建。  </p><p>  不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如swarm、coreos/etcd 。对于Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小 巧。使用Go语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><p><strong>2. RUN</strong>  </p><p>  用来执行命令行命令  </p><ul><li><p>shell格式：RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样  </p></li><li><p>exec格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式  </p><p>使用 &amp;&amp; 符连接多个命令； \ 符进行换行。</p><p>为防止镜像臃肿，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉（编译构建所需要的软件，所有下载、展开的文件，apt缓存文件等）。  </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown的基本使用</title>
      <link href="/2019/07/05/markdown1/"/>
      <url>/2019/07/05/markdown1/</url>
      
        <content type="html"><![CDATA[<h2 id="MarkDown基本使用"><a href="#MarkDown基本使用" class="headerlink" title="MarkDown基本使用"></a>MarkDown基本使用</h2><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>‘#’ 符号 + 空格 +  标题<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure></p><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul><li><p>斜体  </p><p>要倾斜的文字左右分别用一个*号包起来</p></li><li><p>加粗  </p><p>要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体加粗  </p><p>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线  </p><p>要加删除线的文字左右分别用两个~~号包起来</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;  三个&gt;&gt;&gt;</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">**********************</span><br></pre></td></tr></table></figure><hr><hr><h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">  ![测试图片](test.jpg)</span><br></pre></td></tr></table></figure><p>  <img src="//x-ljy.github.io/2019/07/05/markdown1/test.jpg" alt="测试图片"></p><h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul><li>无序列表  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><ol><li>列表内容  </li><li>列表内容</li><li>列表内容</li></ol><ul><li>列表嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上一级和下一级之间敲三个空格即可</span><br></pre></td></tr></table></figure><h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(```java)</span><br><span class="line">(```)</span><br><span class="line"></span><br><span class="line">注：为了防止转义，加了小括号。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
