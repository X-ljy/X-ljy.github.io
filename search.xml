<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux内核设计和实现</title>
      <link href="/2019/10/28/Linux%E5%86%85%E6%A0%B8/"/>
      <url>/2019/10/28/Linux%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux内核简介"><a href="#Linux内核简介" class="headerlink" title="Linux内核简介"></a>Linux内核简介</h2><h3 id="单内核和微内核"><a href="#单内核和微内核" class="headerlink" title="单内核和微内核"></a>单内核和微内核</h3><table><thead><tr><th align="left"></th><th align="left">原理</th></tr></thead><tbody><tr><td align="left">Item One</td><td align="left">Item Two</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP详解（一）</title>
      <link href="/2019/10/23/aop%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/10/23/aop%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql命令总结</title>
      <link href="/2019/10/17/Mysql%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/17/Mysql%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 进入mysql命令行</span></span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示哪些线程在运行</span></span><br><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统变量信息</span></span><br><span class="line">show variables;</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2019/10/15/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/10/15/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p><img src="//qx-ljy.cn/2019/10/15/数据链路层/01.png" alt></p><p><strong>如上图所示，链路层主要有三个目的：</strong></p><ol><li><p>为IP模块发送和接收数据报  </p></li><li><p>为ARP模块发送ARP请求和接收ARP应答</p></li><li><p>为RARP发送RARP请求和接收RARP应答（RARP现在已经淘汰不用了）</p></li></ol><p><strong>链路层的三个基本问题：</strong></p><ol><li><strong>封装成帧</strong> ：将网络层传下来的数据分组添加首部和尾部，用于标记帧的开始和结束。每一种链路层协议都规定了所能传送 <strong>帧的数据部分</strong> 长度上限—-最大传输单元 MTU。</li></ol><blockquote><p>以太网（Ethernet）协议：1500字节<br>Point-to-Point：4470字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up/Modem）：576字节<br>FDDI协议：4352字节</p></blockquote><ol start="2"><li><p><strong>透明传输</strong> ：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧开始结束的地方就会错误地被判定。（在数据部分出现首部尾部相同的内容前面加上转义字符（“ESC”，16进制编码是 1B，二进制是 00011011）。如果数据部分出现转义字符，那就在转义字符前面再加上一个转义字符。接受端进行处理后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在）</p></li><li><p><strong>差错检测</strong> ：目前链路层广泛使用了循环冗余校验（CRC）来检查比特差错。</p></li></ol><p><strong>MAC地址</strong></p><p>在局域网中，硬件地址又叫做物理地址或MAC地址（因为这种地址在MAC帧中使用）</p><p>MAC地址长48比特（6个字节），在使用网卡（NIC）时，MAC地址一般会烧入到ROM（只读存储器（Read-Only Memory））中。</p><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>PPP（Point-to-Point Protocol）是指点对点，即1对1连接计算机的协议。</p><h3 id="LCP-与-NCP"><a href="#LCP-与-NCP" class="headerlink" title="LCP 与 NCP"></a>LCP 与 NCP</h3><p>PPP主要功能中包括两个协议：一个是不依赖上层的LCP协议（Link Control Protocol），一个是依赖上层的NCP协议（Network Control Protocol）。如果上层为IP，此时NCP也叫作IPCP（IP Control Protocol）。</p><p>LCP主要负责建立和断开连接，设置最大接收单元（MRU）、设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控。而IPCP负责IP地址设置以及是否进行TCP/IP首部压缩等。</p><h3 id="PPP帧格式"><a href="#PPP帧格式" class="headerlink" title="PPP帧格式"></a>PPP帧格式</h3><p><img src="//qx-ljy.cn/2019/10/15/数据链路层/02.png" alt></p><p>0x0021：IP数据报<br>0xc021：链路控制数据 (LCP)<br>0x8021：网络控制数据 (NCP)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(三)----垃圾回收算法和垃圾收集器</title>
      <link href="/2019/10/04/jvm4/"/>
      <url>/2019/10/04/jvm4/</url>
      
        <content type="html"><![CDATA[<h2 id="对象是否可被回收"><a href="#对象是否可被回收" class="headerlink" title="对象是否可被回收"></a>对象是否可被回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p><strong>实现原理：</strong> 为每个对象配备一个整形的计数器，例如，对象A，只要有任何对象引用了A，则A的引用计数器就加1，当引用失效时，减1；当A的引用计数器为0时，对象A就不可能再被使用，即可以进行回收。</p><p><strong>存在问题：</strong></p><ol><li>无法处理循环引用的问题。所以在Java垃圾回收器中，没有使用这种方法。</li></ol><blockquote><p>循环引用：有对象A和B，A中含有对象B的引用，对象B中含有A的引用；此时，A和B的计数器都不为0，即无法进行回收；但是在整个系统中，没有其他对象引用了A和B，A和B是应该被回收的对象，但由于垃圾对象之间的互相引用，从而使垃圾回收器无法识别，造成内存泄漏。</p></blockquote><ol start="2"><li>引用计数器要求每次引用产生和消除的时候，都要伴随一次加减操作，对系统性能有一定影响。</li></ol><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p><strong>实现原理：</strong> 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链时（即不可达），则此对象不可用，可以判定为可回收对象。</p><p><strong>可以作为 GC Roots 的对象：</strong>  </p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li></ol><h3 id="判断可触及性"><a href="#判断可触及性" class="headerlink" title="判断可触及性"></a>判断可触及性</h3><p>通过可达性分析法可以判断哪些对象不可达。一般来说，不可达对象需要被回收。但事实上，该对象有可能在某一条件下“复活自己”，如果这样，再回收就不合理了。为此需要定义对象的可触及性状态，并规定在什么状态下，可以安全回收对象。</p><p><strong>可触及性包含三种状态：</strong>  </p><ul><li><p>可触及的：从根节点出发，可以到达这个对象。</p></li><li><p>可复活的：对象的所有引用都被释放，但是对象有可能在 <strong>finalize()</strong> 函数中复活。</p></li><li><p>不可触及的：对象的finalize()函数被调用，并且没有复活，或者 <strong>对象的 finalize() 没有重写（没必要执行）</strong>， 那么就会进入不可触及状态，此时对象不可能被复活，因为 finalize() 只会被调用一次。</p></li></ul><p><strong>对象只有在不可触及状态时，才可以被回收。</strong></p><p><strong>注意:</strong>  </p><ul><li><p>finalize()函数是一个非常糟糕的模式，不推荐使用它释放资源。</p></li><li><p>finalize() 有可能发生引用外泄，在无意中复活对象。</p></li><li><p>finalize() 被系统调用，调用时间不明确。释放资源推荐在 try-catch-finally 中实现。</p></li></ul><h3 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h3><p>Java 提供四个级别的引用，由强到弱依次是：强引用、软引用、弱引用、虚引用。除强引用外，其他都可以在 java.lanf.ref 包中找到。</p><p><strong>不同引用级别出现的意义：</strong> 希望描述这样一类对象：当内存对象还足够时，则保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。</p><ul><li><p>强引用：类似 Object object = new Object() 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉引用的对象。</p></li><li><p>软引用：用来描述一些还有用但是非必须的对象。对于软引用关联的对象，系统将在发生内存溢出前，将这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p></li><li><p>弱引用：用来描述非必须对象。它关联的对象只能拿生存到下一次垃圾收集发生之前，当垃圾回收器工作时，无论内存是否足够，都会回收被弱引用关联的对象。</p></li><li><p>虚引用：一个对象是否有虚引用，完全不会影响其生存周期，也无法通过虚引用取得对象实例。为对象设置虚引用关联的唯一目的是能在这个对象被回收时得到系统通知。</p></li></ul><p><strong>软引用，弱引用非常适合保存可有可无的缓存数据，从而加速系统运行。</strong></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>顾名思义：此算法分为两个阶段 标记 和 清除。</p><p>标记：标记的过程其实就是，遍历所有的 GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。  </p><p>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</p><p><strong>不足：</strong>  </p><ol><li><p>效率问题：标记和清除过程的效率都不高。</p></li><li><p>空间碎片问题：标记清除后会出现大量不连续的内存碎片，空间碎片太多会导致以后程序运行无法分配较大对象时，提前触发GC。</p></li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将原有的内存空间分为两块，每次只是用其中一块，在GC时，将正在使用的内存中存活对象复制到未使用的内存块中，然后，清除正在使用内存的所有对象，交换两块内存的角色。</p><p>复制算法适合存活对象少、垃圾对象多的情况，所以复制算法很适合新生代（新生代中垃圾对象通常多于存活对象）。</p><p>新生代中的 Eden 存活下来的对象，Survivor区不能完全存放，那么这些对象会通过分配担保机制进入老年代。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法是一种老年代的回收算法。首先需要从根节点开始，对所有可达对象做一次标记，然后将所有存活对象整理到内存的一端，之后清理边界外所有的空间。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。</p><p>对于新生代，回收频率很高，但每次GC耗时很短，而老年代频率低，但会消耗更长的时间。为了支持高频率的新生代回收，虚拟机使用一种叫做卡表的数据结构。卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。</p><p>这样在新生代GC时，可以不用耗大量时间扫描所有老年代对象，来确定引用关系，可以先扫描卡表，卡表位为1时，才包含新生代引用，在新生代GC时，只需扫描卡表位为1所在的老年代空间,这样可大大加快新生代回收速度。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>分区算法将整个堆空间划分成连续的小区间。每个小区间都独立使用，独立回收。这种做法的好处是可以控制一次回收多少个小区间，从而很好的控制GC产生的停顿时间。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>新生代串行回收器：</p><ol><li><p>它只使用单线程进行垃圾回收</p></li><li><p>它是独占式的垃圾回收</p></li></ol><p>由于串行收集器只使用单线程回收，所以在垃圾回收时会出现“Stop The World”。这样会造成很槽糕的用户体验，在实时性要求较高的场景不适应。</p><p>由于新生代串行收集器使用复制算法，实现相对简单，逻辑处理特别高效，而且没有线程切换开销。在单CPU处理器等硬件平台不是特别优越的场合，它的性能可以超过并行回收器和并发回收器。  </p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>老年代串行回收器：</p><ol><li><p>使用的是标记-整理算法</p></li><li><p>串行的，它是独占式的</p></li></ol><p>可以作为CMS回收器的备用回收器  </p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>新生代并发回收器</p><ol><li><p>回收策略，算法，参数和新生代串行回收器一样</p></li><li><p>回收过程进行了多线程化，但是回收过程应用程序依旧会全部暂停</p></li></ol><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>同样也是新生代并发收集器，但是它却注重系统吞吐量。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>老年代并发回收器，使用标记-清除算法</p><ol><li>多线程并发收集器，也是一种关注吞吐量的收集器</li></ol><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>老年代并发收集器，主要关注于系统停顿时间。</p><ol><li><p>初始标记： STW（Stop The World）标记根对象</p></li><li><p>并发标记：标记所有对象</p></li><li><p>预清理：清理前准备以及控制停顿时间</p></li><li><p>重新标记：STW，修正并发标记数据</p></li><li><p>并发清理：清理垃圾</p></li><li><p>并发重置</p></li></ol><p>初始标记和重新标记是独占系统资源的，而预清理、并发标记、并发清除和并发重置是可以和用户线程一起执行的。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/10/02/designpattern/"/>
      <url>/2019/10/02/designpattern/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式（proxy模式）"><a href="#代理模式（proxy模式）" class="headerlink" title="代理模式（proxy模式）"></a>代理模式（proxy模式）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。</p></li><li><p>好处：可以在目标对象的基础上，增强额外的功能操作，即拓展目标对象的功能。<strong>只在必要时生成实例</strong></p></li><li><p>被代理的对象可以是远程对象，创建开销大的对象，需要安全控制的对象</p></li><li><p>代理模式有不同形式，主要有三种 <strong>静态代理，动态代理（JDK代理，接口代理）和 Cglib代理（可以在内存中动态的创建对象，而不需要实现接口，属于动态代理的范畴）。</strong></p></li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同父类。</strong>  </p><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teach</span> <span class="keyword">implements</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师授课中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象，静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeachProxy</span> <span class="keyword">implements</span> <span class="title">Teacherable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Teacherable target; <span class="comment">//  目标对象，通过接口聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeachProxy</span><span class="params">(Teacherable target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理开始 完成某些操作"</span>);</span><br><span class="line">        target.Teach();</span><br><span class="line">        System.out.println(<span class="string">"代理结束。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.staticproxy.teacherdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teach对象</span></span><br><span class="line"><span class="comment">     * 创建TeachProxy代理对象</span></span><br><span class="line"><span class="comment">     * 将Teach对象，交给TeachProxy对象执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象，被代理对象</span></span><br><span class="line">        Teach teach = <span class="keyword">new</span> Teach();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传递给代理对象</span></span><br><span class="line">        TeachProxy teachProxy = <span class="keyword">new</span> TeachProxy(teach);</span><br><span class="line">        <span class="comment">//通过代理对象，调用代理对象的方法</span></span><br><span class="line">        <span class="comment">//执行的是代理对象的方法，代理对象再去调用目标对象的方法</span></span><br><span class="line">        teachProxy.Teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li><p>优点：在不修改目标对象的功能前提下，能通过代理对象对目标对象功能拓展  </p></li><li><p>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类  </p></li><li><p>一旦接口增加方法，目标对象与代理对象都要维护</p></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ol><li><p>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理  </p></li><li><p>代理对象的生成，是利用JDK的API，动态在内存中构建代理对象  </p></li><li><p>动态代理也叫作：JDK代理，接口代理  </p></li></ol><p><strong>JDK生成代理对象的API：</strong>  </p><ol><li><p>代理类所在包：java.lang.reflect.Proxy</p></li><li><p>JDK实现代理只需要使用newProxyInstance方法：<strong>static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</strong>  </p></li></ol><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Teacherable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" : 正在授课"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象，Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，对target进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象，生成一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         *                                       Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         *                                       InvocationHandler h)</span></span><br><span class="line"><span class="comment">         * 1. ClassLoad loader : 指定当前目标对象使用的类加载器，获取加载器的方法固定</span></span><br><span class="line"><span class="comment">         * 2. Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">         * 3. InvocationHandler h : 事件处理，执行目标对象的方法时，会触发事件处理器方法，（会把当前执行的目标对象作为参数传入）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"JDK 代理开始"</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        Object returnVal = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"JDK 代理结束"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        Teacherable target = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象</span></span><br><span class="line">        Teacherable proxyInstance = (Teacherable) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//class com.sun.proxy.$Proxy0  内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(proxyInstance.getClass());</span><br><span class="line">        <span class="comment">//通过代理对象调用目标对象的方法</span></span><br><span class="line">        proxyInstance.Teach(<span class="string">"ljy"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><ol><li><p>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候可以使用目标对象子类来实现代理，这就是Cglib代理  </p></li><li><p>Cglib代理也叫作子类代理，它在内存中构建一个子类对象从而实现对目标对象功能的拓展，有些书也将Cglib代理归属到动态代理</p></li><li><p>Cglib是一个强大的高性能的代码生成包，它可以在运行期拓展java类与实现java接口。它广泛的被许多AOP框架使用，如Spring AOP，实现方法拦截</p></li><li><p>在AOP编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理  </li></ul></li><li><p>Cglib包的底层是通过字节码处理框架ASM来转换字节码并生成新的类  </p></li><li><p>Cglib在内存中构建子类，注意代理的类不能为final，否则报错。  </p></li><li><p>目标对象的方法如果为 final/static ,那么就不会拦截，即不会执行目标对象额外的业务方法。</p></li></ol><p><strong>应用实例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象： 是target的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建一个工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2. 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 intercept 方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cglib 代理 开始"</span>);</span><br><span class="line">        Object returnVal = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"Cglib 代理 结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cglib代理: "</span> + name + <span class="string">" : 正在授课"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        Teacher target = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">//获取代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        Teacher proxyInstance = (Teacher) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法，触发intercept方法，实现对目标对象的调用</span></span><br><span class="line">        proxyInstance.Teach(<span class="string">"ljy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式（Adapter模式）"><a href="#适配器模式（Adapter模式）" class="headerlink" title="适配器模式（Adapter模式）"></a>适配器模式（Adapter模式）</h2><ol><li><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作。别名包装器（Wrapper）</p></li><li><p>适配器模式属于结构型模式</p></li><li><p>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p></li></ol><p><strong>工作原理：</strong>  </p><ol><li><p>适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</p></li><li><p>从用户角度看不到被适配者，是解耦的</p></li><li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p></li><li><p>用户收到反馈结果，感觉只是和目标接口交互  </p></li></ol><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><ol><li><p>Java是单继承机制，所以类适配器需要继承src类（被适配的类），这一点算是一个缺点。因为这要求dst（适配接口）必须是接口，有一定的局限性</p></li><li><p>src类的方法在Adapter中都会暴露出来，也增加了使用的成本</p></li><li><p>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压 : "</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5Vable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取220V电压</span></span><br><span class="line">        <span class="keyword">int</span> srcV  = output220V();</span><br><span class="line">        <span class="keyword">int</span> dstV = srcV/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charging</span><span class="params">(Voltage5Vable voltage5Vable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(voltage5Vable.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5伏，可以充电"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voltage5Vable.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压大于5伏，无法充电"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== 类适配器 ===="</span>);</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.Charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><ol><li><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实现，以解决兼容性的问题。即持有src类，实现dst类接口，完成src-&gt;dst的适配</p></li><li><p>根据“合成服用原则”，在系统中尽量使用关联关系来替代继承关系</p></li><li><p>对象适配器模式是适配器模式常用的一种</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压 : "</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5Vable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入Voltage220V实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V)&#123;</span><br><span class="line">            <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220电压</span></span><br><span class="line">            System.out.println(<span class="string">"使用对象适配器转换"</span>);</span><br><span class="line">            dst = src/<span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">"适配完成: "</span>+ dst + <span class="string">"伏"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Charging</span><span class="params">(Voltage5Vable voltage5Vable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(voltage5Vable.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5伏，可以充电"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voltage5Vable.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压大于5伏，无法充电"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== 类适配器 ===="</span>);</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.Charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><ol><li><p>一些书籍将之称为：适配器模式或缺省适配器模式</p></li><li><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类某些方法来实现需求</p></li><li><p>适用于一个接口不想适用其所有的方法的情况</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在AbsAdapter 将TestInterface 的方法默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter()&#123;</span><br><span class="line">            <span class="comment">//只需覆盖我们需要使用的接口方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用m1方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="职责链模式（Chain-of-Responsibility-Pattern）"><a href="#职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="职责链模式（Chain of Responsibility Pattern）"></a>职责链模式（Chain of Responsibility Pattern）</h2><ol><li><p>职责链模式又叫责任链模式，为请求创建一个接受者对象的链。这种模式对请求的发送者和接受者进行解耦</p></li><li><p>职责链模式通常每个接受者都包含另一个接受者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接受者，以此类推</p></li><li><p>属于行为型模式</p></li></ol><p><strong>应用实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>;<span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type, <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Approver approver; <span class="comment">//下一个处理者</span></span><br><span class="line">    String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver approver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.approver = approver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理请求的方法，处理是子类完成，所以该方法设置成抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//其他角色的处理与之类似，这里不再详述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请求编号id = "</span> + purchaseRequest.getId() + <span class="string">" 被 "</span> + <span class="keyword">this</span>.name + <span class="string">" 处理"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            approver.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">1</span>, <span class="number">31000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建审批人</span></span><br><span class="line">        DepartmentApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">"主任"</span>);</span><br><span class="line">        CollegeApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">"院长"</span>);</span><br><span class="line">        ViceSchoolMasterApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">"副校长"</span>);</span><br><span class="line">        SchoolMasterApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">"校长"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将各级别审批下一个指向设置，即设置责任链</span></span><br><span class="line">        <span class="comment">// (处理人构成环形：可以从任意一个处理方进行调用；不设置成环形：必须从最开始进行调用)</span></span><br><span class="line">        departmentApprover.setApprover(collegeApprover);</span><br><span class="line">        collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">        viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">        schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul><li>动态的将新功能附加到对象上。在对象拓展功能方面，它比继承更有弹性，装饰者模式也体现了开闭原则（OCP）。</li></ul><h3 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h3><ol><li><p>Component：增加功能时的核心角色</p></li><li><p>ConcreteComponent：实现了Component角色所定义的接口（API）的具体</p></li><li><p>Decorator：</p></li><li><p>ConcreteDecorator：</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO详解</title>
      <link href="/2019/10/02/NIO/"/>
      <url>/2019/10/02/NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h1><p>Java NIO Buffer用于和NIO Channel交互。我们从Channel中读取数据到Buffer中，从Buffer把数据写到Channel。</p><p><strong>核心缓冲区如下：</strong></p><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p></li><li><p>LongBuffer</p></li></ul><p><strong>利用Buffer读写数据，通常遵循四个步骤：</strong></p><ol><li><p>把数据写入Buffer（Buffer被创建时是写模式）</p></li><li><p>调用flip（）函数（将Buffer从写模式，转换为读模式）</p></li><li><p>从Buffer中读取数据</p></li><li><p>调用buffer.clear()或者buffer.compact() （重置Buffer，转为写模式）</p></li></ol><p>当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过 flip() 方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，转换为写入操作。清空buffer有两种方式：调用 clear() 或 compact() 方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。</p><p><strong>Buffer的三种属性：</strong></p><ul><li><p>capacity容量</p><blockquote><p>容量（Capacity） 作为一块内存，buffer有一个固定的大小，叫做capacit（容量）。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据.</p></blockquote></li><li><p>position位置</p><blockquote><p>位置（Position） 当写入数据到Buffer的时候需要从一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.<br>当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</p></blockquote></li><li><p>limit限制</p><blockquote><p>上限（Limit） 在写模式，limit的含义是我们所能写入的最大数据量，它等同于buffer的容量。一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。</p></blockquote></li></ul><h2 id="Buffer-常见用法"><a href="#Buffer-常见用法" class="headerlink" title="Buffer 常见用法"></a>Buffer 常见用法</h2><p>这里用ByteBuffer为例</p><h3 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">28</span>);</span><br></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(i)</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x; <span class="comment">//hb为存放在heap的底层数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;  <span class="comment">//这里offset初始值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.flip() <span class="comment">//将写入模式转换为读取模式</span></span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用flip()方法，会将limit位置设置为写入模式时的position，即limit变为写入数据的最大坐标；position设置为0，代表可以从0开始读取数据；mark = -1 ,即将mark重置。</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.get()</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())]; <span class="comment">//hb为存放在heap的底层数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复读取"><a href="#重复读取" class="headerlink" title="重复读取"></a>重复读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.rewind()</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer.rewind()方法将position置为0，这样我们可以重复读取buffer中的数据。limit保持不变。</p><h3 id="Buffer重置"><a href="#Buffer重置" class="headerlink" title="Buffer重置"></a>Buffer重置</h3><p>重置后变为写模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf.compact()</span><br></pre></td></tr></table></figure><p>一旦Buffer中读取完数据，需要复用Buffer为下次写数据做准备。</p><ul><li><p>clear()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><ul><li><p>compact()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.arrayCopy(Object srcArray,<span class="keyword">int</span> srcPos,Object destArray ,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">Object srcArray 原数组（要拷贝的数组）</span><br><span class="line"><span class="keyword">int</span> srcPos 要复制的原数组的起始位置（数组从<span class="number">0</span>位置开始）</span><br><span class="line">Object destArray 目标数组</span><br><span class="line"><span class="keyword">int</span> destPos 目标数组的起始位置</span><br><span class="line"><span class="keyword">int</span> length 原数组的长度</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset; <span class="comment">//offset 默认为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">discardMark</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</p><h3 id="Buffer标记"><a href="#Buffer标记" class="headerlink" title="Buffer标记"></a>Buffer标记</h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Buffer-比较"><a href="#Buffer-比较" class="headerlink" title="Buffer 比较"></a>Buffer 比较</h3><ul><li>equals()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == ob)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> ByteBuffer))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ByteBuffer that = (ByteBuffer)ob;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remaining() != that.remaining())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.limit() - <span class="number">1</span>, j = that.limit() - <span class="number">1</span>; i &gt;= p; i--, j--)</span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="keyword">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compareTo()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断两个buffer相对，需满足：</p><ul><li>类型相同</li><li>buffer中剩余字节数相同</li><li>所有剩余字节相等</li></ul><p>从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。 compareTo(): compareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的：</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="Java-NIO-Channel-的特点"><a href="#Java-NIO-Channel-的特点" class="headerlink" title="Java NIO Channel 的特点"></a>Java NIO Channel 的特点</h2><ul><li><p>OIO流一般是单向的（只能读或者写），通道可以读也可以写</p></li><li><p>OIO流读写是阻塞的，而通道可以是异步读写的。</p></li><li><p>通道总是基于缓冲区Buffer来读写。</p></li></ul><h2 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h2><ol><li><p>FileChannel</p><p>用于文件读写操作</p></li><li><p>DatagramChannel  </p><p>用于UDP数据读写</p></li><li><p>SocketChannel</p><p>用于TCP数据读写</p></li><li><p>ServerSocketChannel</p><p>允许我们监听TCP链接请求，每个请求会创建一个SocketChannel</p></li></ol><h2 id="Channel的使用"><a href="#Channel的使用" class="headerlink" title="Channel的使用"></a>Channel的使用</h2><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取FileChannel对象</span></span><br><span class="line">    RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    FileChannel fileChannel = file.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据到Buffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">int</span> bytesRead = fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    buf.clear();</span><br><span class="line">    buf.put(newData.getBytes());</span><br><span class="line">    buf.flip();</span><br><span class="line">    <span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">        fileChannel.write(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    fileChannel.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强制刷新磁盘</span></span><br><span class="line">    <span class="comment">//FileChannel的force()方法将所有未写入的数据从通道刷新到磁盘中。</span></span><br><span class="line">    <span class="comment">// 在你调用该force()方法之前，出于性能原因，操作系统可能会将数据缓存在内存中，</span></span><br><span class="line">    <span class="comment">// 因此您不能保证写入通道的数据实际上写入磁盘。</span></span><br><span class="line">    fileChannel.force(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><ul><li>UDP Server</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUDPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOUDPServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立DatagramChannel</span></span><br><span class="line">            DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">            <span class="comment">//设置为非阻塞模式</span></span><br><span class="line">            datagramChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//获取DatagramSocket</span></span><br><span class="line">            DatagramSocket datagramSocket = datagramChannel.socket();</span><br><span class="line">            <span class="comment">//设置接收的buffer最大值</span></span><br><span class="line">            datagramSocket.setReceiveBufferSize(<span class="number">10240</span>);</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            datagramSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//DatagramChannel注册到Selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            datagramChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">"UDPServer 正在监听端口："</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分配数据缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录接收的字节总数</span></span><br><span class="line">            <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//如果选择器数目为0，则结束循环</span></span><br><span class="line">                <span class="keyword">int</span> selectNum = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(selectNum == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//得到选择键列表</span></span><br><span class="line">                Set keys = selector.selectedKeys();</span><br><span class="line">                Iterator iterator = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey k = (SelectionKey) iterator.next();</span><br><span class="line">                    <span class="comment">//通过位运算得到通道是否正常准备</span></span><br><span class="line">                    <span class="keyword">if</span>( (k.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ )&#123;</span><br><span class="line">                        <span class="comment">//获取客户端准备好的channel</span></span><br><span class="line">                        DatagramChannel datagramChannelClient = (DatagramChannel) k.channel();</span><br><span class="line">                        datagramChannelClient.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//先将buffer清除，防止数据混合</span></span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        <span class="comment">//接收数据到buffer,返回代表客户端的SocketAddress对象</span></span><br><span class="line">                        SocketAddress socketAddressClient = datagramChannelClient.receive(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//读取数据</span></span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        <span class="comment">//判空操作</span></span><br><span class="line">                        <span class="keyword">if</span>(byteBuffer.remaining() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"datagramChannelClient channel is null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录接收的字节总数</span></span><br><span class="line">                        number += byteBuffer.remaining();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;byteBuffer.remaining();i++)&#123;</span><br><span class="line">                            bytes[i] = byteBuffer.get(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String in = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br><span class="line">                        System.out.println(number + <span class="string">"::: Server 接收到："</span> + in );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//返回响应</span></span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        byteBuffer.put(<span class="string">"welcome !!!"</span>.getBytes());</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        datagramChannelClient.send(byteBuffer,socketAddressClient);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keys.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOUDPServer(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UDP Client</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUDPClient</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录每个client发送的字节数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOUDPClient</span><span class="params">(String host,<span class="keyword">int</span> port,<span class="keyword">int</span> threadNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadNum;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//构建客户端channel</span></span><br><span class="line">            DatagramChannel datagramChannelClient = DatagramChannel.open();</span><br><span class="line">            SocketAddress serverSocketAddress = <span class="keyword">new</span> InetSocketAddress(host,port);</span><br><span class="line">            datagramChannelClient.connect(serverSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建发送数据包</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.put(<span class="string">"testClient"</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判空操作</span></span><br><span class="line">            <span class="keyword">if</span>(byteBuffer.remaining() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"client data is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送数据</span></span><br><span class="line">            <span class="keyword">int</span> sendNum = datagramChannelClient.send(byteBuffer,serverSocketAddress);</span><br><span class="line">            number += sendNum;</span><br><span class="line">            System.out.println(<span class="string">"客户端发送的字节数："</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接收服务器响应</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            datagramChannelClient.receive(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取服务器响应</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;byteBuffer.remaining();i++)&#123;</span><br><span class="line">                bytes[i] = byteBuffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">            String res = <span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"client 接收 Server 响应 ： "</span> + res);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOUDPClient(<span class="string">"127.0.0.1"</span>,<span class="number">1024</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServerSocketChannel-和-SocketChannel"><a href="#ServerSocketChannel-和-SocketChannel" class="headerlink" title="ServerSocketChannel 和 SocketChannel"></a>ServerSocketChannel 和 SocketChannel</h3><ul><li>TCP Server</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOTCPServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立 ServerSocketChannel</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//设置成非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//获取ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将ServerSocketChannel注册到Selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">"TCP Server 正在监听端口： "</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//进行事件监听轮询</span></span><br><span class="line">                <span class="keyword">int</span> selectNum = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (selectNum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取选择键的迭代器</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey selectionKey = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断选择键事件类型，进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">//通过选择键获取ServerSocketChannel</span></span><br><span class="line">                        ServerSocketChannel serverSocketChannela = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//通过ServerSocketChannel 获取相应的 SocketChannel，建立连接: 将Client的SocketChannel注册到</span></span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannela.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">                        System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                + socketChannel.socket().getPort() + <span class="string">" 连接上了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//创建接收数据的容器</span></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//从SocketChannel中读取数据到ByteBuffer</span></span><br><span class="line">                            socketChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="comment">//                          客户端异常断开连接</span></span><br><span class="line">                            System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                    + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + socketChannel.socket().getPort() + <span class="string">" 已断开连接"</span>);</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = byteBuffer.array();</span><br><span class="line">                        String msg = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (msg.equals(<span class="string">"退出"</span>)) &#123;</span><br><span class="line"><span class="comment">//                          客户端主动断开连接</span></span><br><span class="line">                            System.out.println(<span class="string">"客户端："</span></span><br><span class="line">                                    + socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + socketChannel.socket().getPort() + <span class="string">" 已断开连接"</span>);</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(</span><br><span class="line">                                socketChannel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                        + socketChannel.socket().getPort() + <span class="string">"："</span> + msg);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line"><span class="comment">//                          System.out.println("可写");</span></span><br><span class="line">                            CharsetEncoder encoder = Charset.forName(<span class="string">"UTF-8"</span>).newEncoder();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                socketChannel.write(encoder.encode(CharBuffer.wrap(<span class="string">"server receive your message "</span>)));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                                System.out.println(<span class="string">"写入io错误"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NIOTCPServer niotcpServer = <span class="keyword">new</span> NIOTCPServer(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TCP  Client</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.learn.nio.channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CharsetDecoder decoder = Charset.forName(<span class="string">"UTF-8"</span>).newDecoder();</span><br><span class="line">    <span class="keyword">private</span> CharsetEncoder encoder = Charset.forName(<span class="string">"UTF-8"</span>).newEncoder();</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SelectionKey clientKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOTCPClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socket = SocketChannel.open();</span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            clientKey = socket.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            InetSocketAddress ip = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">1024</span>);</span><br><span class="line">            socket.connect(ip);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select(<span class="number">1</span>);</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                            channel.finishConnect();</span><br><span class="line">                        &#125;</span><br><span class="line">                        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        System.out.println(<span class="string">"连接服务器端成功！"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"与服务器："</span></span><br><span class="line">                                    + channel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                    + channel.socket().getPort() + <span class="string">"的连接已断开"</span>);</span><br><span class="line">                            channel.close();</span><br><span class="line">                            <span class="keyword">continue</span>;<span class="comment">//这一句是为了让你看到打印信息</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        String msg = decoder.decode(buffer).toString();</span><br><span class="line">                        System.out.println(</span><br><span class="line">                                channel.socket().getInetAddress().getHostName() + <span class="string">":"</span></span><br><span class="line">                                        + channel.socket().getPort() + <span class="string">"："</span> + msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel client = (SocketChannel) clientKey.channel();</span><br><span class="line">            client.write(encoder.encode(CharBuffer.wrap(msg)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发送信息失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NIOTCPClient client = <span class="keyword">new</span> NIOTCPClient();</span><br><span class="line">        client.start();</span><br><span class="line">        BufferedReader sin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String readline;</span><br><span class="line">            <span class="keyword">while</span>((readline = sin.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(readline.equals(<span class="string">"bye"</span>))&#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                client.send(readline);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><h2 id="Selector介绍"><a href="#Selector介绍" class="headerlink" title="Selector介绍"></a>Selector介绍</h2><p>Selector一般称为选择器,当然也可以翻译为多路复用器。它是Java NIO核心组件中的一个,用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channel,也就是可以管理多个网络链接。 使用Selector的好处在于:使用更少的线程来就可以来处理通道了,相比使用多个线程,避免了线程上下文切换带来的开销。</p><p>并不是所有的Channel，都是可以被Selector 复用的。比如：FileChannel就不能被选择器复用。</p><p>判断一个Channel 能被Selector 复用，有一个前提：判断他是否继承了一个抽象类SelectableChannel。如果继承了SelectableChannel，则可以被复用，否则不能。</p><p><strong>每个Channel的继承定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ScatteringByteChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">ServerSocketChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NetworkChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">DatagramChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">GatheringByteChannel</span>, <span class="title">MulticastChannel</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">SocketChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>,</span></span><br><span class="line"><span class="class">    <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span></span></span><br></pre></td></tr></table></figure><p><strong>上述继承关系，跟socket有关的类都继承自AbstractSelectableChannel，而AbstractSelectableChannel又继承自SelectableChannel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectableChannel</span></span></span><br></pre></td></tr></table></figure><p>SelectableChannel类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有socket通道，都继承了SelectableChannel类都是可选择的，包括从管道(Pipe)对象的中获得的通道。而FileChannel类，没有继承SelectableChannel，因此是不是可选通道。</p><p>通道和选择器不是一对一的关系。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</p><p>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p><h2 id="Selector基本使用"><a href="#Selector基本使用" class="headerlink" title="Selector基本使用"></a>Selector基本使用</h2><ol><li>创建Selector</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ol start="2"><li>Channel设置为非阻塞的，注册channel到Selector,并设置感兴趣的监听事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>register() 方法的第二个参数。这是一个“ interest集合 ”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li><p>Connect</p></li><li><p>Accept</p></li><li><p>Read</p></li><li><p>Write</p></li></ul><p>通道触发了一个事件意思是该事件已经就绪。比如：<br>某个Channel成功连接到另一个服务器称为”连接就绪”。一个ServerSocketChannel准备好接收新进入的连接称为”接收就绪”。一个有数据可读的通道可以说是”读就绪”。等待写数据的通道可以说是”写就绪”。<br>这四种事件用SelectionKey的四个常量来表示： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE</p><p>如果你对不止一种事件感兴趣，使用或运算符即可，如下： int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">key.attachment(); <span class="comment">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span></span><br><span class="line">key.channel(); <span class="comment">// 返回该SelectionKey对应的channel。</span></span><br><span class="line">key.selector(); <span class="comment">// 返回该SelectionKey对应的Selector。</span></span><br><span class="line">key.interestOps(); <span class="comment">//返回代表需要Selector监控的IO操作的bit mask</span></span><br><span class="line">key.readyOps(); <span class="comment">// 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span></span><br></pre></td></tr></table></figure><h3 id="key-interestOps-的使用"><a href="#key-interestOps-的使用" class="headerlink" title="key.interestOps()的使用"></a>key.interestOps()的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="key-readyOps-的使用"><a href="#key-readyOps-的使用" class="headerlink" title="key.readyOps()的使用"></a>key.readyOps()的使用</h3><p>ready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建ready集合的方法</span></span><br><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line"><span class="comment">//检查这些操作是否就绪的方法</span></span><br><span class="line"><span class="keyword">boolean</span> key.isAcceptable();<span class="comment">//是否可读，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isWritable()：<span class="comment">//是否可写，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isConnectable()：<span class="comment">//是否可连接，是返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> key.isAcceptable()：<span class="comment">//是否可接收，是返回 true</span></span><br></pre></td></tr></table></figure><h3 id="SelectionKey附加信息"><a href="#SelectionKey附加信息" class="headerlink" title="SelectionKey附加信息"></a>SelectionKey附加信息</h3><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">key.attach(theObject);</span><br><span class="line">Object attachedObj = key.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="select-方法的使用"><a href="#select-方法的使用" class="headerlink" title="select()方法的使用"></a>select()方法的使用</h3><p><strong>Selector维护的三种类型SelectionKey集合:</strong>  </p><ul><li><p>已注册的键的集合(Registered key set)</p></li><li><p>已选择的键的集合(Selected key set)</p></li><li><p>已取消的键的集合(Cancelled key set)</p></li></ul><p>在刚初始化的Selector对象中，这三个集合都是空的。 通过Selector的select（）方法可以选择已经准备就绪的通道 （这些通道包含你感兴趣的的事件）。比如: 对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。</p><p>下面是Selector几个重载的select()方法：</p><ul><li><p>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</p></li><li><p>int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。</p></li><li><p>int selectNow()：非阻塞，只要有通道就绪就立刻返回。</p></li></ul><p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。</p><p><strong>停止选择的方法：</strong>  </p><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下两种方式可以唤醒在select（）方法中阻塞的线程。</p><ul><li><p>wakeup()方法 ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</p></li><li><p>close()方法 ：通过close（）方法关闭Selector 该方法使得任何一个在选择操作中阻塞的线程都被唤醒(类似wakeup()),同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p></li></ul><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">1024</span>));</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> readyNum = selector.select();</span><br><span class="line">    <span class="keyword">if</span> (readyNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = it.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 接受连接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 通道可读</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 通道可写</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA/Java%20NIO%E4%B9%8BSelector(%E9%80%89%E6%8B%A9%E5%99%A8).md" target="_blank" rel="noopener">https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA/Java%20NIO%E4%B9%8BSelector(%E9%80%89%E6%8B%A9%E5%99%A8).md</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode系列</title>
      <link href="/2019/10/02/LeetCode/"/>
      <url>/2019/10/02/LeetCode/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode1"><a href="#leetcode1" class="headerlink" title="leetcode1"></a>leetcode1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span></span><br><span class="line"><span class="comment">     * You may assume that each input would have exactly one solution, and you may not use the same element twice.</span></span><br><span class="line"><span class="comment">     * Example:</span></span><br><span class="line"><span class="comment">     * Given nums = [2, 7, 11, 15], target = 9,</span></span><br><span class="line"><span class="comment">     * Because nums[0] + nums[1] = 2 + 7 = 9,</span></span><br><span class="line"><span class="comment">     * return [0, 1].</span></span><br><span class="line"><span class="comment">     * ————————————————</span></span><br><span class="line"><span class="comment">     * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定 nums = [2, 7, 11, 15], target = 9</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为 nums[0] + nums[1] = 2 + 7 = 9</span></span><br><span class="line"><span class="comment">     * 所以返回 [0, 1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/two-sum</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *方法1.从第一个数开始，用 target-此数 ，得到数值与接下来的数值进行对比，如果有则返回，如果没有；则继续此操作。</span></span><br><span class="line"><span class="comment">     * 使用此种方法，时间复杂度O(n²) ，空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 方法2.设置一个Map,键设置为数值 值设置为下标。</span></span><br><span class="line"><span class="comment">     * 从第一个数1开始，用 target-数1 ，得到 数值2</span></span><br><span class="line"><span class="comment">     * 查看Map中是否有此键，如果有则返回;如果没有，将数1的值作为键，下标作为值 存入Map.</span></span><br><span class="line"><span class="comment">     * 时间复杂度O(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode2"><a href="#leetcode2" class="headerlink" title="leetcode2"></a>leetcode2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span></span><br><span class="line"><span class="comment">     * 输出：7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="comment">     * 原因：342 + 465 = 807</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/add-two-numbers</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">            ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode current = dummy;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> dig = l1.val + l2.val + carry;</span><br><span class="line">                <span class="keyword">int</span> val = dig%<span class="number">10</span>;</span><br><span class="line">                carry = dig/<span class="number">10</span>;</span><br><span class="line">                ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current.next = newNode;</span><br><span class="line">                current = current.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = (l1.val +carry)%<span class="number">10</span>;</span><br><span class="line">                carry = (l1.val+carry)/<span class="number">10</span>;</span><br><span class="line">                current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current = current.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = (l2.val + carry)%<span class="number">10</span>;</span><br><span class="line">                carry = (l2.val + carry)/<span class="number">10</span>;</span><br><span class="line">                current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                current = current.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>) current.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode3"><a href="#leetcode3" class="headerlink" title="leetcode3"></a>leetcode3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "abcabcbb"</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "bbbbb"</span></span><br><span class="line"><span class="comment">     * 输出: 1</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "pwwkew"</span></span><br><span class="line"><span class="comment">     * 输出: 3</span></span><br><span class="line"><span class="comment">     * 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     *      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 map 数据结构存储（k,v）key值为字符，value值字符位置 +1 ，+1 表示从字符位置 后一个才开始不重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>, start = <span class="number">0</span>; end &lt; n; end++) &#123;</span><br><span class="line">            <span class="keyword">char</span> alpha = s.charAt(end);</span><br><span class="line">            <span class="comment">//如果map中包含end位置的字符，则重置start</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(alpha)) &#123;</span><br><span class="line">                start = Math.max(map.get(alpha), start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进行比较更新，得到此时最大子串的长度</span></span><br><span class="line">            ans = Math.max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将 end 位置的字符加入map</span></span><br><span class="line">            map.put(s.charAt(end), end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode7"><a href="#leetcode7" class="headerlink" title="leetcode7"></a>leetcode7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode7</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 123</span></span><br><span class="line"><span class="comment">     * 输出: 321</span></span><br><span class="line"><span class="comment">     *  示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: -123</span></span><br><span class="line"><span class="comment">     * 输出: -321</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 120</span></span><br><span class="line"><span class="comment">     * 输出: 21</span></span><br><span class="line"><span class="comment">     * 注意:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/reverse-integer</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  32位int取值范围[-2^31,2^31-1]</span></span><br><span class="line"><span class="comment">     *将数字逆转可以通过 newNum = res*10 + x%10 关系式解决，正负数都符合此式</span></span><br><span class="line"><span class="comment">     * 不过还需处理数值溢出的情况，如果将得到的新值，按算式返回得到原值，如果与原值不等，则溢出，返回0；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> newNum = res*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((newNum - x%<span class="number">10</span>)/<span class="number">10</span> != res) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = newNum;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode9"><a href="#leetcode9" class="headerlink" title="leetcode9"></a>leetcode9</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 121</span></span><br><span class="line"><span class="comment">     * 输出: true</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: -121</span></span><br><span class="line"><span class="comment">     * 输出: false</span></span><br><span class="line"><span class="comment">     * 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">     * 示例 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 10</span></span><br><span class="line"><span class="comment">     * 输出: false</span></span><br><span class="line"><span class="comment">     * 解释: 从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/palindrome-number</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果数值为负数，则一定不相等，直接返回false</span></span><br><span class="line"><span class="comment">     * 如果为正数，将此数通过倒序后，与原数比较，返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> src = x;</span><br><span class="line">        <span class="keyword">int</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            newNum = newNum*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src == newNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode14"><a href="#leetcode14" class="headerlink" title="leetcode14"></a>leetcode14</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode14</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果不存在公共前缀，返回空字符串 ""。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: ["flower","flow","flight"]</span></span><br><span class="line"><span class="comment">     * 输出: "fl"</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: ["dog","racecar","car"]</span></span><br><span class="line"><span class="comment">     * 输出: ""</span></span><br><span class="line"><span class="comment">     * 解释: 输入不存在公共前缀。</span></span><br><span class="line"><span class="comment">     * 说明:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所有输入只包含小写字母 a-z 。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/longest-common-prefix</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中最长公共前缀，需要两两相比较，先找出之间的最大公共部分，</span></span><br><span class="line"><span class="comment">     * 然后在用此公共部分去跟下一个字符串比较。如此反复。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程基础</title>
      <link href="/2019/09/20/JUC01/"/>
      <url>/2019/09/20/JUC01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty自定义解码器</title>
      <link href="/2019/09/08/netty01/"/>
      <url>/2019/09/08/netty01/</url>
      
        <content type="html"><![CDATA[<h2 id="netty自定义解码器"><a href="#netty自定义解码器" class="headerlink" title="netty自定义解码器"></a>netty自定义解码器</h2><p>实现自定义开始结束标志符，实现TCP粘包，拆包。</p><p><strong>使用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MyDecoder(开始标志符,结束标志符);</span><br></pre></td></tr></table></figure><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDecoder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDecoder</span><span class="params">(<span class="keyword">byte</span> start,<span class="keyword">byte</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MyDecoder.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"进入Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start != end)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = in.readableBytes();</span><br><span class="line">            <span class="keyword">int</span> start_flag = in.indexOf(<span class="number">0</span>,length,start);</span><br><span class="line">            <span class="keyword">int</span> end_flag = in.indexOf(<span class="number">0</span>,length,end);</span><br><span class="line">            logger.info(<span class="string">"start_flag: "</span>+ start_flag + <span class="string">";  end_flag: "</span> + end_flag);</span><br><span class="line">            <span class="keyword">if</span>( (start_flag &gt;= <span class="number">0</span> &amp;&amp; end_flag &gt;= <span class="number">0</span>) &amp;&amp; ((end_flag - start_flag) &gt; <span class="number">0</span>) )&#123;</span><br><span class="line">                out.add(in.copy(start_flag,end_flag - start_flag + <span class="number">1</span>));</span><br><span class="line">                in.skipBytes(in.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = in.readableBytes();</span><br><span class="line">            <span class="keyword">int</span> start_flag = in.indexOf(<span class="number">0</span>,length,start);</span><br><span class="line">            <span class="keyword">if</span>(start_flag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> end_flag = in.indexOf(start_flag+<span class="number">1</span>,length-start_flag,end);</span><br><span class="line">            <span class="keyword">if</span>(end_flag &gt; start_flag)&#123;</span><br><span class="line">                logger.info(<span class="string">"start_flag: "</span>+ start_flag + <span class="string">";  end_flag: "</span> + end_flag);</span><br><span class="line">                out.add(in.copy(start_flag,end_flag - start_flag + <span class="number">1</span>));</span><br><span class="line">                in.skipBytes(in.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"退出Decoder的ByteBuf.readableBytes(): "</span> + in.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装TDengine JDBC工具</title>
      <link href="/2019/09/08/tdengine01/"/>
      <url>/2019/09/08/tdengine01/</url>
      
        <content type="html"><![CDATA[<h4 id="封装的TDengine-JDBC-工具类"><a href="#封装的TDengine-JDBC-工具类" class="headerlink" title="封装的TDengine JDBC 工具类"></a>封装的TDengine JDBC 工具类</h4><p><strong>代码如下：</strong>  </p><p><strong>配置加载：</strong></p><p>配置文件tsdb.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taos.host=x.x.x.x</span><br><span class="line">taos.username=root</span><br><span class="line">taos.password=taosdata</span><br><span class="line">taos.port=0</span><br><span class="line">taos.dbname=iot</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSDBconfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_PROTOCAL = <span class="string">"jdbc:TAOS://"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String dbName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//在static方法中，通过类加载器得到配置文件</span></span><br><span class="line">            InputStream in = TSDBconfig.class.getClassLoader().getResourceAsStream(<span class="string">"tsdb.properties"</span>);</span><br><span class="line">            prop.load(in);     <span class="comment">///加载属性列表</span></span><br><span class="line">            host = prop.getProperty(<span class="string">"taos.host"</span>);</span><br><span class="line">            username  = prop.getProperty(<span class="string">"taos.username"</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">"taos.password"</span>);</span><br><span class="line">            port = Integer.parseInt(prop.getProperty(<span class="string">"taos.port"</span>));</span><br><span class="line">            dbName = prop.getProperty(<span class="string">"taos.dbname"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jdbcUrl = String.format(<span class="string">"%s%s:%d/%s?user=%s&amp;password=%s"</span>, JDBC_PROTOCAL, host, port, dbName,</span><br><span class="line">                username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工具类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.beans.BeanMap;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.ljy.iot.util.TDengineUtil.getFieldNameBySetter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTDengineUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MyTDengineUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSDB_DRIVER = <span class="string">"com.taosdata.jdbc.TSDBDriver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(TSDB_DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Connection connection;</span><br><span class="line">    <span class="comment">//是否开启数据库列名下划线转驼峰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseColumnHumpToLine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTDengineUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTDengineUtil</span><span class="params">(String jdbcUrl, <span class="keyword">boolean</span> databaseColumnHumpToLine)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = DriverManager.getConnection(jdbcUrl);</span><br><span class="line">        <span class="keyword">this</span>.databaseColumnHumpToLine = databaseColumnHumpToLine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getOne</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Method[] setMethods = getSetMethods(clazz);</span><br><span class="line">        ResultSet resultSet = connection.createStatement().executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        resultSet.next();</span><br><span class="line">        <span class="keyword">return</span> resultSetToObject(resultSet,setMethods,clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getList</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Method[] setterMethods = getSetMethods(clazz);</span><br><span class="line">        ResultSet resultSet = connection.createStatement().executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(resultSetToObject(resultSet, setterMethods, clazz));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(String tableName,Object o)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = o.getClass();</span><br><span class="line">        Map&lt;String,Object&gt; map = BeanMap.create(o);</span><br><span class="line">        String sql = createInsertSql(tableName,map);</span><br><span class="line">        <span class="keyword">return</span> connection.createStatement().execute(sql);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createInsertSql</span><span class="params">(String tableName,Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        buffer.append(<span class="string">"INSERT INTO "</span>).append(tableName).append(<span class="string">" ("</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Object&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        StringBuilder keys = <span class="keyword">new</span> StringBuilder(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder value = <span class="keyword">new</span> StringBuilder(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; entry : set)&#123;</span><br><span class="line">            keys.append(humpToLine(entry.getKey())).append(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue().getClass().equals(Date.class))&#123;</span><br><span class="line">                    Date d = (Date)entry.getValue();</span><br><span class="line">                    value.append(d.getTime()).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    value.append(<span class="string">"'"</span>).append(entry.getValue()).append(<span class="string">"'"</span>).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys.deleteCharAt(keys.length()-<span class="number">1</span>);</span><br><span class="line">        value.deleteCharAt(value.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        buffer.append(keys).append(<span class="string">") VALUES( "</span>).append(value).append(<span class="string">")"</span>);</span><br><span class="line">        buffer.append(<span class="string">";"</span>);</span><br><span class="line">        System.out.println( buffer.toString());</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">resultSetToObject</span><span class="params">(ResultSet resultSet, Method[] setterMethods, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = clazz.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"请检查类"</span> + clazz.getCanonicalName() + <span class="string">"是否有无参构造方法"</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : setterMethods)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                String fieldName = getFieldNameBySetter(method);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//因为标准的setter方法只会有一个参数，所以取一个就行了</span></span><br><span class="line">                Class getParamClass = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获得查询的结果</span></span><br><span class="line">                Object resultObject;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//是否启用驼峰转下划线规则获得数据库字段名</span></span><br><span class="line">                <span class="keyword">if</span> (databaseColumnHumpToLine)</span><br><span class="line">                &#123;</span><br><span class="line">                    resultObject = resultSet.getObject(humpToLine(fieldName));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    resultObject = resultSet.getObject(fieldName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果实体类的类型是String类型，那么无论x数据库类型是什么，都调用其toString方法获取值</span></span><br><span class="line">                <span class="keyword">if</span> (getParamClass.equals(String.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    method.invoke(result, resultObject.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (getParamClass.equals(Date.class) &amp;&amp; resultObject.getClass().equals(Long.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    method.invoke(result, <span class="keyword">new</span> Date((Long) resultObject));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        method.invoke(result, resultObject);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (IllegalArgumentException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//对象字段与数据库类型(通过jdbc读取到的)不一致的情况下，将尝试强制转型</span></span><br><span class="line">                        method.invoke(result, getParamClass.cast(resultObject));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ignored)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所有的转型都失败了，则使用默认值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFieldNameBySetMethod</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toLowerCaseFirstOne(method.getName().substring(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首字母转小写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toLowerCaseFirstOne</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toLowerCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] getSetMethods(Class clazz)&#123;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        Method[] setMethods = <span class="keyword">new</span> Method[methods.length/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.getName().startsWith(<span class="string">"set"</span>))&#123;</span><br><span class="line">                setMethods[i] = m;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern humpPattern = Pattern.compile(<span class="string">"[A-Z]"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驼峰转下划线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">humpToLine</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Matcher matcher = humpPattern.matcher(str);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            matcher.appendReplacement(sb, <span class="string">"_"</span> + matcher.group(<span class="number">0</span>).toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.iot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ljy.iot.config.TSDBconfig;</span><br><span class="line"><span class="keyword">import</span> com.ljy.iot.entity.TestEntity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSDB_DRIVER = <span class="string">"com.taosdata.jdbc.TSDBDriver"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(TSDB_DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        MyTDengineUtil tDengineUtil = <span class="keyword">new</span> MyTDengineUtil(<span class="string">"jdbc:TAOS://49.235.215.208:0/iot?user=root&amp;password=taosdata"</span>,<span class="keyword">true</span>);</span><br><span class="line">        TestEntity testEntity = <span class="keyword">new</span> TestEntity();</span><br><span class="line">        testEntity.setMyTs(<span class="string">"2019-09-20 10:05:22"</span>);</span><br><span class="line">        testEntity.setMyId(<span class="number">1</span>);</span><br><span class="line">        testEntity.setMyAddress(<span class="string">"test001"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果sql是select查询语句，返回值为true；</span></span><br><span class="line"><span class="comment">         * 否则是false；</span></span><br><span class="line"><span class="comment">         * 如果语句本身错误会抛出异常。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> isSussess = tDengineUtil.insert(<span class="string">"test"</span>,testEntity);</span><br><span class="line">        List&lt;TestEntity&gt; testEntity1 = tDengineUtil.getList(<span class="string">" select * from test where my_ts &gt;= '2019-09-20 10:05:20';"</span>,TestEntity.class);</span><br><span class="line">        System.out.println(testEntity1.get(<span class="number">1</span>).getMyAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDengine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump命令详解</title>
      <link href="/2019/09/07/linux03/"/>
      <url>/2019/09/07/linux03/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2019/09/07/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2019/09/07/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="IP协议学习"><a href="#IP协议学习" class="headerlink" title="IP协议学习"></a>IP协议学习</h2><h3 id="1、-IP协议功能"><a href="#1、-IP协议功能" class="headerlink" title="1、 IP协议功能"></a>1、 IP协议功能</h3><ul><li><p>寻址和路由（根据对方的IP地址，寻找最佳路径传输信息）</p></li><li><p>传递服务  </p><ol><li><p><strong>不可靠：</strong> IP仅提供最好的传输服务，不能保证IP数据报能成功到达目的地。任何要求的可靠性必须由上层来提供（如：tcp）</p></li><li><p><strong>无连接：</strong> IP并不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP数据报可以不按发送顺序接收。</p></li></ol></li><li><p>数据包的分片和重组</p></li></ul><h3 id="2、-IP地址分类"><a href="#2、-IP地址分类" class="headerlink" title="2、 IP地址分类"></a>2、 IP地址分类</h3><p>在Internet（ipv4）中,ip地址是一个32位的二进制地址，为了方便记忆，将它们分为4组，每组8位，由小数点分开，用四个字节来表示，而且每个字节数值范围是 0~255 。</p><table><thead><tr><th align="left">类别</th><th align="left">网段</th><th align="left">区分</th><th align="left">地址范围</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">0~127</td><td align="left">二进制首位为0</td><td align="left">1.0.0.1~127.255.255.254</td></tr><tr><td align="left">B</td><td align="left">128~191</td><td align="left">二进制首位为10</td><td align="left">172.16.0.0~172.31.255.254</td></tr><tr><td align="left">C</td><td align="left">192~223</td><td align="left">二进制首位为110</td><td align="left">192.168.0.1~192.168.255.254</td></tr><tr><td align="left">D</td><td align="left">224~239</td><td align="left">二进制首位为1110</td><td align="left">224.0.0.0~239.255.255.254</td></tr><tr><td align="left">E</td><td align="left">240~255</td><td align="left">二进制首位为1111</td><td align="left">240.0.0.0~255.255.255.255</td></tr></tbody></table><ul><li><p>(1) A类地址，一个A类地址是由一个字节的网络地址和三个字节的主机地址组成，网络地址的最高位必须是“0”</p></li><li><p>(2) B类地址，一个B类地址是由两个字节的网络地址和两个字节的主机地址组成，网络地址的最高位必须是“10”</p></li><li><p>(3) C类地址，一个C类地址是由三个字节的网络地址和一个字节的主机地址组成，网络地址的最高位必须是“110”</p></li><li><p>(4) D类地址，不区分网络地址和主机地址，D类地址是一种组播地址，D类地址的第一个字节以1110开始。目前D类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p></li><li><p>(5) E类地址，不区分网络地址和主机地址，E类地址是保留地址用于以后使用。E类地址的第一个字节以1111开始。</p></li></ul><h4 id="2-1-特殊IP地址"><a href="#2-1-特殊IP地址" class="headerlink" title="2.1 特殊IP地址"></a>2.1 特殊IP地址</h4><ol><li><p><strong>私有地址</strong>  </p><p>A类地址的私有地址是：10.0.0.0~10.255.255.255</p><p>B类地址的私有地址是：172.16.0.0~172.31.255.255.255</p><p>C类地址的私有地址是：192.168.0.0~192.168.255.255</p><p>这些地址不会被Internet分配，他们再Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以和 Internet通讯（NAT技术）。</p><blockquote><p>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术.</p></blockquote></li><li><p><strong>环回地址</strong><br>1、功能：</p><p>（1）本机网络测试。通信设备发出的数据包又返回（环回）到本设备上，用于测试设备能否正常使用以及节点是否有效。</p><p>（2）进程间通信。</p><p>2、IP地址为127.X.X.X，一般使用127.0.0.1。</p><p>3、发送到这个地址的数据包不会出现在网络实体中，而是送给系统的环回接口。</p><p>4、环回地址使得A类地址少了一个网络号。</p></li></ol><blockquote><p>【小技巧】 　　<br>Ping 127.0.0.1,如果反馈信息失败,说明TCP/IP协议栈有错,必须重新安装TCP/IP协议。如果成功,ping本机IP地址,如果反馈信息失败,说明你的网卡不能和IP协议栈进行通信。 　</p></blockquote><blockquote><p>但是直接ping 0.0.0.0是不行的，他在IPV4中表示的是无效的目标地址，但是在服务器端它表示本机上的所有IPV4地址.</p></blockquote><ol start="3"><li><p><strong>广播地址</strong></p><p>TCP/IP规定，主机号全为”1”的网络地址用于广播之用（二进制地址中主机地址全为1，即 10进制的255），叫做广播地址。所谓广播，指同时向同一子网所有主机发送报文。</p></li></ol><h4 id="2-2-子网掩码"><a href="#2-2-子网掩码" class="headerlink" title="2.2 子网掩码"></a>2.2 子网掩码</h4><p>子网掩码(subnet mask)又叫网络掩码，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p><ul><li><p>对于A类地址来说，默认的子网掩码是255.0.0.0；</p></li><li><p>对于B类地址来说默认的子网掩码是255.255.0.0；</p></li><li><p>对于C类地址来说默认的子网掩码是255.255.255.0。</p></li></ul><h3 id="3、IP报文格式"><a href="#3、IP报文格式" class="headerlink" title="3、IP报文格式"></a>3、IP报文格式</h3><p><img src="//qx-ljy.cn/2019/09/07/网络层/ip1.png" alt></p><ul><li><p>版本号：4个bit，用来标识IP版本号。这个4位字段的值设置为二进制的0100表示IPv4，设置为0110表示IPv6。目前使用的IP协议版本号是4。</p></li><li><p>首部长度：4个bit。标识包括选项在内的IP头部字段的长度。由于它是一个 四比特 字段，所以IP首部最长为60个字节，最少为20字节（没有任何选择项，此字段值为5）。</p></li><li><p>服务类型：8个bit。服务类型字段被划分成两个子字段：3bit的优先级字段和4bit TOS字段，最后一位置为0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小花费。4bit中只能将其中一个bit位置1。如果4个bit均为0，则代表一般服务。</p></li><li><p>总长度：16个bit。接收者用IP数据报总长度减去IP报头长度就可以确定数据报中数据内容起始位置和长度。IP数据报最长可达65535字节。</p></li><li><p>标识：16个bit。唯一的标识主机发送的每一份数据报。接收方根据分片中的标识字段是否相同来判断这些分片是否是同一个数据报的分片，从而进行分片的重组。通常每发送一份报文它的值就会加1。</p></li><li><p>标志：3个bit。用于标识数据报是否分片。第1位没有使用，第2位是不分段（DF）位。当DF位被设置为1时，表示路由器不能对数据包进行分段处理。如果数据包由于不能分段而未能被转发，那么路由器将丢弃该数据包并向源发送ICMP不可达。第3位是分段（MF）位。当路由器对数据包进行分段时，除了最后一个分段的MF位被设置为0外，其他的分段的MF位均设置为1，以便接收者直到收到MF位为0的分片为止。</p></li><li><p>片偏移：13个bit。在接收方进行数据报重组时用来标识分片的顺序。用于指明分段起始点相对于报头起始点的偏移量。由于分段到达时可能错序，所以片偏移字段可以使接收者按照正确的顺序重组数据包。当数据包的长度超过它所要去的那个数据链路的MTU时，路由器要将它分片。数据包中的数据将被分成小片，每一片被封装在独立的数据包中。接收端使用标识符，分段偏移以及标记域的MF位来进行重组。</p></li><li><p>生存时间:8个bit。TTL域防止丢失的数据包在无休止的传播。该域包含一个8位整数，此数由产生数据包的主机设定。TTL值设置了数据报可以经过的最多的路由器数。TTL的初始值由源主机设置（通常为32或64），每经过一个处理它的路由器，TTL值减1。如果一台路由器将TTL减至0，它将丢弃该数据包并发送一个ICMP超时消息给数据包的源地址。</p></li><li><p>协议：8个bit。用来标识是哪个协议向IP传送数据。ICMP为1，IGMP为2，TCP为6，UDP为17，GRE为47，ESP为50。</p></li><li><p>首部检验和：根据IP首部计算的校验和码。</p></li><li><p>源地址：IP报文发送端的IP地址</p></li><li><p>目的地址：IP报文接收端的IP地址</p></li><li><p>选项：是数据报中的一个可变长的可选信息。选项字段以32bit为界，不足时插入值为0的填充字节。保证IP首部始终是32bit的整数倍。</p></li></ul><h3 id="4、IP分片偏移"><a href="#4、IP分片偏移" class="headerlink" title="4、IP分片偏移"></a>4、IP分片偏移</h3><h4 id="4-1-分片原因"><a href="#4-1-分片原因" class="headerlink" title="4.1 分片原因"></a>4.1 分片原因</h4><p>以太网的MTU（最大传输单元）是1500字节，如果IP层有数据包要传，而长度超过了MTU，那么IP层就要对数据包进行分片操作。</p><h4 id="4-2-不同传输层协议的分片"><a href="#4-2-不同传输层协议的分片" class="headerlink" title="4.2 不同传输层协议的分片"></a>4.2 不同传输层协议的分片</h4><ol><li>TCP协议</li></ol><p>对于TCP协议来说尽量避免分片，因为当在IP层进行了分片后，如果其中的某片数据丢失，则需对整个数据报进行重传。因为IP层本身没有超时重传机制，当来自TCP报文段的某一片丢失后，TCP在超时后重发整个TCP报文段，该报文段对应于一份IP数据报，没有办法只重传数据报中的一个数据分片。</p><p>TCP协议可以避免分片，避免的机制是首先，TCP在建立连接时会进行3次握手，而在这3次握手中，客户端和服务端通常会协商一个值，那就是MSS（最长报文大小），用来表示本段所能接收的最大长度的报文段。MSS=MTU-TCP首部大小-IP首部大小，MTU值通过查询链路层得知。</p><p>当两端确认好MSS后进行通信，TCP层往IP层传输数据时，如果TCP层缓冲区的大小大于MSS，那么TCP层都会将其中的数据分组进行传输，这样就避免了在IP层进行分片。</p><ol start="3"><li>UDP协议  </li></ol><p>对于UDP而言，由于UDP是不需要保证可靠性的，没有超时和重传机制，这使得UDP很容易导致IP分片。</p><p>UDP协议分片会根据IP报文字段中的标识字段、标志字段、片偏移字段来解决。</p><p>对于每份IP数据报来说，其16位标识字段都包含一个唯一值。在数据报被分片时，这个值同时被复制到每个片中。用来识别分片的数据是否为同一个数据报文。</p><p>在IP首部中，我们看到有一个占了3位的标志字段，其中第1位是R作为保留字段未用；第2位分段是DF用来表示一个数据报是否允许在IP层被分片，DF=0时允许分片，DF=1时不允许分片；而第3位是MF更多分片字段，则是当数据报被分片时，让接收端知道在什么时候完成所有的分片组装，除了最后一片外，其他每个组成数据报的片都要把该比特置1。</p><p>而如果将其中的分段标志比特位置1，表示不允许IP层对数据报进行分片。例如当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特，路由器会丢弃数据报并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”）。</p><p>IP首部的13位片偏移字段表示IP分片再整个数据流中的位置，第一个数据报分片的偏移量置为0，而后续的分片偏移量则是根据网络的MTU大小设置，且必须为8的整数倍。</p><p><img src="//qx-ljy.cn/2019/09/07/网络层/ip2.png" alt></p><p>以上图中我们看到把一个报文长度为3800字节的报文分片为三个。他们每一个分片都会含有一个标识（IP地址 + 标识），到达目的地要对其所有的分片进行重新组装；<br>片偏移计算过程；首部分大体的内容是一样，因为都属于同一个数据报文！</p><h3 id="5、IP报文重组"><a href="#5、IP报文重组" class="headerlink" title="5、IP报文重组"></a>5、IP报文重组</h3><p>IP报文分片后进行重组，只能在目标主机进行重组。</p><p>IP报文分片重组时，采用了一组重组定时器，片重组的控制主要根据数据首部中的标识、标志、偏移字段进行重组。</p><p><strong>分片重组策略如下：</strong></p><p>（1）第一个分片的偏移值时0</p><p>（2）将第一个分片携带的数据长度除以8，结果就是第二个分片的偏移值</p><p>（3）将第一个和第二个分片携带数据的总长度除以8，结果就是第二个分片的偏移值</p><p>（4）继续以上过程。直到之后分片的MF标志位为0</p><h3 id="6、报文校验"><a href="#6、报文校验" class="headerlink" title="6、报文校验"></a>6、报文校验</h3><h4 id="6-1-IP报文校验和计算方式"><a href="#6-1-IP报文校验和计算方式" class="headerlink" title="6.1 IP报文校验和计算方式"></a>6.1 IP报文校验和计算方式</h4><p>（1）为了计算一份数据报的IP检验和，首先需要把检验和字段置为0</p><p>（2）对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16bit的字组成）</p><p>PS：路由器收到IP报文，然后转发之后，是需要对TTL（Time to Live）字段减一，那么这样的话IP报文校验和数值也需要进行相应改变</p><h4 id="6-2-IP报文不对数据校验原因"><a href="#6-2-IP报文不对数据校验原因" class="headerlink" title="6.2 IP报文不对数据校验原因"></a>6.2 IP报文不对数据校验原因</h4><p>上层传输层是端到端的协议，进行端到端的校验比进行点到点的校验开销小。</p><h4 id="6-3-IP报文对IP首部校验原因"><a href="#6-3-IP报文对IP首部校验原因" class="headerlink" title="6.3 IP报文对IP首部校验原因"></a>6.3 IP报文对IP首部校验原因</h4><p>IP首部属于IP层协议的内容，上层协议无法处理。</p><p>IP首部的部分字段在点到点的传递过程中是不断变化的，只能在每个中间点重新形成校验数据，在相邻点完成校验。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2019/08/05/java03/"/>
      <url>/2019/08/05/java03/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="/2019/08/04/java02/"/>
      <url>/2019/08/04/java02/</url>
      
        <content type="html"><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="//qx-ljy.cn/2019/08/04/java02/01.png" alt></p><p>JDK中定义了一套完整的异常处理机制，所有异常都是Throwable的子类，分为Error（致命错误，程序无法处理，只能人工介入）和 Exception（非致命异常）；Exception又分为checked异常（受检异常）和 unchecked异常（非受检异常）。  </p><p>checked异常是需要在程序中显示处理的异常，否则编译出错。<br>unchecked异常是运行时异常（数组越界，空指针异常等），它们都继承自RuntimeException，不需要程序进行显示的捕捉和处理。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>定式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  需要监控的可能会抛出异常的代码块</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">  出现异常后的处理代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  回收资源的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>  </p><p>如果try中的代码块发生异常，它将被抛出，在catch代码块中捕捉异常并用合理的方式来处理该异常。无论是否发生异常，发生什么异常，finally从句中的代码块一定会执行，除非在之前通过 <strong>System.exit(0);</strong> 语句终止程序；此外，<strong>finally是在return表达式执行结束后执行的</strong>。</p><p><strong>下面看这一段代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn_exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnException01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            temp = <span class="number">666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> z = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++x;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> ++y;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ++z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test01()); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"test02() value: "</span> + test02());</span><br><span class="line">        System.out.println(<span class="string">"x: "</span>+ x);</span><br><span class="line">        System.out.println(<span class="string">"y: "</span>+ y);</span><br><span class="line">        System.out.println(<span class="string">"z: "</span>+ z);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * test02() value: 101</span></span><br><span class="line"><span class="comment">         * x: 1</span></span><br><span class="line"><span class="comment">         * y: 10</span></span><br><span class="line"><span class="comment">         * z: 101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>  </p><ol><li><p>test01() ：</p><p>finally是在return表达式执行结束后执行的,即将要return的结果暂时存起来，待finally代码块执行完后再将暂存的返回值返回。</p></li><li><p>test02() :  </p><p>由于最后在finally代码块中执行了return操作，所以return返回值被刷新。</p></li></ol><h2 id="异常处理中代码规范"><a href="#异常处理中代码规范" class="headerlink" title="异常处理中代码规范"></a>异常处理中代码规范</h2><ol><li><p>在finally中 <strong>不建议执行赋值语句（对返回值进行改变等赋值）</strong> ， <strong>拒绝使用return语句</strong>，<strong>应该存放内存回收相关代码</strong>。</p></li><li><p>尽量减少try监控的代码块，尽量对单一过程监控，不要一个try中监控好几个会出现异常的代码块；要try在最贴近异常出现的代码位置。</p></li><li><p>如果try中有一个对象object指向了一块比较大的内存空间，而且之后不会在再使用，那么在finall中建议写上 <strong>object = null;</strong> 这样能提升内存使用效率。</p></li><li><p>try catch 中如果用到了 ArrayList，HashMap等集合对象，而且之后这些对象不会在使用，那么在finally建议调用 <strong>clear()</strong> 方法清空集合。</p></li><li><p>同理 IO读写，连接数据库，如果后序不再需要，则需要在finally中进行回收。  </p></li></ol><h2 id="throw，throws的区别"><a href="#throw，throws的区别" class="headerlink" title="throw，throws的区别"></a>throw，throws的区别</h2><ol><li><p>throws 出现在声明方法的位置，而 throw 出现在函数体内。</p></li><li><p>如果某个函数内部使用throw抛出异常，那么在声明函数时，一定要配套使用 throws ,否则出现错误。</p></li><li><p>在子类方法中不应该抛出比父类范围更广的异常。  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>自定义异常：定义一个派生于Exception的类，或者派生于Exception子类的类；<br>习惯上，定义的类应该包含两个构造器，一个默认的构造器；另一个是带有详细描述信息的构造器。</p><p><strong>代码如下：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn_exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 夕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnException03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"test MyException!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * learn_exception.MyException: test MyException!!!</span></span><br><span class="line"><span class="comment">     * at learn_exception.LearnException03.test(LearnException03.java:19)</span></span><br><span class="line"><span class="comment">     * at learn_exception.LearnException03.main(LearnException03.java:23)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux零拷贝技术</title>
      <link href="/2019/08/03/linux02/"/>
      <url>/2019/08/03/linux02/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>零复制（英语：Zero-copy；也译零拷贝）技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p></blockquote><p>零拷贝操作减少了在用户空间与内核空间之间切换模式的次数。</p><p><img src="//qx-ljy.cn/2019/08/03/linux02/01.png" alt></p><p><strong>传统的I/O操作进行了4次用户空间与内核空间的上下文切换，以及4次数据拷贝。其中4次数据拷贝中包括了2次DMA拷贝和2次CPU拷贝。</strong></p><h2 id="Linux-中零拷贝技术的实现方向"><a href="#Linux-中零拷贝技术的实现方向" class="headerlink" title="Linux 中零拷贝技术的实现方向"></a>Linux 中零拷贝技术的实现方向</h2><h3 id="一、直接-I-O"><a href="#一、直接-I-O" class="headerlink" title="一、直接 I/O"></a>一、直接 I/O</h3><p>对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，但是硬件上的数据不会拷贝一份到内核空间，而是直接拷贝至了用户空间，因此直接I/O不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</p><h3 id="二、copy-on-write-写时复制技术"><a href="#二、copy-on-write-写时复制技术" class="headerlink" title="二、copy-on-write(写时复制技术)"></a>二、copy-on-write(写时复制技术)</h3><p>在某些情况下，Linux操作系统的内核空间缓冲区可能被多个应用程序所共享，操作系统有可能会将用户空间缓冲区地址映射到内核空间缓存区中。当应用程序需要对共享的数据进行修改的时候，才需要真正地拷贝数据到应用程序的用户空间缓冲区中，并且对自己用户空间的缓冲区的数据进行修改不会影响到其他共享数据的应用程序。所以，如果应用程序不需要对数据进行任何修改的话，就不会存在数据从系统内核空间缓冲区拷贝到用户空间缓冲区的操作。</p><h3 id="三、数据传输不经过用户进程地址空间"><a href="#三、数据传输不经过用户进程地址空间" class="headerlink" title="三、数据传输不经过用户进程地址空间"></a>三、数据传输不经过用户进程地址空间</h3><p>在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 mmap()，sendfile() 以及 splice()。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/08/03/linux02/mmap.png" alt></p><p><strong>过程：</strong></p><ol><li><p>应用进程调用了 mmap() 之后，数据会先通过 DMA 拷贝到操作系统内核缓冲区中去。接着，应用进程跟操作系统共享这个缓冲区。这样，操作系统内核和应用进程存储空间就不需要再进行任何的数据拷贝操作。</p></li><li><p>应用进程再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态 。</p></li><li><p>socket缓冲区再把数据发到网卡。</p></li></ol><p>使用 mmap 并不一定能获得理想的数据传输性能。数据传输的过程中仍然需要一次 CPU 拷贝操作，而且映射操作也是一个开销很大的虚拟存储操作，这种操作需要通过更改页表以及冲刷 TLB （使得 TLB 的内容无效）来维持存储的一致性。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile()"></a>sendfile()</h4><p>为了简化用户接口，同时减少 CPU 的拷贝次数，Linux 在版本 2.1 中引入了 sendfile() 这个系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/08/03/linux02/sendfile.png" alt></p><p><strong>过程：</strong></p><ol><li><p>sendfile() 系统调用利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中。</p></li><li><p>然后数据被拷贝到与 socket 相关的内核缓冲区中去。</p></li><li><p>接下来，DMA 引擎将数据从内核 socket 缓冲区中拷贝到协议引擎中去。</p></li></ol><p>sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile() 只是适用于应用程序地址空间不需要对所访问数据进行处理的情况。相对于 mmap() 方法来说，因为 sendfile 传输的数据没有越过用户应用程序 / 操作系统内核的边界线，所以 sendfile () 也极大地减少了存储管理的开销。</p><p>现在，已经减少了数据拷贝的次数，但是仍然存在一次CPU拷贝，就是页缓存到socket缓存的拷贝。  </p><p>借助于硬件的帮助，可以把这个拷贝省略掉。即：</p><p><img src="//qx-ljy.cn/2019/08/03/linux02/DMASendfile.png" alt></p><p><strong>sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。</strong></p><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>splice() 可以被看成是类似于基于流的管道的实现，管道可以使得两个文件描述符相互连接，splice 的调用者则可以控制两个设备（或者协议栈）在操作系统内核中的相互连接。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p>splice（）在两个文件描述符之间移动数据，而不在内核地址空间和用户地址空间之间进行复制。它将文件描述符fd_in中的len个字节的数据传输到文件描述符fd_out，其中一个描述符必须引用一个管道。  </p><p>如果fd_in引用一个管道，那么off_in必须为NULL。如果fd_in没有引用管道并且off_in为NULL，则从当前文件偏移量开始从fd_in读取字节，并且适当地调整当前文件偏移量。如果fd_in没有引用管道并且off_in不是NULL，那么off_in必须指向一个缓冲区，该缓冲区指定从fd_in读取字节的起始偏移量; 在这种情况下，fd_in的当前文件偏移量不会改变。类似的语句适用于fd_out和off_out。</p><p>flags参数是一个位掩码，它由零个或多个下列值组成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SPLICE_F_NONBLOCK：   splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O</span><br><span class="line">                     ，那么调用 splice 有可能仍然被阻塞。</span><br><span class="line"></span><br><span class="line">SPLICE_F_MORE：       告知操作系统内核下一个 splice 系统调用将会有更多的数据传来。</span><br><span class="line"></span><br><span class="line">SPLICE_F_MOVE：       如果输出是文件，这个值则会使得操作系统内核尝试从输入管道缓冲区直接将数据读入</span><br><span class="line">                      到输出地址空间，这个数据传输过程没有任何数据拷贝操作发生。如果内核不能从pipe</span><br><span class="line">                      移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据。</span><br></pre></td></tr></table></figure><h4 id="splice-和-sendfile-的区别与联系"><a href="#splice-和-sendfile-的区别与联系" class="headerlink" title="splice() 和 sendfile() 的区别与联系"></a>splice() 和 sendfile() 的区别与联系</h4><p>联系：用户应用进程必须拥有两个已经打开的文件描述符，一个用于表示输入设备，一个用于表示输出设备。  </p><p>区别：<br>    1. splice() 允许任意两个文件之间互相连接<br>    2. sendfile()只适用于文件到 socket 进行数据传输。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络IO模型</title>
      <link href="/2019/08/03/linux01/"/>
      <url>/2019/08/03/linux01/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-IO-模式"><a href="#Linux-IO-模式" class="headerlink" title="Linux IO 模式"></a>Linux IO 模式</h1><p>初学netty,但是由于许多铺垫的基础知识了解的并不多，所以从这里开始我的netty学习之路。</p><h2 id="一、概念说明"><a href="#一、概念说明" class="headerlink" title="一、概念说明"></a>一、概念说明</h2><p><strong>1. 用户空间和系统内核</strong>  </p><p>现代操作系统都是虚拟储存器，对于32位操作系统而言，它的寻址空间（虚拟存储空间）为 4G （2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p><strong>2. 进程的阻塞</strong></p><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><p><strong>3. 文件描述符</strong>  </p><p>内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p><p><strong>4. 缓存I/O</strong>  </p><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 I/O 的缺点：  </p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="二、IO模式"><a href="#二、IO模式" class="headerlink" title="二、IO模式"></a>二、IO模式</h2><p>由于对于一次IO操作，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>即两个阶段：</strong></p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)  </li></ol><p>因为这两个阶段产生了五种网络IO模式：</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p><strong>1.  阻塞 I/O（blocking IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/blockingIO.png" alt>  </p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。(IO执行的两个阶段都被block了)  </p><p><strong>2. 非阻塞 I/O（nonblocking IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/nonblockingIO.png" alt>  </p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在只专门提供某种功能的系统中才有。</p><p><strong>3. I/O 多路复用（ IO multiplexing）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/IOmultiplexing.png" alt></p><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。  </p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。  </p><p>整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><p><strong>4. 信号驱动 I/O（ signal driven IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/signaldrivenIO.png" alt>  </p><p>首先开启套接口的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p><p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间，进程不被阻塞。主循环可以继续执行，只要不时等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。  </p><p><strong>5. 异步 I/O（asynchronous IO）</strong>  </p><p><img src="//qx-ljy.cn/2019/08/03/linux01/asynchronousIO.png" alt></p><p>异步I/O（asynchronous I/O）由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到我们自己的缓冲区）完成后通知我们。</p><h2 id="各种模型的比较"><a href="#各种模型的比较" class="headerlink" title="各种模型的比较"></a>各种模型的比较</h2><p><img src="//qx-ljy.cn/2019/08/03/linux01/io.png" alt>  </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java String 对象的分析</title>
      <link href="/2019/08/03/Java01/"/>
      <url>/2019/08/03/Java01/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-String-对象的分析"><a href="#Java-String-对象的分析" class="headerlink" title="Java String 对象的分析"></a>Java String 对象的分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)String 常量存放在常量池中，Java虚拟机处于优化的考虑，会让内容一致的对象共享内存块，</span></span><br><span class="line"><span class="comment">     * 但变量是放在堆内存空间中的，new定义的不同变量内存地址不会相同。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2）String 常量 连接 常量，还是 常量，依然用常量池管理，但 变量 连接 常量 就是 变量了。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(a == b );</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">        Integer ia = <span class="number">1</span>;</span><br><span class="line">        Integer ib = <span class="number">1</span>;</span><br><span class="line">        System.out.println(ia == ib);</span><br><span class="line">        System.out.println(ia.equals(ib));</span><br><span class="line"></span><br><span class="line">        String sc = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String sd = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(sc == sd);</span><br><span class="line">        System.out.println(a == sc);</span><br><span class="line">        System.out.println(sc.equals(sd));</span><br><span class="line"></span><br><span class="line">        String c = <span class="string">"a"</span>;</span><br><span class="line">        String d = c + <span class="string">"bc"</span>;</span><br><span class="line">        String e = <span class="string">"a"</span> + <span class="string">"bc"</span>;</span><br><span class="line">        System.out.println(a == d);</span><br><span class="line">        System.out.println(a == e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String 是不可变的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过new操作在内存中开辟一块空间存放“123”，然后让s1指向存放“123”的内存</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新开辟一块内存存放“abc”，s1 指向 “abc” ， 但是原先 “123” 并没有改变，在垃圾回收时会进行回收。</span></span><br><span class="line">        s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder 是直接在对象上操作</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"abc"</span>).append(<span class="string">"123"</span>);</span><br><span class="line">        stringBuilder.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象用法总结：</strong>  </p><ol><li><p>尽可能使用常量 String s = “abc”; ,避免使用变量，如：String a = new String(“123”);</p></li><li><p>尽量避免大规模针对String的操作（如连接字符串）操作，因为这样会频繁产生内存碎片。这种情况下，建议使用StringBuilder（线程不安全） 和 StringBuffer（线程安全）。如果在单线程下，考虑性能，建议使用StringBuilder。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(三)----类加载机制</title>
      <link href="/2019/08/01/jvm3/"/>
      <url>/2019/08/01/jvm3/</url>
      
        <content type="html"><![CDATA[<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="//qx-ljy.cn/2019/08/01/jvm3/01.png" alt></p><ol><li>加载，验证，准备，初始化，卸载 这五个阶段先后顺序是确定的。但是解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（动态绑定或晚期绑定）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态绑定：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），</span><br><span class="line">此时由编译器或其它连接程序实现。  </span><br><span class="line"></span><br><span class="line">所有私有方法、静态方法、构造器及初始化方法&lt;clinit&gt;都是采用静态绑定机制。</span><br><span class="line">在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要</span><br><span class="line">进行一次常量池解析即可。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">动态绑定：动态绑定（后期绑定）是指：在程序运行过程中，根据具体的实例对象</span><br><span class="line">才能具体确定是哪个方法。</span><br><span class="line"></span><br><span class="line">通俗的是指，对象在调用方法的时候能够自己判断该调用谁的方法。所以动态绑定</span><br><span class="line">一般发生在继承、方法重载时。  </span><br><span class="line"></span><br><span class="line">假设，对象o是类C1的实例，其中C1是C2的子类，C2是C3的子类，那么o也是C2，C3</span><br><span class="line">的实例。如果对象o调用一个方法p，JVM会依次在类C1，C2，C3中查找方法p的实现</span><br><span class="line">，直到找到为止。</span><br><span class="line"></span><br><span class="line">类对象方法的调用必须在运行过程中采用动态绑定机制：</span><br><span class="line"></span><br><span class="line">         首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：</span><br><span class="line"></span><br><span class="line">         ① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。</span><br><span class="line"></span><br><span class="line">         ② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将</span><br><span class="line">         参数类型进行自动转型之后再进行匹配。如果匹配到多个自动转型后的</span><br><span class="line">         方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)</span><br><span class="line">         方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。</span><br><span class="line"></span><br><span class="line">         ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。</span><br><span class="line"></span><br><span class="line">         然后，根据在堆中创建对象的实际类型找到对应的方法表，从中确定具体的方法在内存中的位置。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>JVM规范没有强制约束 <strong>加载</strong> 过程何时开始，这部分可以由虚拟机的具体实现自由把握。但是对于初始化阶段，虚拟机规范严格规定了<strong>有且只有</strong> <strong>5种情况</strong> 必须立即对类进行初始化操作（加载 验证 准备自然要在此之前开始）。</p><ol><li><p>遇到new、getstatic、putstatic、invokestatic四条字节码指令时，如果类没有进行初始化，则必须先触发其初始化操作。</p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化操作。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p></li><li><p>虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类</p></li><li><p>当使用JDK1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄时，并且这个句柄对应的类没有进行初始化，虚拟机需要先触发其初始化操作。</p></li></ol></li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>加载阶段虚拟机需要完成以下3件事情：</strong>  </p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口</p></li></ol><p>对于数组类而言，情况就有所不同，数组本身不通过类加载器创建，它是由虚拟机直接创建的。但是数组类和类加载器仍有密切联系，因为数组类的元素类型最终是要靠类加载器去创建的。</p><p><strong>数组类创建规则：</strong>  </p><ol><li><p>如果数组的元素类型是引用类型，那就使用系统提供的或者用户自定义的类加载器去加载。该数组将在 加载数组元素类型 的类加载器 的类命名空间上被标识。（一个类必须与类加载器一起确定唯一性）</p></li><li><p>如果数组的元素类型不是引用类型（如 int[] 数组），虚拟机会把该数组标记为与引导类加载器关联。</p></li><li><p>数组类的可见性和数组元素类型可见性一致，如果元素类型不是引用类型，那么可见性默认为public。  </p></li></ol><p><strong>加载完成后：</strong></p><p>虚拟机将外部二进制字节流按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机自行实现。然后在内存中实例化一个java.lang.Class对象（Class对象比较特殊，它虽然是对象，但是存放在方法区中），这个对象将作为程序访问方法区中类型数据的外部接口。</p><p>加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段进行的动作，仍属于连接阶段的内容。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机得到要求，不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的动作：</strong>  </p><ol><li><p>文件格式验证</p><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否有不被支持的常量类型<br>。。。。。</li></ul><p>验证点还有很多，这里不一一列举。该验证阶段主要保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个描述Java类型信息的要求。</p><p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区进行存储，后面的验证阶段全部是基于方法区的存储结构进行的，不会再直接操作部字节流。</p></li><li><p>元数据验证</p><p>此阶段是对类的元数据信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</p><p>此阶段部分验证点如下：</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法</p><p>。。。。。</p></li></ul></li><li><p>字节码验证  </p><p>此阶段是验证阶段最复杂的一个阶，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。此阶段对类的方法体进行校验分析，保证校验的类在运行时不会做出危害虚拟机安全的事件。</p></li></ol><p>在JDK1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流分析校验则是唯一选择，不允许退回类型推导的校验方式。</p><ol start="4"><li><p>符号引用验证</p><p>此阶段的验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段—-解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p><p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将抛出java.lang.IncompatibleClassChangeError异常的子类。</p></li></ol><p>对于虚拟机来说，验证阶段是一个非常重要，但不是一定必要的阶段。如果运行的代码经过反复使用和验证，那么在实施阶段可以考虑使用 <strong>-Xverify:none</strong> 参数来关闭大部分的验证措施，缩短类加载时间。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的的内存在方法区中被分配。</p><p>此阶段进行内存分配的仅包括类变量（static修饰），而不包括实例变量，实例变量将会在对象实例化时分配在堆中。此外，这里的初始值是数据类型的零值。但是被 final修饰的类变量 会直接用程序中定义的值进行值初始化。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><ul><li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够使用时能无歧义地定位到目标即可。</p></li><li><p>直接引用：直接引用是可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  初始化阶段是执行类构造器&lt;clinit()&gt;方法的过程</p><ol><li><p>&lt;clinit()&gt;方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}）中的语句结合并产生的。编译器收集顺序是由语句在源代码中出现的顺序决定的，静态语句块中只能访问到定义静态语句块之前的变量。定义在它之后的变量，静态语句块可以赋值，但不能访问。</p></li><li><p>&lt;clinit()&gt;方法和类的构造函数（实例构造器&lt;init()&gt;）不同,它不需要显示地调用父类构造器，虚拟机会保证子类的&lt;clinit()&gt;方法执行之前，父类的&lt;clinit()&gt;方法已经执行完毕。所以虚拟机第一个执行的&lt;clinit()&gt;方法肯定是java.lang.Object。</p></li><li><p>&lt;clinit()&gt;方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit()&gt;方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成&lt;clinit()&gt;方法。但是接口与类不同，执行接口的&lt;clinit()&gt;方法不需要先执行父接口的&lt;clinit()&gt;方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit()&gt;方法。</p></li><li><p>虚拟机会保证一个类的&lt;clinit()&gt;方法在多线程环境中被正确地加锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行类的&lt;clinit()&gt;方法，其他线程需要阻塞等待。</p></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每个类加载器都有一个独立的命名空间。</p><p>比较两个类是否相等：只有这两个类是由同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="//qx-ljy.cn/2019/08/01/jvm3/02.png" alt></p><ol><li><p>启动类加载器（Bootstrap ClassLoader）：这个类负责将存放在<java_home>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法直接被Java程序引用，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</java_home></p></li><li><p>扩展类加载器（Extension ClassLoader）：这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <java_home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</java_home></p></li><li><p>应用程序加载器（Application ClassLoader）：这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ol><p><strong>工作过程：</strong>  </p><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲委派模型的工作过程源码</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            <span class="comment">//父类加载器无法完成类加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order to find the class</span></span><br><span class="line">            <span class="comment">//子加载器进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要链接过程，参数传入</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）当前类加载器从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><p>（2）如果没有找到，就去委托父类加载器去加载（如代码c = parent.loadClass(name, false)所示）。父类加载器也会采用同样的策略，查看自己已经加载过的类中是否包含这个类，有就返回，没有就委托父类的父类去加载，一直到启动类加载器。因为如果父加载器为空了，就代表使用启动类加载器作为父加载器去加载。</p><p>（3）如果启动类加载器加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），则会抛出一个异常ClassNotFoundException，然后再调用当前加载器的findClass()方法进行加载。 </p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p> <strong>自定义类加载器：</strong></p><p> 自定义一个People.java类做例子<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"><span class="comment">//该类写在记事本里，在用javac命令行编译成class文件，放在d盘根目录下</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am a people, my name is "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义一个类加载器，需要继承ClassLoader类，并实现findClass方法。其中defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class（只要二进制字节流的内容符合Class文件规范）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数里使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader mcl = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"People"</span>, <span class="keyword">true</span>, mcl);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getClassLoader());<span class="comment">//打印出我们的自定义类加载器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(四)----docker-compose.yml V3.x 指令详解</title>
      <link href="/2019/07/28/docker04/"/>
      <url>/2019/07/28/docker04/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-compopse-yml-版本和Docker兼容性表"><a href="#docker-compopse-yml-版本和Docker兼容性表" class="headerlink" title="docker-compopse.yml 版本和Docker兼容性表"></a>docker-compopse.yml 版本和Docker兼容性表</h2><p><img src="//qx-ljy.cn/2019/07/28/docker04/001.png" alt>  </p><p><strong>详情请看<a href="https://docs.docker.com/compose/compose-file/#reference-and-guidelines" target="_blank" rel="noopener">官网文档</a></strong>  </p><h2 id="顶级配置项"><a href="#顶级配置项" class="headerlink" title="顶级配置项"></a>顶级配置项</h2><ul><li><p>version 定义了版本信息</p></li><li><p>services 定义了服务的配置信息</p></li><li><p>networks 定义了网络信息，提供给 services 中的 具体容器使用</p></li><li><p>volumes 定义了卷信息，提供给 services 中的 具体容器使用</p></li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  result:</span><br><span class="line">    image: dockersamples/examplevotingapp_result:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5001:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      labels: [APP=VOTING]</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 10s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">  backend:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><h2 id="services配置指令"><a href="#services配置指令" class="headerlink" title="services配置指令"></a>services配置指令</h2><p><strong>1. container_name</strong>  </p><p>指定容器名称</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: redis_test</span><br></pre></td></tr></table></figure><p><strong>2. image</strong>  </p><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br></pre></td></tr></table></figure><p><strong>3. build</strong>  </p><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">也可以使用 context 指令指定 Dockerfile 所在文件夹的路径（或者是git仓库的URL）。同时使用 dockerfile 指令指定 Dockerfile 文件名。</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-name</span><br></pre></td></tr></table></figure><p><strong>注意：<br>如果同时指定了 image和 build， image 不在具有单独使用它的意义，而是指定了目前要构建的镜像的名称。 也就是说 Compose 会使用 build 指令中指定的 Dockerfile  构建的镜像，之后构建的镜像名称使用 image 中指定的名字 webapp:tag命名。</strong></p><p><strong>4. command</strong>  </p><p>使用 command 可以覆盖容器启动后默认执行的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写成shell形式</span></span><br><span class="line"><span class="built_in">command</span>: bundle <span class="built_in">exec</span> thin -p 3000</span><br><span class="line"><span class="comment">#写成Dockerfile中的exec格式</span></span><br><span class="line"><span class="built_in">command</span>: [bundle, <span class="built_in">exec</span>, thin, -p, 3000]</span><br></pre></td></tr></table></figure><p><strong>5. depends_on</strong>   </p><p>解决容器的依赖、启动先后的问题。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: redis_test</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br></pre></td></tr></table></figure><p><strong>6. environment</strong>  </p><p>设置环境变量。可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上的对应变量的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: <span class="string">'true'</span></span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=<span class="literal">true</span></span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**7. expose**  </span><br><span class="line"></span><br><span class="line">暴露端口，但不映射到宿主机，只被连接的服务访问。</span><br><span class="line"></span><br><span class="line">仅可以指定容器内部的端口为参数</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><p><strong>8. ports</strong></p><p>映射端口信息。</p><p>宿主端口：容器端口 (即：HOST:CONTAINER) 的格式格式，或者仅仅指定容器的端口（宿主将会随机选择端口）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"3000-3005"</span></span><br><span class="line"> - <span class="string">"8000:8000"</span></span><br><span class="line"> - <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"> - <span class="string">"49100:22"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"> - <span class="string">"6060:6060/udp"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p></blockquote><p><strong>9. extra_hosts</strong>  </p><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。会在启动后的服务容器中 /etc/hosts 文件中添加host映射信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - <span class="string">"somehost:162.242.195.82"</span></span><br><span class="line"> - <span class="string">"otherhost:50.31.209.229"</span></span><br></pre></td></tr></table></figure><p><strong>10. networks</strong>  </p><p>要加入的网络，使用顶级 networks 定义下的条目 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure><p><strong>11. entrypoint</strong>  </p><p>指定服务容器启动后执行的入口文件。</p><p><strong>12. user</strong>  </p><p>指定容器中运行应用的用户名。</p><p><strong>13. working_dir</strong>  </p><p>指定容器中工作目录。</p><p><strong>14. restart</strong></p><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境 中推荐配置为 always 或者 unless-stopped 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure><p><strong>15. alias</strong>  </p><p>网络上此服务的别名（备用主机名）。同一网络上的其他容器可以使用服务名称或此别名连接到其中一个服务的容器。<br>由于aliases是网络范围的，因此相同的服务可以在不同的网络上具有不同的别名。<br>注意：网络范围的别名可以由多个容器共享，甚至可以由多个服务共享。如果是，则无法保证名称解析为的容器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">         - alias3</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br></pre></td></tr></table></figure><h2 id="volumes配置指令"><a href="#volumes配置指令" class="headerlink" title="volumes配置指令"></a>volumes配置指令</h2><p>数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure><h2 id="volumes配置指令-1"><a href="#volumes配置指令-1" class="headerlink" title="volumes配置指令"></a>volumes配置指令</h2><p><strong>1. 未显式声明网络环境的docker-compose.yml</strong>  </p><p><strong>使用docker-compose up启动容器后，这些容器都会被加入app_default网络中。使用docker network ls可以查看网络列表，docker network inspect <container id>可以查看对应网络的配置。</container></strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    mage: nginx:latest</span><br><span class="line">    container_name: web</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"9090:80"</span></span><br><span class="line">    links:</span><br><span class="line">      - db</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: db</span><br></pre></td></tr></table></figure><p><strong>2. networks关键字指定自定义网络</strong>  </p><p>例如下面的docker-compose.yml文件，定义了front和back网络，实现了网络隔离。其中proxy和db之间只能通过app来实现通信。其中，custom-driver-1并不能直接使用，你应该替换为host, bridge, overlay等选项中的一种。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - back</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front:</span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  back:</span><br><span class="line">    <span class="comment"># Use a custom driver which takes special options</span></span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: <span class="string">"1"</span></span><br><span class="line">      bar: <span class="string">"2"</span></span><br></pre></td></tr></table></figure><p><strong>3. 配置默认网络</strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8000:8000"</span></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    driver: custom-driver-1</span><br></pre></td></tr></table></figure><p><strong>4. 使用已存在的网络</strong>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: my-pre-existing-network</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(三)----Docker 网络详解</title>
      <link href="/2019/07/26/docker03/"/>
      <url>/2019/07/26/docker03/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-网络详解"><a href="#Docker-网络详解" class="headerlink" title="Docker 网络详解"></a>Docker 网络详解</h2><ul><li><p>Bridge contauner   桥接式网络模式</p></li><li><p>Host(open) container   开放式网络模式</p></li><li><p>Container(join) container   联合挂载式网络模式，是host网络模式的延伸</p></li><li><p>None(Close) container   封闭式网络模式</p></li></ul><h2 id="Bridge-桥接式网络模式"><a href="#Bridge-桥接式网络模式" class="headerlink" title="Bridge(桥接式网络模式)"></a>Bridge(桥接式网络模式)</h2><p><strong>1. 介绍</strong>  </p><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机启动的Docker容器会连接到这个虚拟网桥上，默认分配网段为172.17.0.0/16，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机，附加在其上的任何网卡之间都能自动转发数据包。  </p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机创建一对虚拟网卡<a href="https:/www.cnblogs.com/bakari/p/10613710.html" target="_blank" rel="noopener">veth pair 设备</a>,Docker将veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主句中，以vethxxx这样的名字命名，并将这个网络设备加入到docker0网桥中。  </p><p>veth 是 Virtual ETHernet 的缩写，是一种虚拟网络设备。它的特点是：当它被创建以后，总是以两张虚拟网卡（Veth peer）形式成对出现，并且在一个网卡上的数据包可直接转发给另一个与之对应的网卡上，即使这两个网卡不在同一个namespace中。</p><p><strong>2. 容器与容器间的通信</strong>  </p><p>容器1（172.17.0.2）ping 容器2（172.17.0.3）；<br>根据路由规则，数据包从容器1（172.17.0.2）的eth0转发至与之对应的veth上，该veth桥接在了docker0上，此时数据包到达了docker0,docker0扮演交换机的角色，并广播ARP请求寻找容器2（172.17.0.3）的mac地址，而此时容器2的另一个veth 设备桥接在了docker0，并收到ARP请求，发现自己是172.17.0.3 ，故将其mac地址回复给容器1，此时容器1和容器2就可以进行通信了，并且在容器1可以查看到缓存的容器2的mac地址。</p><p><strong>3. 容器与外部网络通讯</strong></p><p>同理，如果容器ping另一个主机，它发出去的数据包经过docker0网桥流向宿主机的eth0网卡，eth0再将数据包转发给与之相通的主机，于是，容器便可以跟其它主机通信了。（主要宿主机eth0能到达，容器都可以与之通信）  </p><p><strong>4. 宿主机与容器通讯</strong></p><p>当宿主机访问容器时，数据包从docker0流入到与容器的eth0对应的veth设备，veth与容器的eth0相通信。  </p><p><strong>5. 外部访问容器</strong>  </p><p>默认情况，其他外部网络（宿主机以外）无法访问到容器内的端口，通常的做法是使用-p或者-P选项，来暴露容器中的端口到宿主机上，外部网络通过访问宿主机的端口从而访问到容器端口。本质上来说，该方式是通过iptables规则转发实现的。  </p><p><strong>6. 自定义网桥</strong>  </p><p>除了使用默认docker0作网桥以为还可以使用docker network 相关命令自定义网桥，以下将创建一个br1的网络，子网是172.30.0.0/16，网关为172.30.0.1。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建br1网桥</span></span><br><span class="line">docker network create -d bridge --subnet <span class="string">'172.30.0.0/16'</span> --gateway <span class="string">'172.30.0.1'</span> br1</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看docker网络</span></span><br><span class="line"> docker network ls</span><br><span class="line"></span><br><span class="line"> NETWORK ID          NAME                    DRIVER              SCOPE</span><br><span class="line"> b9c01f82c16b        br1                     bridge              <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#自定义网桥的使用</span></span><br><span class="line"> docker run -it --network br1 镜像名称 bash</span><br></pre></td></tr></table></figure><h2 id="Host（开放式网络模式）"><a href="#Host（开放式网络模式）" class="headerlink" title="Host（开放式网络模式）"></a>Host（开放式网络模式）</h2><p>Host模式使用是在容器启动时候指明–network host，此时容器共享宿主机的Network Namespace，容器内启动的端口直接是宿主机的端口，并且容器不会创建网卡和IP，直接使用宿主机的网卡和IP，但是容器内的其他资源是隔离的，如文件系统、用户和用户组。这种模式的好处就是效率高，因为不需要额外的网络开始，直接使用宿主机网络。</p><pre><code class="sh">docker run -d --name nginx --network host nginx:latest</code></pre><p><img src="//qx-ljy.cn/2019/07/26/docker03/nginx.png" alt></p><h2 id="Container-联合挂载式网络模式"><a href="#Container-联合挂载式网络模式" class="headerlink" title="Container(联合挂载式网络模式)"></a>Container(联合挂载式网络模式)</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo回环 通信。同样，kubernetes中的pod的话，pod内的网络也是靠这样的共享方式来实现的。</p><h2 id="None（封闭式网络模式）"><a href="#None（封闭式网络模式）" class="headerlink" title="None（封闭式网络模式）"></a>None（封闭式网络模式）</h2><p>使用–network none选项指定其网络模式，在该模式下虽然容器有着自己的Network Namespace，但是容器内没有网卡、IP、路由信息，只有一个lo回环接口。如果需要网络配置则需要用户手动进行配置网卡、ip以及路由信息，通常这样的容器用于承担某些无需网络介入的工作，如离线任务、备份等。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据类型</title>
      <link href="/2019/07/24/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/24/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a>串数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">1~255个字符的定长串。它的长度必须在创建时指定，否则Mysql假定为CHAR(1)</td></tr><tr><td align="left">ENUM</td><td align="left">接受最多64K个串组成的有个预定义集合的某个串</td></tr><tr><td align="left">LONGTEXT</td><td align="left">与TEXT相同，但最大长度为4GB</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">与TEXT相同，但最大长度为16K</td></tr><tr><td align="left">SET</td><td align="left">接受最多64个串组成的一个预定义集合的零个或多个串</td></tr><tr><td align="left">TEXT</td><td align="left">最大长度为64K的变长文本</td></tr><tr><td align="left">TINYTEXT</td><td align="left">与TEXT相同，但最大长度为256字节</td></tr><tr><td align="left">VARCHAR</td><td align="left">长度可变，最多不超过255个字节。如果在创建时指定为VARCHAR(n),则可存储0-n个字符的变长串（其中 n &lt;= 255 ）</td></tr></tbody></table><p><strong>注意：<br>无论使用何种串数据类型，串值都必须在引号内（通常单引号更好）。</strong></p><h2 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">BIT</td><td align="left">位字段，1～64位。（在MySQL 5之前，BIT在功能上等价于TINYINT</td></tr><tr><td align="left">BIGINT</td><td align="left">整数值，支持-9223372036854775808～9223372036854775807（如果是UNSIGNED，为0～18446744073709551615）的数</td></tr><tr><td align="left">BOOLEAN（或BOOL）</td><td align="left">布尔标志，或者为0或者为1，主要用于开/关（on/off）标志</td></tr><tr><td align="left">DECIMAL（或DEC）</td><td align="left">精度可变的浮点值</td></tr><tr><td align="left">DOUBLE</td><td align="left">双精度浮点值</td></tr><tr><td align="left">FLOAT</td><td align="left">单精度浮点值</td></tr><tr><td align="left">INT（或INTEGER）</td><td align="left">整数值，支持 -2147483648～2147483647（如果是UNSIGNED为0～4294967295）的数</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">整数值，支持 -8388608～8388607（如果是UNSIGNED，为0～16777215）的数</td></tr><tr><td align="left">REAL</td><td align="left">4字节的浮点值</td></tr><tr><td align="left">SMALLINT</td><td align="left">整数值，支持 -32768～32767（如果是UNSIGNED，为0～65535）的数</td></tr><tr><td align="left">TINYINT</td><td align="left">整数值，支持 -128～127（如果为UNSIGNED，为0～255）的数</td></tr></tbody></table><h2 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">表示1000-01-01～9999-12-31的日期，格式为YYYY-MM-DD</td></tr><tr><td align="left">DATETIME</td><td align="left">DATE和TIME的组合</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">功能和DATETIME相同（但范围较小）</td></tr><tr><td align="left">TIME</td><td align="left">格式为HH:MM:SS</td></tr><tr><td align="left">YEAR</td><td align="left">用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年</td></tr></tbody></table><h2 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h2><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">BLOB</td><td align="left">Blob最大长度为64 KB</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">Blob最大长度为16 MB</td></tr><tr><td align="left">LONGBLOB</td><td align="left">Blob最大长度为4 GB</td></tr><tr><td align="left">TINYBLOB</td><td align="left">Blob最大长度为255字节</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习(一)----k8s集群部署</title>
      <link href="/2019/07/24/k8s001/"/>
      <url>/2019/07/24/k8s001/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><table><thead><tr><th align="left">角色</th><th align="left">ip</th></tr></thead><tbody><tr><td align="left">master1</td><td align="left">10.10.44.123</td></tr><tr><td align="left">node1</td><td align="left">10.10.44.124</td></tr><tr><td align="left">node2</td><td align="left">10.10.44.125</td></tr><tr><td align="left">node3</td><td align="left">10.10.44.127</td></tr></tbody></table><p>Docker: 18.06.0-ce<br>Kubernetes: v1.15.1</p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>1.关闭交换空间：</p><ul><li>sudo swapoff -a  </li></ul><p>2.避免开机启动交换空间：</p><ul><li>注释 /etc/fstab 中的 swap  </li></ul><p>3.关闭防火墙：  </p><ul><li>systemctl stop firewalld.service            #停止firewall  </li><li>systemctl disable firewalld.service        #禁止firewall开机启动  </li></ul><p>4.安装Docker(这里不再详述，镜像下载速度慢可设置镜像加速器)  </p><p>5.设置hostname  </p><ul><li>hostnamectl set-hostname [hostname]  </li></ul><p>6.创建操作目录</p><ul><li>mkdir -p /opt/kubernetes  </li></ul><h2 id="安装kubeadm，kubelet，kubectl"><a href="#安装kubeadm，kubelet，kubectl" class="headerlink" title="安装kubeadm，kubelet，kubectl"></a>安装kubeadm，kubelet，kubectl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">kubelet --version</span><br><span class="line"><span class="comment">#Kubernetes v1.15.1</span></span><br></pre></td></tr></table></figure><h2 id="配置Kubeadm"><a href="#配置Kubeadm" class="headerlink" title="配置Kubeadm"></a>配置Kubeadm</h2><ol><li>创建并修改配置文件  </li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出配置文件</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  <span class="comment">#修改为主节点 IP</span></span><br><span class="line">  advertiseAddress: 10.10.44.123</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: k8s-master1</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line"><span class="comment"># 国内不能访问，修改为阿里云地址</span></span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line"><span class="comment"># 修改版本号</span></span><br><span class="line">kubernetesVersion: v1.15.1</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line"> <span class="comment"># 配置成 Calico 的默认网段</span></span><br><span class="line">  podSubnet: <span class="string">"192.168.0.0/16"</span></span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line"><span class="comment">#开启IPVS模式</span></span><br><span class="line"><span class="comment">#IPVS (IP Virtual Server，IP虚拟服务器)是基于Netfilter的、作为linux内核的一部分实现传输层负载均衡的技术，通常称为第4层LAN交换。</span></span><br><span class="line"><span class="comment">#kube-proxy是为service构建路由规则的模块，之前依赖iptables来实现主要service类型的支持，比如(ClusterIP和NodePort)。</span></span><br><span class="line"><span class="comment">#但是iptables很难支持上万级的service，因为iptables纯粹是为防火墙而设计的，并且底层数据结构是内核规则的列表。</span></span><br><span class="line"><span class="comment">#基于IPVS的集群内负载均衡就可以完美的解决这个问题。IPVS是专门为负载均衡设计的，并且底层使用哈希表这种非常高效的数据结构，几乎可以允许无限扩容。</span></span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">featureGates:</span><br><span class="line">  SupportIPVSProxyMode: <span class="literal">true</span></span><br><span class="line">mode: ipvs</span><br></pre></td></tr></table></figure><ol start="2"><li>查看拉去镜像</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所需镜像列表</span></span><br><span class="line">kubeadm config images list --config kubeadm.yml</span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yml</span><br></pre></td></tr></table></figure><p><img src="//qx-ljy.cn/2019/07/24/k8s001/k8s01.png" alt>  </p><h2 id="安装-kubernetes-主节点"><a href="#安装-kubernetes-主节点" class="headerlink" title="安装 kubernetes 主节点"></a>安装 kubernetes 主节点</h2><p>执行以下命令初始化主节点，该命令指定了初始化时需要使用的配置文件，其中添加 –experimental-upload-certs 参数可以在后续执行加入节点时自动分发证书文件。追加的 tee kubeadm-init.log 用以输出日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=kubeadm.yml --experimental-upload-certs | tee kubeadm-init.log</span><br><span class="line"></span><br><span class="line">Flag --experimental-upload-certs has been deprecated, use --upload-certs instead</span><br><span class="line">[init] Using Kubernetes version: v1.15.1</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING Hostname]: hostname <span class="string">"k8s-master3"</span> could not be reached</span><br><span class="line">[WARNING Hostname]: hostname <span class="string">"k8s-master3"</span>: lookup k8s-master3 on 202.198.176.1:53: server misbehaving</span><br><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action <span class="keyword">in</span> beforehand using <span class="string">'kubeadm config images pull'</span></span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">"/var/lib/kubelet/kubeadm-flags.env"</span></span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">"/var/lib/kubelet/config.yaml"</span></span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder <span class="string">"/etc/kubernetes/pki"</span></span><br><span class="line">[certs] Generating <span class="string">"ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver-kubelet-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver"</span> certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.10.44.123]</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver-etcd-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/peer"</span> certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 localhost] and IPs [10.10.44.123 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"etcd/healthcheck-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/server"</span> certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed <span class="keyword">for</span> DNS names [k8s-master3 localhost] and IPs [10.10.44.123 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"sa"</span> key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder <span class="string">"/etc/kubernetes"</span></span><br><span class="line">[kubeconfig] Writing <span class="string">"admin.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"kubelet.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"controller-manager.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"scheduler.conf"</span> kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-apiserver"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-controller-manager"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-scheduler"</span></span><br><span class="line">[etcd] Creating static Pod manifest <span class="keyword">for</span> <span class="built_in">local</span> etcd <span class="keyword">in</span> <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[<span class="built_in">wait</span>-control-plane] Waiting <span class="keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="string">"/etc/kubernetes/manifests"</span>. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 35.504680 seconds</span><br><span class="line">[upload-config] Storing the configuration used <span class="keyword">in</span> ConfigMap <span class="string">"kubeadm-config"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap <span class="string">"kubelet-config-1.15"</span> <span class="keyword">in</span> namespace kube-system with the configuration <span class="keyword">for</span> the kubelets <span class="keyword">in</span> the cluster</span><br><span class="line">[upload-certs] Storing the certificates <span class="keyword">in</span> Secret <span class="string">"kubeadm-certs"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">[upload-certs] Using certificate key:</span><br><span class="line">7c96a0027e3c3ef4da2869ea68094f98f593f16b42526f706ef0450dab94f723</span><br><span class="line">[mark-control-plane] Marking the node k8s-master3 as control-plane by adding the label <span class="string">"node-role.kubernetes.io/master=''"</span></span><br><span class="line">[mark-control-plane] Marking the node k8s-master3 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: abcdef.0123456789abcdef</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="keyword">in</span> order <span class="keyword">for</span> nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation <span class="keyword">for</span> all node client certificates <span class="keyword">in</span> the cluster</span><br><span class="line">[bootstrap-token] Creating the <span class="string">"cluster-info"</span> ConfigMap <span class="keyword">in</span> the <span class="string">"kube-public"</span> namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.10.44.123:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:39ddf7bea129f622b444d3257a9e93b5868240683e62596f6ad22c030cd9f8ee</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用 kubeadm 配置 slave 节点  </span></span><br><span class="line"></span><br><span class="line">将 slave 节点加入到集群中很简单，只需要在 slave 服务器上安装 kubeadm，kubectl，kubelet 三个工具，然后使用 kubeadm join 命令加入即可.</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"><span class="comment">#上一节中日志最后部分已经给出加入集群的命令</span></span><br><span class="line">kubeadm join 10.10.44.123:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:39ddf7bea129f622b444d3257a9e93b5868240683e62596f6ad22c030cd9f8ee</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME          STATUS     ROLES    AGE     VERSION</span><br><span class="line">k8s-master3   NotReady   master   9m9s    v1.15.1</span><br><span class="line">k8s-node1     NotReady   &lt;none&gt;   6m22s   v1.15.1</span><br><span class="line">k8s-node2     NotReady   &lt;none&gt;   5m11s   v1.15.1</span><br><span class="line">k8s-node3     NotReady   &lt;none&gt;   5m19s   v1.15.1</span><br></pre></td></tr></table></figure><h2 id="安装网络"><a href="#安装网络" class="headerlink" title="安装网络"></a>安装网络</h2><p>这里选择 calico 作为网络插件  </p><blockquote><p>什么是calico ?<br>Calico 为容器和虚拟机提供了安全的网络连接解决方案，并经过了大规模生产验证（在公有云和跨数千个集群节点中），可与 Kubernetes，OpenShift，Docker，Mesos，DC / OS 和 OpenStack 集成。<br>Calico 还提供网络安全规则的动态实施。使用 Calico 的简单策略语言，您可以实现对容器，虚拟机工作负载和裸机主机端点之间通信的细粒度控制。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 在 Master 节点操作即可</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.7/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line">日志如下：</span><br><span class="line">configmap/calico-config created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">daemonset.extensions/calico-node created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">deployment.extensions/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br></pre></td></tr></table></figure><p><strong>确认安装是否成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch kubectl get pods --all-namespaces</span><br><span class="line"></span><br><span class="line"># 需要等待所有状态为 Running，注意时间可能较久，3 - 5 分钟的样子</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(二)----Docker基础命令</title>
      <link href="/2019/07/23/docker02/"/>
      <url>/2019/07/23/docker02/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>- 镜像</strong>  </p><p>  Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文 件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含任何动态数据，其内容在构建之后也不会被改变。  </p><p>  镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后 一层上的任何改变只发生在自己这一层。  </p><p><strong>- 容器</strong>  </p><p>  镜像（ Image ）和容器（ Container ）的关系，就像 类 和 实例 的关系一样。容器的实质是进程，但与宿主机执行的进程不一样。容器进程运行于属于自己的独立的命名空间（容器可以拥有自己的 root 文件系统，网络配置，进程空间，甚至自己的用户ID空间）。</p><p>  每一个容器运行时，是以镜像为基础层， 在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存 于容器存储层的信息都会随容器删除而丢失。  </p><p>  <strong>注意：</strong> 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有文件的写入操作，都应该使用 数据卷（VOLUME），或者绑定宿主机目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。  </p><p>  数据卷的生存周期独立于容器，容器消亡，数据卷不会。使用数据卷后，容器删除或者重新运行，数据不会丢失。  </p><p><strong>- 仓库</strong>  </p><p>  一个集中地存储、分发镜像的服务，叫做docker仓库(Docker Registry)<br>  仓库可以是私有的，也可以是公开的。</p><h2 id="二、Docker环境信息相关命令"><a href="#二、Docker环境信息相关命令" class="headerlink" title="二、Docker环境信息相关命令"></a>二、Docker环境信息相关命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录docker hub</span></span><br><span class="line">docker login</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行后从指定服务器登出，默认为官方服务器。</span></span><br><span class="line"> docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看docker详细信息</span></span><br><span class="line">docker info</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"><span class="comment">#查看docker 版本信息</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="三、Docker镜像相关命令"><a href="#三、Docker镜像相关命令" class="headerlink" title="三、Docker镜像相关命令"></a>三、Docker镜像相关命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在镜像仓库中搜索</span></span><br><span class="line">docker search [OPTIONS] ImageName  </span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">--automated :只列出 automated build类型的镜像；</span><br><span class="line"></span><br><span class="line">--no-trunc :显示完整的镜像描述；</span><br><span class="line"></span><br><span class="line">-s :列出收藏数不小于指定值的镜像。</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#镜像拉取</span></span><br><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line"></span><br><span class="line">-a :拉取所有 tagged 镜像</span><br><span class="line"></span><br><span class="line">--<span class="built_in">disable</span>-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出镜像列表</span></span><br><span class="line">docker images ls</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看镜像、容器、数据卷所占用的空间</span></span><br><span class="line">docker system df</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">```sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本操作</title>
      <link href="/2019/07/20/git/"/>
      <url>/2019/07/20/git/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 仓库操作</strong></p><ul><li>git init   (创建一个Git仓库)</li><li>git clone [url]  （拷贝一个git仓库到本地）</li></ul><blockquote><p>工作流 ：<br>本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index）,它像个缓存区域，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。  </p></blockquote><p><strong>2. 将文件添加到缓存区</strong></p><ul><li><p>git add [filename]  </p></li><li><p>git add .  </p><p>不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</p></li><li><p>git add -u .  </p><p>-u  == –update ，表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</p></li><li><p>git add -A .  </p><p>-A == –all  ， 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。  </p></li></ul><p><strong>3. 将改动提交到 HEAD，但是不到远端仓库</strong>  </p><ul><li>git commit -m “代码提交信息”</li></ul><p><strong>4. 推送改动</strong></p><ul><li><p>git push origin master  </p><p>git commit 之后，你的改动已经在本地仓库的HEAD中了，执行此上命令，可提交至远端仓库，master 可换成你想推送的任何分支。</p></li><li><p>git remote add origin [url]  </p><p>使用此命令可将你的仓库连接到某个远程服务器，此后你就可以将改动推送到添加的服务器中了。</p></li></ul><p><strong>5. 分支</strong></p><ul><li><p>git checkout -b [分支名称]  </p><p>新建分支并切换到该分支</p></li><li><p>git checkout master<br>切换到指定分支  </p></li><li><p>git branch -d [分支命称]<br>将新建分支删掉  </p></li></ul><p><strong>6. 更新与合并</strong>  </p><ul><li><p>git pull<br>按照git branch 设置的默认跟踪的服务器和分支来拉取  </p></li><li><p>git pull origin master<br>拉取远程服务器origin 的master分支  </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(二)----JVM内存结构</title>
      <link href="/2019/07/14/jvm2/"/>
      <url>/2019/07/14/jvm2/</url>
      
        <content type="html"><![CDATA[<p><strong>经典JVM内存布局（JDK8以上）</strong>  </p><p><img src="//qx-ljy.cn/2019/07/14/jvm2/jvm2.png" alt></p><h2 id="一、Heap（堆区）"><a href="#一、Heap（堆区）" class="headerlink" title="一、Heap（堆区）"></a>一、Heap（堆区）</h2><p><strong>Heap存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各个子线程共享使用。</strong> 通常情况下，它占用的空间是所有内存区域中最大的，同时也是OOM（Out Of Memory）故障最主要的发源地。  </p><p>堆的内存空间既可以固定大小，也可以在运行时动态地调整。  </p><p>通过如下参数设置初始值和最大值，比如-Xms256M -Xmx1024M （-X表示它是JVM运行参数，ms是memory start（最小堆容量）的简称，mx是memory max（最大堆容量）的简称）。由于服务器在不断运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以在线上生产环境中，JVM的Xms Xmx 设置成一样大小，避免在GC调整堆大小时带来的额外压力。</p><p><strong>堆分为两大块：新生代和老年代。</strong> 对象产生之初在新生代，步入暮年进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。  </p><p><strong>新生代 = 1个Eden区 + 2个Survivor区。</strong> 绝大部分对象在Eden区生成，当Eden区填满的时候，后触发Young Garbage Collection（YGC）。垃圾回收的时候在Eden区实现清除策略，没有被引用的对象则直接回收。仍然存活的对象会被移送到Survivor区。Survivor区被分为S0和S1两块内存空间，每次YGC的时候，他们将存活的对象复制到未使用那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Survivor区容量的上限，则直接移交给老年代。<br><strong>每个对象都有一个计数器，每次YGC都会加1。-XX:MaxTenuringThreshold参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升到老年代。默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</strong> 如果参数配置为1，那么从新生代的Eden区直接移至老年代。<br>如果Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代进行分配；如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。可设置参数 -XX:+HeapDumpOnOutOfMemoryError,让JVM遇到OOM时输出堆内信息。  </p><h2 id="二、方法区"><a href="#二、方法区" class="headerlink" title="二、方法区"></a>二、方法区</h2><ul><li><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>元空间的前身为永久代（Perm），在JDK8之后被淘汰，在JDK7及之前的版本中，只有Hotspot才有Perm区，译为永久代，它在启动的时候固定大小，很难进行调优，并且FGC时会移动类元信息。  </p></li><li><p>区别于永久代，元空间在本地内存中分配。在JDK8里，Perm区中的所有内容中  字符串常量移至堆内存，其他内容包括类元信息，字段，静态属性，方法，常量等移动至元空间内。</p></li></ul><h2 id="三、JVM-Stack（虚拟机栈）"><a href="#三、JVM-Stack（虚拟机栈）" class="headerlink" title="三、JVM Stack（虚拟机栈）"></a>三、JVM Stack（虚拟机栈）</h2><ul><li><p>java虚拟机栈是线程私有的，生命周期与线程相同。  </p></li><li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈入栈到出栈的过程。</p></li><li><p>Java虚拟机规范中对这个区域规定两种异常情况：   </p><ol><li>OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；</li><li>StackOverflowError（线程请求的栈深度 &gt; 虚拟机所允许的深度）；</li></ol></li></ul><p>  虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。  </p><p><strong>1. 局部变量表</strong>  </p><p>  局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段，局部变量没有准备阶段，必须显式化初始化。如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。  </p><p><strong>2. 操作栈</strong>  </p><p>操作栈是一个初始状态为空的桶式结构栈。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的stack属性中。</p><p><strong>3. 动态连接</strong>  </p><p>每个栈帧中包含一个在常量池中对当前方法的引用，目的就是支持方法调用过程的动态连接。  </p><p><strong>4. 方法返回地址</strong>  </p><p>方法执行有两种退出情况：第一，正常退出；第二，异常退出。无论哪种退出情况，都将返回至方法当前被调用的位置。方法退出相当于弹出当前栈帧。</p><p><strong>退出的三种方式：</strong>  </p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给能够处理的栈帧</li><li>PC计数器指向方法调用后的下一条指令  </li></ul><h2 id="四、本地方法栈"><a href="#四、本地方法栈" class="headerlink" title="四、本地方法栈"></a>四、本地方法栈</h2><ul><li><p>本地方法栈描述的是Native方法执行的内存模型  </p></li><li><p>可能抛出的异常：与 Java 虚拟机栈一样。  </p></li></ul><p>本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，而本地方法栈“主外”。本地方法栈为Native方法服务。<br>线程开始调用本地方法时，会进入一个不再受JVM约束的世界。本地方法可以通过JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为他的出错信息比较黑盒。对于内存不足的情况，本地方法栈还是会抛出native heap OutOfMemory。  </p><h2 id="五、程序计数器（Program-Counter-Register，PC）"><a href="#五、程序计数器（Program-Counter-Register，PC）" class="headerlink" title="五、程序计数器（Program Counter Register，PC）"></a>五、程序计数器（Program Counter Register，PC）</h2><ul><li><p>程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p>JVM多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，所以，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程互不影响，独立存储，线程私有。</p></li><li><p>线程执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行Native方法，这个计数器值为空（Undefined）。</p></li><li><p>此区域是唯一一个JVM规范中没有规定任何OOM（OutOfMemoryError）情况的区域。  </p></li></ul><p>  每个线程创建后，都会产生自己的程序计数器和栈帧，程序计数器都用来存放执行指令的偏移量和行号指示器等，线程执行和恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。  </p><p><strong>从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本地方法栈、程序计数器是线程内部私有的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(一)----JVM基本概念</title>
      <link href="/2019/07/13/jvm1/"/>
      <url>/2019/07/13/jvm1/</url>
      
        <content type="html"><![CDATA[<p><strong>一、什么是JVM</strong>  </p><p>JVM(Java Virtual Machine) ,中文名java虚拟机，是由软件技术模拟出计算机运行的一个虚拟计算机。</p><p>java程序经过编译后，产生 .class 文件， jvm 才能识别并运行它，jvm 针对每个操作系统开发出对应的编译器，所以只要其操作系统有对应版本的jvm，那么java程序便能运行起来，这是java可以一次编译，到处运行的原因。</p><p><strong>二、JRE、JDK和JVM的关系</strong>  </p><p><strong>JRE（Java Runtime Environment， Java运行环境）</strong> 是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。</p><p><strong>JDK（Java Development Kit，Java开发工具包）</strong> 是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API ）。</p><p><strong>JVM（Java Virtual Machine， Java虚拟机）</strong> 是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性。</p><p><strong>三、JVM基本概念</strong></p><p>jvm基本结构如下:  </p><p> <img src="//qx-ljy.cn/2019/07/13/jvm1/jvm1.png" alt="jvm基本结构"></p><p> <strong>说明：</strong> 方法区：线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也称之为永久代，有一个别名叫做Non-Heap（非堆）。  </p><p>在JDK8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域取代。元空间的本质和永久代类似，都是对jvm规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在于虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入元空间，字符串和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统实际可用空间控制。</p><p><strong>采用元空间代替永久代的原因：</strong>  </p><ol><li>字符串存在永久代中，容易出现性能和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出（因为堆内存有限，此消彼长）</li><li>永久代会为GC带来不必要的复杂度，并且回收效率低。</li></ol><p><strong>四、JVM生命周期</strong></p><ol><li><strong>启动：</strong> 启动一个Java程序，一个JVM实例就产生。拥有public static void main(String[] args)函数的class可以作为JVM实例运行的起点。</li><li><strong>运行：</strong> main()作为程序初始线程的起点，任何其他线程均可由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM使用，程序可以指定创建的线程为守护线程。</li><li><strong>消亡：</strong> 当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</li></ol><p><strong>五、JVM体系</strong></p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习(一)----Dockerfile基础指令</title>
      <link href="/2019/07/06/docker01/"/>
      <url>/2019/07/06/docker01/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Dockerfile简介"><a href="#一、Dockerfile简介" class="headerlink" title="一、Dockerfile简介"></a>一、Dockerfile简介</h2><p>  Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令，Docker程序将这些Dockerfile指令翻译真正的Linux命令；Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile，Docker程序将读取Dockerfile，根据指令生成定制的image。</p><p>  Dockerfile的指令是忽略大小写的，建议使用大写，使用#作为注释，每一行只支持一条指令，每条指令可以携带多个参数。</p><p>  Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层， 因此每一条指令的内容，就是描述该层应当如何构建。  </p><h2 id="二、dockerfile指令详解"><a href="#二、dockerfile指令详解" class="headerlink" title="二、dockerfile指令详解"></a>二、dockerfile指令详解</h2><p><strong>1. FROM</strong>  </p><p>  功能为指定基础镜像，并且必须是第一条指令。  </p><p>  除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为scratch。这个镜像 是虚拟的概念，并不实际存在，它表示一个空白的镜像。<br>  如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始构建。  </p><p>  不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如swarm、coreos/etcd 。对于Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小 巧。使用Go语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><p><strong>2. MAINTAINER</strong>  </p><p>  格式为 MAINTAINER <name>，指定维护者信息。</name></p><p><strong>3. RUN</strong>  </p><p>  用来执行命令行命令  </p><ul><li>shell格式：RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样</li><li>exec格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式  </li></ul><p>使用 &amp;&amp; 符连接多个命令； \ 符进行换行。</p><p>为防止镜像臃肿，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉（编译构建所需要的软件，所有下载、展开的文件，apt缓存文件等）。  </p><p><strong>4. CMD</strong>  </p><ul><li>shell格式：CMD &lt;命令&gt;</li><li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li><li>参数列表格式：CMD [“参数1”, “参数2”…]，提供给 ENTRYPOINT 的默认参数  </li></ul><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p><p>Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用upstart/systemd去启动后台服务，容器内没有后台服务的概念。   </p><p>CMD service nginx start ，如果这样写会出现容器执行后立即退出了，这主要是因为没搞明白前台和后台的概念，没有区分容器和虚拟机的差异，对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，进而退出，其他辅助进程不是他关心的内容。 上述命令可以理解为 CMD[ “sh”, “-c”, “service nginx start”]  ，因此主进程是sh ,sh结束，主进程退出，自然容器也会退出。正确的做法是 CMD [ “nginx”, “-g”, “daemon off;” ]</p><p><strong>5. ENTRYPOINT</strong>  </p><p>两种格式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”]</li><li>ENTRYPOINT command param1 param2（shell中执行）  </li></ul><p>配置容器启动后执行的命令，ENTRYPOINT 在运行时也可以替代，不过比CMD要略显繁琐，需要通过docker run的参数 -entrypoint来指定。</p><p><strong>当指定了ENTRYPOINT后，CMD的含义就发生了改变：</strong></p><p>如果CMD中不是完整的命令，则将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为 ENTRYPOINT CMD。  </p><p>如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效。  </p><p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。  </p><p><strong>6. EXPOSE</strong>  </p><ul><li>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]  </li></ul><p>功能为暴漏容器运行时的监听端口给外部，但是EXPOSE并不会使容器访问主机的端口，如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数。  </p><p>-P：大写P为自动映射，会将EXPOSE暴露出来的端口随机映射到宿主机的端口上，如果没有暴露端口，就不会有映射。<br>-p：小写p为手动映射，需要自己指定宿主机的端口和容器的端口，形式为：<br>-p    宿主机端口：容器端口</p><p>（1）无论有没有暴露端口、自动映射或者手动映射，宿主机都可以通过容器ip+port（port随容器内部服务监听端口改变而改变）端口访问服务；  </p><p>（2）要通过宿主机ip+端口的方式访问服务，宿主机的端口必须与容器端口有映射关系；</p><p>（3）如果没有暴露端口，-P自动映射不会映射任何端口，-p可以指定宿主机端口和容器端口形成映射。</p><p><strong>7. ENV</strong>  </p><ol><li>ENV &lt;键&gt; &lt;值&gt;</li><li>ENV &lt;键&gt;=&lt;值&gt; …  </li></ol><p>两者的区别就是第一种是一次设置一个，第二种是一次设置多个  </p><p>下列指令可以支持环境变量展开：<br><strong>ADD、COPY 、ENV、EXPOSE 、LABEL 、USER 、WORKDIR 、VOLUME 、STOPSIGNAL、ONBU ILD</strong>  </p><p><strong>使用环境变量方式： $环境变量</strong>  </p><p><strong>8. COPY</strong></p><p>将从构建上下文目录中&lt;源路径&gt;的文件或者目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。  </p><p>此外，还需要注意一点，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git 进行管理的时候。  </p><ul><li>COPY：&lt;源路径&gt;… &lt;目标路径&gt;   </li><li>COPY： [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY src1 \</span><br><span class="line">     src2 \</span><br><span class="line">     WORKDIR/</span><br></pre></td></tr></table></figure><p>执行上述操作会发现将src1 src2 下的文件全部复制到WORKDIR下，并没有复制目录src1 src2，官方对于COPY解释是：</p><blockquote><p>Note: The directory itself is not copied, just its contents.</p></blockquote><p>即：COPY指令拷贝一个文件夹只会拷贝文件夹的内容。  </p><p>上述指令可以这样写：  </p><pre><code class="sh">COPY src1 \     src2 \     WORKDIR/src</code></pre><p>这样将COPY的文件，放在了新创建的src目录下。  </p><p><strong>9. ADD</strong>  </p><p>ADD指令和COPY的格式和性质基本一致，不过&lt;源文件&gt;可以是一个URL,同时如果源文件是一个压缩文件，ADD会自动执行解压缩。  </p><p>因此在COPY 和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩的场合使用ADD 。  </p><p><strong>10. VOLUME</strong>  </p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]   </li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存 动态数据的应用，其数据库文件应该保存于卷(volume)中。  </p><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p><p><strong>如何使用：</strong><br>在Dockerfile中定义匿名卷，运行容器时，使用参数 <strong>-v 宿主机目录:匿名卷</strong>  进行挂载，实现了数据持久化。  </p><p><strong>11. WORKDIR</strong>  </p><ul><li>WORKDIR &lt;工作目录路径&gt;   </li></ul><p>使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。  </p><p>可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。  </p><pre><code class="sh">WORKDIR /aWORKDIR bWORKDIR cRUN <span class="built_in">pwd</span>  则最终路径为 /a/b/c。</code></pre><p><strong>12. USER</strong></p><ul><li>USER &lt;用户名&gt;   </li></ul><p>USER是改变之后层的执行RUN ,CMD以及ENTRYPOINT这类命令的身份。USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。  </p><p><strong>13. ONBUILD</strong>  </p><ul><li>ONBUILD &lt;其它指令&gt;   </li></ul><p>ONBUILD是一个特殊的指令，它后面跟的是其它指令，比如RUN ,COPY等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br>Dockerfile中的其它指令都是为了定制当前镜像而准备的，唯有ONBUILD是为了帮助别人定制自己而准备的。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown的基本使用</title>
      <link href="/2019/07/05/markdown1/"/>
      <url>/2019/07/05/markdown1/</url>
      
        <content type="html"><![CDATA[<h2 id="MarkDown基本使用"><a href="#MarkDown基本使用" class="headerlink" title="MarkDown基本使用"></a>MarkDown基本使用</h2><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>‘#’ 符号 + 空格 +  标题<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure></p><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul><li><p>斜体  </p><p>要倾斜的文字左右分别用一个*号包起来</p></li><li><p>加粗  </p><p>要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体加粗  </p><p>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线  </p><p>要加删除线的文字左右分别用两个~~号包起来</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;  三个&gt;&gt;&gt;</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">**********************</span><br></pre></td></tr></table></figure><hr><hr><h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line">  ![测试图片](test.jpg)</span><br></pre></td></tr></table></figure><p>  <img src="//qx-ljy.cn/2019/07/05/markdown1/test.jpg" alt="测试图片"></p><h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul><li>无序列表  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><ol><li>列表内容  </li><li>列表内容</li><li>列表内容</li></ol><ul><li>列表嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上一级和下一级之间敲三个空格即可</span><br></pre></td></tr></table></figure><h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(```java)</span><br><span class="line">(```)</span><br><span class="line"></span><br><span class="line">注：为了防止转义，加了小括号。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
